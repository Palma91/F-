<?xml version="1.0" encoding="UTF-8"?>
<doc>
<assembly><name>FSharp.Core</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.BuildSettings.BuildDetails">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.BuildSettings.Version">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Tail">
 <summary>Получает хвост списка, который содержит все элементы списка, за исключением первого элемента </summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Length">
 <summary>Получает количество элементов, содержащихся в списке</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Item(System.Int32)">
 <summary>Получает элемент списка, расположенный в указанной позиции.</summary>
 <remarks>Списки представляются как связанные списки, поэтому это операция O(n).</remarks>
 <param name="index">Индекс.</param>
 <returns>Значение по указанному индексу.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.IsEmpty">
 <summary>Получает значение, указывающее на отсутствие записей в списке</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Head">
 <summary>Получает первый элемент списка</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Empty">
 <summary>Возвращает пустой список определенного типа.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.Cons(`0,Microsoft.FSharp.Collections.FSharpList{`0})">
 <summary>Возвращает список, первым элементом в котором указан <c>заголовок</c>, а последующими — <c>хвост</c>.</summary>
 <param name="head">Новое значение заголовка списка.</param>
 <param name="tail">Существующий список.</param>
 <returns>Список с заголовком прикреплен к началу хвоста.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpList`1">
 <summary>Тип неизменяемых однонаправленных списков.</summary>

 <remarks>Используйте конструкторы <c>[]</c> и <c>::</c> (инфикс) для создания значений этого типа либо нотацию <c>[1;2;3]</c>. Значения в модуле <c>List</c> можно использовать для управления значениями данного типа или сопоставления шаблона со значениями напрямую.</remarks>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Item(`0)">
 <summary>Выполняет поиск элемента в сопоставлении. Создайте исключение <c>KeyNotFoundException</c>, если привязка в сопоставлении отсутствует.</summary>
 <param name="key">Входной ключ.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если ключ не найден.</exception>
 <returns>Значение, сопоставляемое с ключом.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.IsEmpty">
 <summary>Возвращает значение true, если в сопоставлении нет привязок.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Count">
 <summary>Количество привязок в сопоставлении.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.TryFind(`0)">
 <summary>Выполните поиск элемента в сопоставлении, возвращая значение <c>Some</c>, если элемент найден в области сопоставления, или значение <c>None</c>, если элемент не найден.</summary>
 <param name="key">Входной ключ.</param>
 <returns>Возвращается сопоставленное значение или значение None, если ключа нет в сопоставлении.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Remove(`0)">
 <summary>Удаляет элемент из домена сопоставления. Если элемент не существует, исключение не создается.</summary>
 <param name="key">Входной ключ.</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.ContainsKey(`0)">
 <summary>Проверяет, входит ли элемент в домен сопоставления.</summary>
 <param name="key">Входной ключ.</param>
 <returns>Значение true, если сопоставление содержит заданный ключ.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Add(`0,`1)">
 <summary>Возвращает новое сопоставление с привязкой, добавленной в заданное сопоставление.</summary>
 <param name="key">Входной ключ.</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
 <summary>Формирует сопоставление, содержащее привязки указанного элемента IEnumerable.</summary>
 <param name="elements">Входная последовательность пар "ключ-значение".</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpMap`2">
 <summary>Неизменяемые сопоставления. Ключи упорядочиваются посредством универсального сравнения F#.</summary>
 
 <remarks>Сопоставления на основе универсального сравнения удобны для небольших ключей. Но они не подходят, если ключи — это рекурсивные структуры данных или для ключей требуется специальная семантика сравнения. Все элементы этого класса являются потокобезопасными и могут быть использованы одновременно из нескольких потоков.</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">
 <summary>Сокращение для типа CLI <c>System.Collections.Generic.List&lt;_&gt;</c></summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Subtraction(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Возвращает новый набор, в котором из элементов первого набора удалены элементы второго набора.</summary>
 <param name="set1">Первый входной набор.</param>
 <param name="set2">Второй входной набор.</param>
 <returns>Набор, содержащий элементы первого набора, которые отсутствуют во втором наборе.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Addition(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Вычисляет объединение двух наборов.</summary>
 <param name="set1">Первый входной набор.</param>
 <param name="set2">Второй входной набор.</param>
 <returns>Объединение двух входных наборов.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MinimumElement">
 <summary>Возвращает минимальный элемент набора в соответствии с правилами упорядочения, используемыми для этого набора.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MaximumElement">
 <summary>Возвращает наибольший элемент набора в соответствии с правилами упорядочения, используемыми для набора.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.IsEmpty">
 <summary>Полезный ярлык для Set.isEmpty. Дополнительные сведения об операциях с наборами см. в описании модуля Set.</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.Count">
 <summary>Число элементов в наборе</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Remove(`0)">
 <summary>Полезный ярлык для Set.remove. Примечание. Эта операция создает новый набор и не изменяет исходный набор. Новый набор будет использовать многие узлы хранения совместно с оригинальным набором. Дополнительные сведения об операциях с наборами см. в описании модуля Set.</summary>
 <param name="value">Значение, которое необходимо удалить из набора.</param>
 <returns>Результирующий набор.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Принимает значение true, если все элементы второго набора присутствуют в первом.</summary>
 <param name="otherSet">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если данное множество является надмножеством <c>otherSet</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Принимает значение true, если все элементы первого набора присутствуют во втором наборе.</summary>
 <param name="otherSet">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если данное множество является подмножеством <c>otherSet</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Принимает значение true, если все элементы второго набора присутствуют в первом, и хотя бы один элемент первого набора не входит во второй.</summary>
 <param name="otherSet">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если данное множество является надлежащим надмножеством <c>otherSet</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Принимает значение true, если все элементы первого набора присутствуют во втором и хотя бы один элемент второго набора не входит в первый.</summary>
 <param name="otherSet">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если данное множество является надлежащим подмножеством <c>otherSet</c>.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Contains(`0)">
 <summary>Полезный ярлык для Set.contains. Дополнительные сведения об операциях с наборами см. в описании модуля Set.</summary>
 <param name="value">Проверяемое значение.</param>
 <returns>Значение true, если данное множество содержит <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Add(`0)">
 <summary>Полезный ярлык для Set.add. Примечание. Эта операция создает новый набор и не изменяет исходный набор. Новый набор будет использовать многие узлы хранения совместно с оригинальным набором. Дополнительные сведения об операциях с наборами см. в описании модуля Set.</summary>
 <param name="value">Значение, которое добавляется в набор.</param>
 <returns>Результирующий набор.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>Создает набор, содержащий элементы из данной последовательности.</summary>
 <param name="elements">Входная последовательность.</param>
 <returns>Результирующий набор.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpSet`1">
 <summary>Неизменяемые наборы на основе двоичных деревьев, где сравнение представляет собой функцию структурного сравнения F#, теоретически использующую реализации интерфейса IComparable применительно к значениям ключей.</summary>

 <remarks>Дополнительные сведения об операциях с наборами см. в описании модуля Set. Все элементы этого класса являются потокобезопасными и могут быть использованы одновременно из нескольких потоков.</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">
 <summary>Сокращенное обозначение типа неизменяемых однонаправленных списков. </summary>

 <remarks>Используйте конструкторы <c>[]</c> и <c>::</c> (инфикс) для создания значений этого типа либо нотацию <c>[1;2;3]</c>. Значения в модуле <c>List</c> можно использовать для управления значениями данного типа или сопоставления шаблона со значениями напрямую.</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.seq`1">
 <summary>Сокращение для типа CLI <c>System.Collections.Generic.IEnumerable&lt;_&gt;</c></summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Get``1(``0[0:,0:],System.Int32,System.Int32)">
 <summary>Получает элемент из двухмерного массива. Кроме того, можно использовать синтаксис <c>array.[index1,index2]</c>.</summary>

 <param name="array">Входной массив.</param>
 <param name="index1">Индекс в первом измерении.</param>
 <param name="index2">Индекс во втором измерении.</param>

 <returns>Значение массива по указанному индексу.</returns>
 <exception cref="System.ArgumentException">Создается, если индекс является отрицательным числом или выходит за границы массива.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Set``1(``0[0:,0:],System.Int32,System.Int32,``0)">
 <summary>Задает значение элемента в массиве. Кроме того, можно использовать синтаксис <c>array.[index1,index2] &lt;- value</c>.</summary>

 <param name="array">Входной массив.</param>
 <param name="index1">Индекс в первом измерении.</param>
 <param name="index2">Индекс во втором измерении.</param>
 <param name="value">Значение, устанавливаемое в массиве.</param>
 <exception cref="System.ArgumentException">Создается, если индекс является отрицательным числом или выходит за границы массива.</exception> 
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Rebase``1(``0[0:,0:])">
 <summary>Формирует новый массив, с такими элементами, как и у входного массива, при этом входной массив с индексацией, начинающейся не с нуля, создает соответствующий массив с индексацией, начинающейся с нуля.</summary>

 <param name="array">Входной массив.</param>

 <returns>Массив с индексацией с нуля.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},``0[0:,0:])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива. Целочисленные индексы, переданные функции, указывают преобразуемый элемент.</summary>

 <remarks>При обработке массивов, индексация которых ведется не с нуля, в выходном массиве будет сохраняться способ индексации входного массива.</remarks>

 <param name="mapping">Функция, которая применяется для преобразования каждого элемента массива. Два целых числа задают индекс элемента.</param>
 <param name="array">Входной массив.</param>

 <returns>Массив, элементы которого преобразованы заданным сопоставлением.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[0:,0:])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива.</summary>

 <remarks>При обработке массивов, индексация которых ведется не с нуля, в выходном массиве будет сохраняться способ индексации входного массива.</remarks>

 <param name="mapping">Функция, которая применяется для преобразования каждого элемента входного массива.</param>
 <param name="array">Входной массив.</param>

 <returns>Массив, элементы которого преобразованы заданным сопоставлением.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length2``1(``0[0:,0:])">
 <summary>Возвращает длину массива по второму измерению.</summary>

 <param name="array">Входной массив.</param>

 <returns>Длина массива по второму измерению.</returns>  
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length1``1(``0[0:,0:])">
 <summary>Возвращает длину массива по первому измерению.</summary>

 <param name="array">Входной массив.</param>

 <returns>Длина массива по первому измерению.</returns>  
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}},``0[0:,0:])">
 <summary>Применяет заданную функцию к каждому элементу массива. Целочисленные индексы, переданные функции, обозначают индекс элемента.</summary>

 <param name="action">Функция, применяемая к каждому элементу массива с индексами в качестве аргумента.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[0:,0:])">
 <summary>Применяет заданную функцию к каждому элементу массива.</summary>

 <param name="action">Функция преобразования, применяемая к каждому элементу массива.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Создает массив, записям которого изначально присваивается Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="base1">Начальное значение первой размерности массива.</param>
 <param name="base2">Начальное значение второй размерности массива.</param>
 <param name="length1">Длина первого измерения массива.</param>
 <param name="length2">Длина второго измерения массива.</param>

 <returns>Созданный массив.</returns>
 <exception cref="System.ArgumentException">Создается, если значение base1, base2, length1 или length2 является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Создает массив, элементам которого изначально присваивается заданное значение.</summary>

 <param name="base1">Начальное значение первой размерности массива.</param>
 <param name="base2">Начальное значение второй размерности массива.</param>
 <param name="length1">Длина первого измерения массива.</param>
 <param name="length2">Длина второго измерения массива.</param>
 <param name="initial">Значение, которым необходимо заполнить новый массив.</param>

 <returns>Созданный массив.</returns>
 <exception cref="System.ArgumentException">Создается, если значение base1, base2, length1 или length2 является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.InitializeBased``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
 <summary>Создает массив с учетом заданных измерений и функции генератора для вычисления элементов.</summary>

 <param name="base1">Начальное значение первой размерности массива.</param>
 <param name="base2">Начальное значение второй размерности массива.</param>
 <param name="length1">Длина первого измерения массива.</param>
 <param name="length2">Длина второго измерения массива.</param>
 <param name="initializer">Функция для создания элементов массива с двумя указанными индексами.</param>

 <returns>Созданный массив.</returns>
 <exception cref="System.ArgumentException">Создается, если значение base1, base2, length1 или length2 является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreate``1(System.Int32,System.Int32)">
 <summary>Создает массив, записям которого изначально присваивается Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="length1">Длина первого измерения массива.</param>
 <param name="length2">Длина второго измерения массива.</param>

 <returns>Созданный массив.</returns>
 <exception cref="System.ArgumentException">Создается, если значение length1 или length2 является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Create``1(System.Int32,System.Int32,``0)">
 <summary>Создает массив, элементам которого изначально присваивается заданное значение.</summary>

 <param name="length1">Длина первого измерения массива.</param>
 <param name="length2">Длина второго измерения массива.</param>
 <param name="value">Значение, которым необходимо заполнить новый массив.</param>

 <returns>Созданный массив.</returns>
 <exception cref="System.ArgumentException">Создается, если значение length1 или length2 является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Initialize``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
 <summary>Создает массив с учетом заданных измерений и функции генератора для вычисления элементов.</summary>

 <param name="length1">Длина первого измерения массива.</param>
 <param name="length2">Длина второго измерения массива.</param>
 <param name="initializer">Функция для создания элементов массива с двумя указанными индексами.</param>

 <returns>Созданный массив.</returns>
 <exception cref="System.ArgumentException">Вызывается, если любое из значений длины отрицательное.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CopyTo``1(``0[0:,0:],System.Int32,System.Int32,``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Считывает диапазон элементов из первого массива и записывает их во второй.</summary>

 <param name="source">Исходный массив.</param>
 <param name="sourceIndex1">Индекс в первом измерении, с которого следует начать копирование из исходного массива.</param>
 <param name="sourceIndex2">Индекс во втором измерении, с которого следует начать копирование из исходного массива.</param>
 <param name="target">Целевой массив.</param>
 <param name="targetIndex1">Индекс в первом измерении, с которого следует начать копирование в целевой массив.</param>
 <param name="targetIndex2">Индекс во втором измерении, с которого следует начать копирование в целевой массив.</param>
 <param name="length1">Число элементов для копирования по первому измерению массивов.</param>
 <param name="length2">Число элементов для копирования по второму измерению массивов.</param>
 <exception cref="System.ArgumentException">Создается в случае указания отрицательного значения индекса или при превышении заданных чисел максимального значения, разрешенного соответствующим измерением.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Copy``1(``0[0:,0:])">
 <summary>Формирует новый массив, содержащий те же элементы, что и входной массив.</summary>

 <remarks>При обработке массивов, индексация которых ведется не с нуля, в выходном массиве будет сохраняться способ индексации входного массива.</remarks>

 <param name="array">Входной массив.</param>

 <returns>Копия входного массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base2``1(``0[0:,0:])">
 <summary>Выдает базовый индекс второго измерения массива.</summary>

 <param name="array">Входной массив.</param>

 <returns>Базовый индекс второго измерения массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base1``1(``0[0:,0:])">
 <summary>Получает базовый индекс первого измерения массива.</summary>

 <param name="array">Входной массив.</param>

 <returns>Базовый индекс первого измерения массива.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.Array2DModule">
 <summary>Основные операции над двухмерными массивами.</summary>

 <remarks>Индексация многомерных массивов F# и CLI обычно ведется с нуля. Однако в многомерных массивах CLI, используемых в сочетании с внешними библиотеками (например, библиотеками, связанными с Visual Basic), индексация может начинаться не с нуля, а с потенциально разных значений для каждого измерения. Операции в этом модуле принимают такие массивы, а основание входного массива распространяется на соответствующий выходной массив в ходе операций <c>Array2D.map</c> и <c>Array2D.mapi</c>. Массивы, индексация которых начинается не с нуля, также могут создаваться с помощью <c>Array2D.zeroCreateBased</c>, <c>Array2D.createBased</c> и <c>Array2D.initBased</c>.</remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32)">
 <summary>Создает массив, элементам которого изначально присваивается значение "по умолчанию".</summary>
 <param name="length1">Длина по первому измерению.</param>
 <param name="length2">Длина по второму измерению.</param>
 <param name="length3">Длина по третьему измерению.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Set``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32,``0)">
 <summary>Задает значение элемента в массиве. Можно также использовать синтаксис array.[index1,index2,index3] &lt;- value.</summary>
 <param name="array">Входной массив.</param>
 <param name="index1">Индекс в первом измерении.</param>
 <param name="index2">Индекс во втором измерении.</param>
 <param name="index3">Индекс в третьем измерении.</param>
 <param name="value">Задаваемое по данному индексу значение.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}}},``0[0:,0:,0:])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива. Целочисленные индексы, переданные функции, указывают преобразуемый элемент.</summary>

 <remarks>При обработке массивов, индексация которых ведется не с нуля, в выходном массиве будет сохраняться способ индексации входного массива.</remarks>
 <param name="mapping">Функция для преобразования элемента по каждому индексу в массиве.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив, созданный при помощи преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[0:,0:,0:])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива.</summary>

 <remarks>При обработке массивов, индексация которых ведется не с нуля, в выходном массиве будет сохраняться способ индексации входного массива.</remarks>
 <param name="mapping">Функция для преобразования каждого элемента массива.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив, созданный при помощи преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length3``1(``0[0:,0:,0:])">
 <summary>Возвращает длину массива по третьему измерению.</summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по третьему измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length2``1(``0[0:,0:,0:])">
 <summary>Возвращает длину массива по второму измерению.</summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по второму измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length1``1(``0[0:,0:,0:])">
 <summary>Возвращает длину массива по первому измерению  </summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по первому измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}}},``0[0:,0:,0:])">
 <summary>Применяет заданную функцию к каждому элементу массива. Целочисленные индексы, передаваемые функции, обозначают индекс элемента.</summary>
 <param name="action">Функция преобразования, применяемая к каждому элементу массива.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[0:,0:,0:])">
 <summary>Применяет заданную функцию к каждому элементу массива.</summary>
 <param name="action">Функция преобразования, применяемая к каждому элементу массива.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Get``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32)">
 <summary>Получает элемент из трехмерного массива. Можно также использовать синтаксис array.[index1,index2,index3]</summary>
 <param name="array">Входной массив.</param>
 <param name="index1">Индекс в первом измерении.</param>
 <param name="index2">Индекс во втором измерении.</param>
 <param name="index3">Индекс в третьем измерении.</param>
 <returns>Значение по указанному индексу.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Initialize``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}})">
 <summary>Создает массив с учетом заданных измерений и функции генератора для вычисления элементов.</summary>
 <param name="length1">Длина по первому измерению.</param>
 <param name="length2">Длина по второму измерению.</param>
 <param name="length3">Длина по третьему измерению.</param>
 <param name="initializer">Функция для создания начального значения массива по каждому индексу.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Create``1(System.Int32,System.Int32,System.Int32,``0)">
 <summary>Создает массив, элементам которого изначально присваивается заданное значение.</summary>
 <param name="length1">Длина по первому измерению.</param>
 <param name="length2">Длина по второму измерению.</param>
 <param name="length3">Длина по третьему измерению.</param>
 <param name="initial">Значение элементов массива.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.Array3DModule">
 <summary>Основные операции над массивами 3 ранга.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Set``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Задает значение элемента в массиве. Можно также использовать синтаксис array.[index1,index2,index3,index4] &lt;- value.</summary>
 <param name="array">Входной массив.</param>
 <param name="index1">Индекс в первом измерении.</param>
 <param name="index2">Индекс во втором измерении.</param>
 <param name="index3">Индекс в третьем измерении.</param>
 <param name="index4">Индекс в четвертом измерении.</param>
 <param name="value">Задаваемое значение.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Get``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Получает элемент из четырехмерного массива. Можно также использовать синтаксис array.[index1,index2,index3,index4]</summary>
 <param name="array">Входной массив.</param>
 <param name="index1">Индекс в первом измерении.</param>
 <param name="index2">Индекс во втором измерении.</param>
 <param name="index3">Индекс в третьем измерении.</param>
 <param name="index4">Индекс в четвертом измерении.</param>
 <returns>Значение по указанному индексу.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Создает массив, элементам которого изначально присваивается значение "по умолчанию".</summary>
 <param name="length1">Длина по первому измерению.</param>
 <param name="length2">Длина по второму измерению.</param>
 <param name="length3">Длина по третьему измерению.</param>
 <param name="length4">Длина по четвертому измерению.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length4``1(``0[0:,0:,0:,0:])">
 <summary>Возвращает длину массива по четвертому измерению.</summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по четвертому измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length3``1(``0[0:,0:,0:,0:])">
 <summary>Возвращает длину массива по третьему измерению.</summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по третьему измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length2``1(``0[0:,0:,0:,0:])">
 <summary>Возвращает длину массива по второму измерению.</summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по второму измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length1``1(``0[0:,0:,0:,0:])">
 <summary>Возвращает длину массива по первому измерению  </summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива по первому измерению.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Initialize``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}}})">
 <summary>Создает массив с учетом заданных измерений и функции генератора для вычисления элементов.</summary>
 <param name="length1">Длина по первому измерению.</param>
 <param name="length2">Длина по второму измерению.</param>
 <param name="length3">Длина по третьему измерению.</param>
 <param name="length4">Длина по четвертому измерению.</param>
 <param name="initializer">Функция, предназначенная для создания начального значения в каждом индексе массива.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Create``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Создает массив, элементам которого изначально присваивается заданное значение</summary>
 <param name="length1">Длина по первому измерению.</param>
 <param name="length2">Длина по второму измерению.</param>
 <param name="length3">Длина по третьему измерению.</param>
 <param name="length4">Длина по четвертому измерению.</param>
 <param name="initial">Начальное значение каждого элемента массива.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.Array4DModule">
 <summary>Основные операции над массивами 4 ранга. </summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip3``3(``0[],``1[],``2[])">
 <summary>Объединяет три массива в массив пар. Длины трех массивов должны быть одинаковы, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <param name="array3">Третий входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Массив кортежных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip``2(``0[],``1[])">
 <summary>Объединяет два массива в массив пар. Длины двух массивов должны быть одинаковы, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Массив кортежных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip3``3(System.Tuple{``0,``1,``2}[])">
 <summary>Разделяет массив триад на три массива.</summary>
 <param name="array">Входной массив.</param>
 <returns>Кортеж трех массивов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip``2(System.Tuple{``0,``1}[])">
 <summary>Разделяет массив пар на два массива.</summary>
 <param name="array">Входной массив.</param>
 <returns>Два массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Возвращает индекс первого элемента массива, который удовлетворяет заданному предикату.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Индекс первого элемента, удовлетворяющего предикату, или значение None.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Возвращает первый элемент, для которого заданная функция возвращает значение <c>true</c>. Возвращает значение <c>None</c>, если такого элемента не существует.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Первый элемент, удовлетворяющий предикату или None.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToSeq``1(``0[])">
 <summary>Обеспечивает просмотр заданного массива в виде последовательности.</summary>
 <param name="array">Входной массив.</param>
 <returns>Последовательность элементов массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToList``1(``0[])">
 <summary>Формирует список из заданного массива.</summary>
 <param name="array">Входной массив.</param>
 <returns>Список элементов массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Возвращает сумму результатов, созданную путем применения функции к каждому элементу массива.</summary>
 <param name="projection">Функция для преобразования элементов массива в суммируемый тип.</param>
 <param name="array">Входной массив.</param>
 <returns>Результирующая сумма.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sum``1(``0[])">
 <summary>Возвращает сумму элементов в массиве.</summary>
 <param name="array">Входной массив.</param>
 <returns>Результирующая сумма.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlace``1(``0[])">
 <summary>Сортирует элементы массива посредством изменения массива на месте, используя заданную функцию сравнения. Для сравнения элементов используется оператор Operators.compare.</summary>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])">
 <summary>Сортирует элементы массива посредством изменения массива на месте, используя заданную функцию сравнения по порядку.</summary>
 <param name="comparer">Функция, используемая для сравнения пар элементов массива.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Сортирует элементы массива посредством изменения массива на месте, используя заданную проекцию для ключей. Для сравнения элементов используется оператор Operators.compare.</summary>

 <remarks>Это не стабильная сортировка, то есть исходный порядок равных элементов не обязательно сохраняется. Для обеспечения стабильных результатов сортировки можно использовать Seq.sort.</remarks>
 <param name="projection">Функция для преобразования элементов массива в сравниваемый тип.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])">
 <summary>Сортирует элементы массива, используя заданную функцию сравнения по порядку и возвращая новый массив.</summary>

 <remarks>Это не стабильная сортировка, то есть исходный порядок равных элементов не обязательно сохраняется. Для обеспечения стабильных результатов сортировки можно использовать Seq.sort.</remarks>
 <param name="comparer">Функция, используемая для сравнения пар элементов массива.</param>
 <param name="array">Входной массив.</param>
 <returns>Сортируемый массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Сортирует элементы массива, используя заданную проекцию для ключей и возвращая новый массив. Для сравнения элементов используется оператор Operators.compare.</summary>

 <remarks>Это не стабильная сортировка, то есть исходный порядок равных элементов не обязательно сохраняется. Для обеспечения стабильных результатов сортировки можно использовать Seq.sort.</remarks>
 <param name="projection">Функция для преобразования элементов массива в сравниваемый тип.</param>
 <param name="array">Входной массив.</param>
 <returns>Сортируемый массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sort``1(``0[])">
 <summary>Сортирует элементы массива, возвращая новый массив. Для сравнения элементов используется оператор Operators.compare. </summary>

 <remarks>Это не стабильная сортировка, то есть исходный порядок равных элементов не обязательно сохраняется. Для обеспечения стабильных результатов сортировки можно использовать Seq.sort.</remarks>
 <param name="array">Входной массив.</param>
 <returns>Сортируемый массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.GetSubArray``1(``0[],System.Int32,System.Int32)">
 <summary>Формирует новый массив, содержащий заданный поддиапазон, который определяется по начальному индексу и длине.</summary>
 <param name="array">Входной массив.</param>
 <param name="startIndex">Индекс первого элемента подмассива.</param>
 <param name="count">Длина подмассива.</param>
 <returns>Созданный подмассив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Set``1(``0[],System.Int32,``0)">
 <summary>Задает элемент массива.</summary>
 <param name="array">Входной массив.</param>
 <param name="index">Входной индекс.</param>
 <param name="value">Входное значение.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)">
 <summary>Действует как функция <c>foldBack</c>, но возвращает и промежуточный, и конечный результаты.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="array">Входной массив.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Массив значений состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])">
 <summary>Действует как функция <c>fold</c>, но возвращает промежуточный и конечный результаты.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="state">Начальное состояние.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив значений состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reverse``1(``0[])">
 <summary>Возвращает новый массив с элементами в обратном порядке.</summary>
 <param name="array">Входной массив.</param>
 <returns>Обращенный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Применяет функцию к каждому элементу массива, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f i0 (...(f iN-1 iN))</c>. Если размер массива равен нулю, создается исключение ArgumentException.</summary>
 <param name="reduction">Функция для приведения пар элементов к одному элементу.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входной массив пуст.</exception>
 <returns>Результат выглядит следующим образом:</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Применяет функцию к каждому элементу массива, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f (... (f i0 i1)...) iN</c>. Если размер массива равен нулю, создается исключение ArgumentException.</summary>
 <param name="reduction">Функция для приведения пар элементов к одному элементу.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входной массив пуст.</exception>
 <returns>Конечный результат приведений.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},``0[])">
 <summary>Возвращает массив со всеми элементами, переставленными в соответствии с указанной перестановкой.</summary>
 <param name="indexMap">Функция, сопоставляющая входные индексы с выходными.</param>
 <param name="array">Входной массив.</param>
 <returns>Выходной массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Разделяет коллекцию на две коллекции, содержащие те элементы, для которых заданный предикат возвращает соответственно значения true и false.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Пара массивов. Первый массив содержит элементы, для которых предикат возвращает значение true, а второй — элементы, для которых предикат возвращает значение false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует новый массив из заданного перечисляемого объекта.</summary>
 <param name="source">Входная последовательность.</param>
 <returns>Массив элементов последовательности.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Формирует массив из заданного списка.</summary>
 <param name="list">Входной список.</param>
 <returns>Массив элементов из списка.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Возвращает минимальный элемент массива, определенный посредством сравнения с результатом функции с помощью оператора Operators.min.</summary>

 <remarks>Создает исключение ArgumentException для пустых массивов.</remarks>
 <param name="projection">Функция для преобразования элементов в тип, поддерживающий сравнение.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входной массив пуст.</exception>
 <returns>Минимальный элемент.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Min``1(``0[])">
 <summary>Возвращает минимальный элемент массива, определенный посредством оператора Operators.min.</summary>

 <remarks>Создает исключение ArgumentException для пустых массивов</remarks>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входной массив пуст.</exception>
 <returns>Минимальный элемент.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Возвращает максимальный элемент массива, определенный посредством сравнения с результатом функции с помощью оператора Operators.max.</summary>

 <remarks>Создает исключение ArgumentException для пустых массивов.</remarks>
 <param name="projection">Функция для преобразования элементов в тип, поддерживающий сравнение.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входной массив пуст.</exception>
 <returns>Максимальный элемент.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Max``1(``0[])">
 <summary>Возвращает максимальный элемент массива, определенный посредством сравнения с результатом функции с помощью оператора Operators.max.</summary>

 <remarks>Создает исключение ArgumentException для пустых массивов.</remarks>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входной массив пуст.</exception>
 <returns>Максимальный элемент.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива. Целочисленный индекс, переданный функции, обозначает индекс преобразуемого элемента.</summary>
 <param name="mapping">Функция для преобразования элементов и их индексов.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0[],``1[])">
 <summary>Формирует новую коллекцию, элементы которой являются результатом попарного применения заданной функции к соответствующим элементам двух коллекций, а также передает индекс элементов. Длины двух входных массивов должны совпадать, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="mapping">Функция для преобразования пар входных элементов и их индексов.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Массив преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])">
 <summary>Формирует новую коллекцию, элементы которой являются результатом попарного применения заданной функции к соответствующим элементам двух коллекций. Длины двух входных массивов должны совпадать, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="mapping">Функция для преобразования пар входных элементов.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Массив преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива.</summary>
 <param name="mapping">Функция, используемая для преобразования элементов массива.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Length``1(``0[])">
 <summary>Возвращает длину массива. Можно также использовать свойство arr.Length.</summary>
 <param name="array">Входной массив.</param>
 <returns>Длина массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},``0[],``1[])">
 <summary>Применяет заданную функцию к паре элементов, извлеченных из соответствующих индексов в двух массивах, а также передает индекс элементов. Длины двух входных массивов должны совпадать, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="action">Функция, применяемая к каждому индексу и паре элементов.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``0[])">
 <summary>Применяет заданную функцию к каждому элементу массива. Целое число, переданное функции, обозначает индекс элемента.</summary>
 <param name="action">Функция, применяемая к каждому индексу и элементу.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``0[],``1[])">
 <summary>Применяет заданную функцию к паре элементов, извлеченных из соответствующих индексов в двух массивах. Длины двух входных массивов должны совпадать, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="action">Применяемая функция.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[])">
 <summary>Применяет заданную функцию к каждому элементу массива.</summary>
 <param name="action">Применяемая функция.</param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IsEmpty``1(``0[])">
 <summary>Возвращает значение true, если заданный массив пуст; в противном случае возвращает значение false.</summary>
 <param name="array">Входной массив.</param>
 <returns>Значение true, если массив пуст.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ZeroCreate``1(System.Int32)">
 <summary>Создает массив, записям которого изначально присваивается значение по умолчанию Unchecked.defaultof&lt;'T&gt;.</summary>
 <param name="count">Длина создаваемого массива.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Создает массив с учетом заданного измерения и функции генератора для вычисления значений элементов.</summary>
 <param name="count">Число инициализируемых элементов.</param>
 <param name="initializer">Функция для создания начальных значений для каждого индекса.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Get``1(``0[],System.Int32)">
 <summary>Получает элемент массива.</summary>
 <param name="array">Входной массив.</param>
 <param name="index">Входной индекс.</param>
 <returns>Значение массива по указанному индексу.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},``0[],``1[],``2)">
 <summary>Применяет функцию к парам элементов, извлеченных из двух коллекций, справа налево, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Длины двух входных массивов должны совпадать, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <param name="state">Начальное состояние.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Конечное состояние.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,``0[],``1[])">
 <summary>Применяет функцию к парам элементов, извлеченных из двух коллекций, слева направо, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Длины двух входных массивов должны совпадать, в противном случае создается исключение <c>ArgumentException</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="state">Начальное состояние.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Конечное состояние.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)">
 <summary>Применяет функцию к каждому элементу массива, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f i0 (...(f iN s))</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="array">Входной массив.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Конечное состояние.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f (... (f s i0)...) iN</c></summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="state">Начальное состояние.</param>
 <param name="array">Входной массив.</param>
 <returns>Конечное состояние.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])">
 <summary>Проверяет, все ли соответствующие элементы массива попарно удовлетворяют заданному предикату.</summary>

 <remarks>Предикат применяется к соответствующим элементам двух коллекций до длины, более короткой из этих коллекций. Если любая из проверок возвращает значение false, то для окончательного результата также устанавливается значение false, а проверка последующих элементов не выполняется. В противном случае, если одна коллекция длиннее другой, создается исключение <c>ArgumentException</c>. В остальных случаях возвращается значение true.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если входные массивы имеют разную длину.</exception>
 <returns>Значение true, если все элементы массива удовлетворяют предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Проверяет, все ли элементы массива удовлетворяют заданному предикату.</summary>

 <remarks>Предикат применяется к элементам входной коллекции. Если любая из проверок возвращает значение false, то для окончательного результата также устанавливается значение false, а проверка последующих элементов не выполняется. В остальных случаях возвращается значение true.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Значение true, если все элементы массива удовлетворяют предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Возвращает индекс первого элемента массива, который удовлетворяет заданному предикату. Если ни один элемент не удовлетворяет предикату, создается исключение <c>KeyNotFoundException</c>.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если предикат <c>predicate</c> никогда не возвращает значение true.</exception>
 <returns>Индекс первого элемента в массиве, который удовлетворяет заданному предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Возвращает первый элемент, для которого заданная функция возвращает значение true. Если такого элемента не существует, создается исключение <c>KeyNotFoundException</c>.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если предикат <c>predicate</c> никогда не возвращает значение true.</exception>
 <returns>Первый элемент, для которого предикат <c>predicate</c> возвращает значение true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Возвращает новую коллекцию, содержащую только те элементы коллекции, для которых заданный предикат возвращает значение true.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив, содержащий только те элементы, для которых указанный предикат возвращает значение true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])">
 <summary>Проверяет, удовлетворяет ли какая-либо пара соответствующих элементов массивов заданному предикату.</summary>

 <remarks>Предикат применяется к соответствующим элементам двух коллекций до длины, более короткой из этих коллекций. Если любая из проверок возвращает значение true, то для окончательного результата также устанавливается значение true, а проверка последующих элементов не выполняется. В противном случае, если одна коллекция длиннее другой, создается исключение <c>ArgumentException</c>. В противном случае возвращается значение false.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <returns>Значение true, если любой результат предиката <c>predicate</c> — true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Проверяет, удовлетворяет ли какой-либо элемент массива заданному предикату.</summary>

 <remarks>Предикат применяется к элементам входного массива. Если любая из проверок возвращает значение true, то для окончательного результата также устанавливается значение true, а проверка последующих элементов не выполняется. В противном случае возвращается значение false.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Значение true, если любой результат предиката <c>predicate</c> — true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Empty``1">
 <summary>Возвращает пустой массив заданного типа.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Применяет заданную функцию к каждому элементу массива. Возвращает массив, состоящий из результатов x для каждого элемента, где функция возвращает значение Some(x)</summary>
 <param name="chooser">Функция для создания параметров из элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>Массив результатов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Применяет заданную функцию к идущим подряд элементам, возвращая первый результат, в котором функция возвращает <c>Some(x)</c> для некоторого <c>x</c>. Если функция никогда не возвращает <c>Some(x)</c>, создается исключение <c>KeyNotFoundException</c>.</summary>
 <param name="chooser">Функция для создания параметров из элементов.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если каждый результат <c>chooser</c> — <c>None</c>.</exception>
 <returns>Первый результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fill``1(``0[],System.Int32,System.Int32,``0)">
 <summary>Заполняет диапазон элементов массива заданным значением.</summary>
 <param name="target">Целевой массив.</param>
 <param name="targetIndex">Индекс первого задаваемого элемента.</param>
 <param name="count">Число задаваемых элементов.</param>
 <param name="value">Задаваемое значение.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Применяет заданную функцию к идущим подряд элементам, возвращая первый результат, в котором функция возвращает <c>Some(x)</c> для некоторого <c>x</c>. Если функция никогда не возвращает <c>Some(x)</c>, возвращается исключение <c>None</c>.</summary>
 <param name="chooser">Функция для преобразования каждого элемента массива в параметры.</param>
 <param name="array">Входной массив.</param>
 <returns>Первый преобразованный элемент, равный <c>Some(x)</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Create``1(System.Int32,``0)">
 <summary>Создает массив, элементам которого изначально присваивается заданное значение.</summary>
 <param name="count">Длина создаваемого массива.</param>
 <param name="value">Значение элементов.</param>
 <returns>Созданный массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Copy``1(``0[])">
 <summary>Формирует новый массив, содержащий элементы заданного массива.</summary>
 <param name="array">Входной массив.</param>
 <returns>Копия входного массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Concat``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>Формирует новый массив, содержащий элементы каждой заданной последовательности массивов.</summary>
 <param name="arrays">Входная последовательность массивов.</param>
 <returns>Объединенная последовательность входных массивов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},``0[])">
 <summary>Применяет заданную функцию к каждому элементу массива. Сцепляет все результаты и возвращает объединенный массив.</summary>
 <param name="mapping">Функция для создания подмассивов из входных элементов массива.</param>
 <param name="array">Входной массив.</param>
 <returns>Объединение подмассивов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CopyTo``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
 <summary>Считывает диапазон элементов из первого массива и записывает их во второй.</summary>
 <param name="source">Исходный массив.</param>
 <param name="sourceIndex">Начальный индекс исходного массива.</param>
 <param name="target">Целевой массив.</param>
 <param name="targetIndex">Начальный индекс исходного целевого массива.</param>
 <param name="count">Число элементов для копирования.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Возвращает среднее значение элементов, созданных путем применения функции к каждому элементу массива.</summary>
 <param name="projection">Функция для преобразования элементов массива перед вычислением среднего значения.</param>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если массив <c>array</c> пуст.</exception>
 <returns>Вычисленное среднее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Average``1(``0[])">
 <summary>Возвращает среднее значение элементов в массиве.</summary>
 <param name="array">Входной массив.</param>
 <exception cref="System.ArgumentException">Создается, если массив <c>array</c> пуст.</exception>
 <returns>Среднее значение элементов в массиве.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Append``1(``0[],``0[])">
 <summary>Формирует новый массив, содержащий элементы первого массива, за которыми следуют элементы второго массива.</summary>
 <param name="array1">Первый входной массив.</param>
 <param name="array2">Второй входной массив.</param>
 <returns>Результирующий массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Разделяет коллекцию на две коллекции, содержащие те элементы, для которых заданный предикат возвращает соответственно значения true и false. </summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к индексам, не задан.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>'T[] * 'T[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Создает массив с учетом заданного измерения и функции генератора для вычисления значений элементов.</summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к индексам, не задан.</remarks>
 <param name="count"></param>
 <param name="initializer"></param>
 <returns>'T[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``0[])">
 <summary>Применение заданной функции к каждому элементу массива. Целое число, переданное функции, обозначает индекс элемента.</summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к элементам входного массива, не задан.</remarks>
 <param name="action"></param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[])">
 <summary>Применение заданной функции к каждому элементу массива. </summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к элементам входного массива, не задан.</remarks>
 <param name="action"></param>
 <param name="array">Входной массив.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива. Целочисленный индекс, переданный функции, обозначает индекс преобразуемого элемента.</summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к элементам входного массива, не задан.</remarks>
 <param name="mapping"></param>
 <param name="array">Входной массив.</param>
 <returns>'U[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Формирует новый массив, элементы которого являются результатами применения заданной функции к каждому элементу массива.</summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к элементам входного массива, не задан.</remarks>
 <param name="mapping"></param>
 <param name="array">Входной массив.</param>
 <returns>'U[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},``0[])">
 <summary>Применяет заданную функцию к каждому элементу массива. Сцепляет все результаты и возвращает объединенный массив.</summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к элементам входного массива, не задан.</remarks>
 <param name="mapping"></param>
 <param name="array">Входной массив.</param>
 <returns>'U[]</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Применение заданной функции к каждому элементу массива. Возвращает массив, состоящий из результатов x для каждого элемента, где функция возвращает значение Some(x).</summary>

 <remarks>Выполняет операцию параллельно с помощью System.Threading.Parallel.For. Порядок, в котором заданная функция применяется к элементам входного массива, не задан.</remarks>
 <param name="chooser">Функция для создания параметров из элементов.</param>
 <param name="array">Входной массив.</param>
 <returns>'U[]</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule.Parallel">
 <summary>Обеспечивает параллельные действия над массивами </summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule">
 <summary>Основные операции над массивами.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
 <summary>Сравнение с помощью указанной функции компаратора.</summary>
 <param name="comparer">Функция, сравнивающая два значения.</param>
 <returns>Объект, реализующий IComparer с помощью предоставленного компаратора.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
 <summary>Структурное сравнение. Сравнение с помощью оператора Operators.compare.</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
 <summary>Общие понятия идентификации сравнения, используемой с отсортированными структурами данных.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunctions``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}})">
 <summary>Хэш, используемый заданные функции хэширования и равенства.</summary>
 <param name="hasher">Функция для создания хэш-кода из значения.</param>
 <param name="equality">Функция для проверки равенства двух значений.</param>
 <returns>Объект, реализующий IEqualityComparer с помощью предоставленных функций.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
 <summary>Физическое хэширование (хэш ссылочного идентификатора объектов и содержимое типов значений). Хэширование с использованием LanguagePrimitives.PhysicalEquality и LanguagePrimitives.PhysicalHash. Т.е. для значений типов используется GetHashCode и Object.Equals (если другая оптимизация недоступна), а для ссылочных типов используется System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode и ссылочное равенство.</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
 <summary>Структурное хэширование. Хэширование с использованием операторов Operators.(=) и Operators.hash.</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
 <summary>Общие понятия идентификации значений, используемой с хэш-таблицами.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Объединяет три списка в список триад. Списки должны иметь одинаковую длину.</summary>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <param name="list3">Третий входной список.</param>
 <returns>Единый список, содержащий триады соответствующих элементов из входных списков.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Объединяет два списка в список пар. Два списка должны иметь одинаковую длину.</summary>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <returns>Единый список, содержащий пары соответствующих элементов из входных списков.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1,``2}})">
 <summary>Разделяет список триад на три списка.</summary>
 <param name="list">Входной список.</param>
 <returns>Три списка разделенных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
 <summary>Разделяет список пар на два списка.</summary>
 <param name="list">Входной список.</param>
 <returns>Два списка разделенных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает индекс первого элемента в списке, который удовлетворяет заданному предикату. Возвращает значение <c>None</c>, если такого элемента не существует.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Индекс первого элемента, для которого предикат возвращает значение true, или значение None, если все элементы дают значение false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает первый элемент, для которого заданная функция возвращает значение <c>true</c>. Возвращает значение <c>None</c>, если такого элемента не существует.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Первый элемент, для которого предикат возвращает значение true, или значение None, если все элементы дают значение false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет заданную функцию к идущим подряд элементам, возвращая <c>Some(x)</c> — первый результат, в котором функция возвращает <c>Some(x)</c> для некоторого x. Если такого элемента не существует, возвращает <c>None</c>.</summary>
 <param name="chooser">Функция для создания параметров из элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Первое результирующее значение или None.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Просматривает заданный список как последовательность.</summary>
 <param name="list">Входной список.</param>
 <returns>Последовательность элементов списка.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Формирует массив из заданного списка.</summary>
 <param name="list">Входной список.</param>
 <returns>Массив, содержащий элементы списка.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Tail``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает список после удаления первого элемента.</summary>

 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Список после удаления первого элемента.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает сумму результатов, созданную путем применения функции к каждому элементу списка.</summary>
 <param name="projection">Функция для преобразования элементов списка в суммируемый тип.</param>
 <param name="list">Входной список.</param>
 <returns>Результирующая сумма.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sum``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает сумму элементов в списке.</summary>
 <param name="list">Входной список.</param>
 <returns>Результирующая сумма.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sort``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Сортирует заданный список с помощью Operators.compare.</summary>

 <remarks>Это стабильная сортировка, то есть исходный порядок равных элементов сохраняется.</remarks>
 <param name="list">Входной список.</param>
 <returns>Сортируемый список.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Сортирует заданный список с помощью указанных проекцией ключей. Для сравнения ключей используется Operators.compare.</summary>

 <remarks>Это стабильная сортировка, то есть исходный порядок равных элементов сохраняется.</remarks>
 <param name="projection">Функция для преобразования элементов списка в тип, который нужно сравнить.</param>
 <param name="list">Входной список.</param>
 <returns>Сортируемый список.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Сортирует заданный список с помощью указанной функции сравнения.</summary>

 <remarks>Это стабильная сортировка, то есть исходный порядок равных элементов сохраняется.</remarks>
 <param name="comparer">Функция, используемая для сравнения элементов списка.</param>
 <param name="list">Входной список.</param>
 <returns>Сортируемый список.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Действует как функция <c>foldBack</c>, но возвращает и промежуточный, и конечный результаты.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="list">Входной список.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Список состояний.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Принимает второй аргумент и применяет функцию к нему и к первому элементу списка. Затем передает этот результат в функцию вместе со вторым элементом и т. д. Возвращает список промежуточных результатов и конечный результат.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="state">Начальное состояние.</param>
 <param name="list">Входной список.</param>
 <returns>Список состояний.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reverse``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает новый список с элементами в обратном порядке.</summary>
 <param name="list">Входной список.</param>
 <returns>Обращенный список.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Replicate``1(System.Int32,``0)">
 <summary>Создает список путем вызова заданного генератора для каждого индекса.</summary>
 <param name="count">Число реплицируемых элементов.</param>
 <param name="initial">Реплицируемое значение.</param>
 <returns>Созданный список.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f i0 (...(f iN-1 iN))</c>.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст</remarks>
 <param name="reduction">Функция для приведения двух элементов списка к одному элементу.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Окончательное приведенное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Примените функцию к двум первым элементам списка. Затем передайте этот результат в функцию вместе с третьим элементом и т. д. Возвращает окончательный результат. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f (... (f i0 i1) i2 ...) iN</c>.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст</remarks>
 <param name="reduction">Функция для приведения двух элементов списка к одному элементу.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Окончательное приведенное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает список со всеми элементами, переставленными в соответствии с указанной перестановкой.</summary>
 <param name="indexMap">Функция, предназначенная для сопоставления входных индексов с выходными.</param>
 <param name="list">Входной список.</param>
 <returns>Список, подвергнутый перестановке.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет заданную функцию к идущим подряд элементам, возвращая первый результат, в котором функция возвращает <c>Some(x)</c> для некоторого x. Если такого элемента не существует, создается исключение <c>System.Collections.Generic.KeyNotFoundException</c>.</summary>
 <param name="chooser">Функция для создания параметров из элементов.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если список пуст.</exception>
 <returns>Первое результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Разделяет коллекцию на две коллекции, содержащие те элементы, для которых заданный предикат возвращает соответственно значения <c>true</c> и <c>false</c>. Порядок элементов сохраняется в обоих созданных списках.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Список, содержащий элементы, для которых предикат возвратил значение false, и список, содержащий элементы, для которых предикат возвратил значение true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует новый список из заданного перечисляемого объекта.</summary>
 <param name="source">Входная последовательность.</param>
 <returns>Список элементов последовательности.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfArray``1(``0[])">
 <summary>Формирует список из заданного массива.</summary>
 <param name="array">Входной массив.</param>
 <returns>Список элементов из массива.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Get``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Производит индексацию в список. Индекс первого элемента — 0.</summary>
 <param name="list">Входной список.</param>
 <param name="index">Извлекаемый индекс.</param>
 <returns>Значение по указанному индексу.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает минимальный элемент списка, определенный посредством сравнения с результатом функции с помощью Operators.min</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст.</remarks>
 <param name="projection">Функция для преобразования элементов списка в тип, который нужно сравнить.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Минимальное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Min``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает минимальный элемент списка, определенный посредством Operators.min.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст</remarks>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Минимальное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает максимальный элемент списка, определенный посредством сравнения с результатом функции с помощью Operators.max.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст.</remarks>
 <param name="projection">Функция для преобразования элементов списка в тип, который нужно сравнить.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Максимальный элемент.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Max``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает максимальный элемент списка, определенный посредством Operators.max.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст</remarks>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Максимальный элемент.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Аналогичен mapi, но сопоставляет соответствующие элементы из двух списков равной длины.</summary>
 <param name="mapping">Функция для преобразования пар элементов из двух списков и их индексов.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <returns>Список преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом применения заданной функции к каждому элементу коллекции. Целочисленный индекс, переданный функции, указывает индекс (от 0) преобразуемого элемента.</summary>
 <param name="mapping">Функция для преобразования элементов и их индексов.</param>
 <param name="list">Входной список.</param>
 <returns>Список преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом одновременного применения заданной функции к соответствующим элементам трех коллекций.</summary>
 <param name="mapping">Функция для преобразования триад элементов из входных списков.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <param name="list3">Третий входной список.</param>
 <returns>Список преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом попарного применения заданной функции к соответствующим элементам двух коллекций.</summary>
 <param name="mapping">Функция для преобразования пар элементов из входных списков.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <returns>Список преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом применения заданной функции к каждому элементу коллекции.</summary>
 <param name="mapping">Функция для преобразования элементов из входного списка.</param>
 <param name="list">Входной список.</param>
 <returns>Список преобразованных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Length``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает длину какого-либо списка.</summary>
 <param name="list">Входной список.</param>
 <returns>Длина списка.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Применяет заданную функцию одновременно к двум коллекциям. Размеры коллекций должны быть идентичны. Целое число, переданное функции, обозначает индекс элемента.</summary>
 <param name="action">Функция, применяемая к паре элементов из входных списков вместе с их индексами.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет заданную функцию к каждому элементу коллекции. Целое число, переданное функции, обозначает индекс элемента.</summary>
 <param name="action">Функция, применяемая к элементам списка вместе с их индексами.</param>
 <param name="list">Входной список.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Применяет заданную функцию одновременно к двум коллекциям. Размеры коллекций должны быть идентичны.</summary>
 <param name="action">Функция, применяемая к парам элементов из входных списков.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет заданную функцию к каждому элементу коллекции.</summary>
 <param name="action">Функция, применяемая к элементам входного списка.</param>
 <param name="list">Входной список.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает значение true, если список не содержит какие-либо элементы; в противном случае — значение false.</summary>
 <param name="list">Входной список.</param>
 <returns>Значение true, если список пустой.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Создает список путем вызова заданного генератора для каждого индекса.</summary>
 <param name="length">Длина создаваемого списка.</param>
 <param name="initializer">Функция для создания элемента из индекса.</param>
 <returns>Список созданных элементов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Head``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает первый элемент списка.</summary>

 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Первый элемент списка.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Проверяет, все ли соответствующие элементы коллекции удовлетворяют заданному предикату попарно.</summary>

 <remarks>Предикат применяется к соответствующим элементам двух коллекций до длины, более короткой из этих коллекций. Если любая из проверок возвращает значение false, то для окончательного результата также устанавливается значение false, а проверка последующих элементов не выполняется. В противном случае, если одна коллекция длиннее другой, создается исключение <c>System.ArgumentException</c>. В остальных случаях возвращается значение true.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <exception cref="System.ArgumentException">Создается, если входные списки имеют разную длину.</exception>
 <returns>Значение true, если все пары элементов удовлетворяют предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Проверяет, все ли элементы коллекции удовлетворяют заданному предикату.</summary>

 <remarks>Предикат применяется к элементам входного списка. Если любая из проверок возвращает значение false, то для окончательного результата также устанавливается значение false, а проверка последующих элементов не выполняется. В остальных случаях возвращается значение true.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Значение true, если все элементы удовлетворяют предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)">
 <summary>Применяет функцию к соответствующим элементам двух коллекций, накапливаемое значение аргумента передается по потоку в процессе вычисления. Размеры коллекций должны быть идентичны. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c> и <c>j0...jN</c>, вычисляет <c>f i0 j0 (...(f iN jN s))</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Значение конечного состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f i0 (...(f iN s))</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="list">Входной список.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Значение конечного состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Применяет функцию к соответствующим элементам двух коллекций, накапливаемое значение аргумента передается по потоку в процессе вычисления. Размеры коллекций должны быть идентичны. Если входная функция <c>f</c>, а элементы — <c>i0...iN</c> и <c>j0...jN</c>, вычисляет <c>f (... (f s i0 j0)...) iN jN</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="state">Начальное состояние.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <returns>Значение конечного состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Принимает второй аргумент и применяет функцию к нему и к первому элементу списка. Затем передает этот результат в функцию вместе со вторым элементом и т. д. Возвращает окончательный результат. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f (... (f s i0) i1 ...) iN</c>.</summary>
 <param name="folder">Функция для обновления состояния на основании входных элементов.</param>
 <param name="state">Начальное состояние.</param>
 <param name="list">Входной список.</param>
 <returns>Значение конечного состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает новую коллекцию, содержащую только те элементы коллекции, для которых заданный предикат возвращает значение true</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Список, содержащий только те элементы, которые удовлетворяют предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает индекс первого элемента в списке, который удовлетворяет заданному предикату. Если такого элемента не существует, создается исключение <c>KeyNotFoundException</c>.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если в результате оценки предиката возникает значение false (для всех элементов списка).</exception>
 <returns>Индекс первого элемента, удовлетворяющего предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает первый элемент, для которого заданная функция возвращает значение <c>true</c>. Если такого элемента не существует, создается исключение <c>KeyNotFoundException</c>.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если в результате оценки предиката возникает значение false (для всех элементов списка).</exception>
 <returns>Первый элемент, удовлетворяющий предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Проверяет, удовлетворяет ли какая-либо пара соответствующих элементов списков заданному предикату.</summary>

 <remarks>Предикат применяется к соответствующим элементам двух коллекций до длины, более короткой из этих коллекций. Если любая из проверок возвращает значение true, то для окончательного результата также устанавливается значение true, а проверка последующих элементов не выполняется. В противном случае, если одна коллекция длиннее другой, создается исключение <c>System.ArgumentException</c>. В противном случае возвращается значение false.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <exception cref="System.ArgumentException">Создается, если входные списки имеют разную длину.</exception>
 <returns>Значение true, если какая-либо пара элементов удовлетворяет предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Проверяет, удовлетворяет ли какой-либо элемент списка заданному предикату.</summary>

 <remarks>Предикат применяется к элементам входного списка. Если любая из проверок возвращает значение true, то для окончательного результата также устанавливается значение true, а проверка последующих элементов не выполняется. В противном случае возвращается значение false.</remarks>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Значение true, если какой-либо элемент удовлетворяет предикату.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Empty``1">
 <summary>Возвращает пустой список заданного типа.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Concat``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">
 <summary>Возвращает новый список, содержащий элементы каждого списка в соответствующем порядке.</summary>
 <param name="lists">Входная последовательность списков.</param>
 <returns>Результирующий сцепленный список.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет заданную функцию к каждому элементу списка. Сцепляет все результаты и возвращает объединенный список.</summary>
 <param name="mapping">Функция для преобразования каждого входного элемента в объединяемый подсписок.</param>
 <param name="list">Входной список.</param>
 <returns>Объединение преобразованных подсписков.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Применяет заданную функцию к каждому элементу списка. Возвращает список, состоящий из результатов <c>x</c> для каждого элемента, где функция возвращает значение Some(x).</summary>
 <param name="chooser">Функция для создания параметров из элементов.</param>
 <param name="list">Входной список.</param>
 <returns>Список, состоящий из значений, избранных из функции выбора.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает среднее значение элементов, созданное путем применения функции к каждому элементу списка.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст.</remarks>
 <param name="projection">Функция для преобразования элементов списка в тип, для которого нужно получить среднее значение.</param>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Результирующее среднее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Average``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает среднее значение элементов в списке.</summary>

 <remarks>Создает исключение <c>System.ArgumentException</c>, если список <c>list</c> пуст.</remarks>
 <param name="list">Входной список.</param>
 <exception cref="System.ArgumentException">Создается, если список пуст.</exception>
 <returns>Результирующее среднее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Возвращает новый список, содержащий элементы первого списка, за которыми следуют элементы второго списка.</summary>
 <param name="list1">Первый входной список.</param>
 <param name="list2">Второй входной список.</param>
 <returns>Результирующий список.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.ListModule">
 <summary>Основные операции над списками.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает ключ первого сопоставления в коллекции, который удовлетворяет заданному предикату. Если такого элемента нет, возвращает значение None.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Первый ключ, для которого предикат возвращает значение true, или значение None, если предикат возвращает значение true для всех пар ключей и значений.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FindKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Вычисляет функцию для каждого сопоставления в коллекции. Возвращает ключ первого сопоставления, для которого функция возвращает значение true. Если такого элемента не существует, создается исключение <c>KeyNotFoundException</c>.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="table">Входное сопоставление.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если ключ не существует в сопоставлении.</exception>
 <returns>Первый ключ, для которого предикат возвращает значение true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFind``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Выполните поиск элемента в сопоставлении, возвращая значение <c>Some</c>, если элемент найден в области сопоставления, или значение <c>None</c>, если элемент не найден.</summary>
 <param name="key">Входной ключ.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Найденное значение <c>Some</c> или <c>None</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Remove``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Удаляет элемент из домена сопоставления. Если элемент не существует, исключение не создается.</summary>
 <param name="key">Входной ключ.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Формирует два новых сопоставления: первое содержит привязки, для которых заданный предикат возвращает значение true, а другое возвращает оставшиеся привязки.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Пара сопоставлений, где первое сопоставление содержит элементы, для которых предикат вернул значение true, а второе сопоставление — элементы, для которых предикат вернул значение false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ContainsKey``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Проверяет, входит ли элемент в домен сопоставления.</summary>
 <param name="key">Входной ключ.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Значение true, если сопоставление содержит заданный ключ.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом применения заданной функции к каждому элементу коллекции. Ключ, который передается в функцию, указывает ключ преобразуемого элемента.</summary>
 <param name="mapping">Функция, предназначенная для преобразования пар "ключ-значение".</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Результирующее сопоставление ключей и преобразованных значений.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ForAll``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает значение true, если заданный предикат возвращает значение true для всех привязок в сопоставлении.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Значение true, если предикат принимает значение true для всех привязок в сопоставлении.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Формирует новое сопоставление, содержащее только те привязки, для которых заданный предикат возвращает значение true.</summary>
 <param name="predicate">Функция, предназначенная для тестирования пар "ключ-значение".</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Отфильтрованное сопоставление.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает значение true, если заданный предикат возвращает значение true для одной из привязок в сопоставлении.</summary>
 <param name="predicate">Функция для проверки входных элементов.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Значение true, если заданный предикат возвращает значение true для одной из пар "ключ-значение".</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Применяет заданную функцию к каждой привязке в словаре.</summary>
 <param name="action">Функция преобразования, применяемая к каждой паре ключей и значений.</param>
 <param name="table">Входное сопоставление.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Выполняет свертывание привязок в сопоставлении </summary>
 <param name="folder">Функция для обновления состояния на основании входных пар "ключ-значение".</param>
 <param name="state">Начальное состояние.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Значение конечного состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
 <summary>Выполняет свертывание привязок в сопоставлении.</summary>
 <param name="folder">Функция для обновления состояния на основании входных пар "ключ-значение".</param>
 <param name="table">Входное сопоставление.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Значение конечного состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Выполняет поиск первого элемента сопоставления, для которого заданная функция возвращает значение <c>Some</c>.</summary>
 <param name="chooser">Функция, используемая для создания параметров из пар ключей и значений.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Первый результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Выполняет поиск первого элемента сопоставления, для которого заданная функция возвращает значение <c>Some</c>.</summary>
 <param name="chooser">Функция, используемая для создания параметров из пар ключей и значений.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Первый результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Find``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Выполняет поиск элемента в сопоставлении; если в сопоставлении нет привязок, создает исключение <c>KeyNotFoundException</c>.</summary>
 <param name="key">Входной ключ.</param>
 <param name="table">Входное сопоставление.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если ключ не существует в сопоставлении.</exception>
 <returns>Значение, сопоставляемое с заданным ключом.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Empty``2">
 <summary>Пустое сопоставление.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.IsEmpty``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает значение, указывающее, является ли сопоставление пустым.</summary>
 <param name="table">Входное сопоставление.</param>
 <returns>Значение true, если сопоставление является пустым.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToArray``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает массив всех пар "ключ-значение" в сопоставлении. Массив будет упорядочен по ключам сопоставления.</summary>
 <param name="table">Входное сопоставление.</param>
 <returns>Массив пар "ключ-значение".</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает список всех пар "ключ-значение" в сопоставлении. Список будет упорядочен по ключам сопоставления.</summary>
 <param name="table">Входное сопоставление.</param>
 <returns>Список пар "ключ-значение".</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Просматривает коллекцию как перечисляемую последовательность пар. Последовательность будет упорядочена по ключам сопоставления.</summary>
 <param name="table">Входное сопоставление.</param>
 <returns>Последовательность пар "ключ-значение".</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Возвращает новое сопоставление, созданное из заданных привязок.</summary>
 <param name="elements">Входная последовательность пар "ключ-значение".</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfArray``2(System.Tuple{``0,``1}[])">
 <summary>Возвращает новое сопоставление, созданное из заданных привязок.</summary>
 <param name="elements">Входной массив пар "ключ-значение".</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
 <summary>Возвращает новое сопоставление, созданное из заданных привязок.</summary>
 <param name="elements">Входной список пар "ключ-значение".</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Add``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Возвращает новое сопоставление с привязкой, добавленной в заданное сопоставление.</summary>
 <param name="key">Входной ключ.</param>
 <param name="value">Входное значение.</param>
 <param name="table">Входное сопоставление.</param>
 <returns>Результирующее сопоставление.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.MapModule">
 <summary>Операторы функционального программирования, связанные с типом <c>Map&lt;_,_&gt;</c>.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip3``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
 <summary>Объединяет три последовательности в список триад. Последовательности не обязаны иметь равную длину: при исчерпании одной последовательности оставшиеся в других последовательностях элементы игнорируются.</summary>

 <param name="source1">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>
 <param name="source3">Третья входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается, если для любой из входных последовательностей указано значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Объединяет две последовательности в список пар. Две последовательности не обязаны иметь равную длину: при исчерпании одной последовательности оставшиеся в другой элементы игнорируются.</summary>

 <param name="source1">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается, если любая из входных последовательностей имеет значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Windowed``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, выдающую перемещающиеся окна из элементов, содержащихся во входной последовательности. Каждое окно возвращается как новый массив.</summary>

 <param name="windowSize">Число элементов в каждом окне.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>Возвращает последовательность, которая содержит элементы созданные данным вычислением. Заданный аргумент начального состояния <c>state</c> передается генератору элементов. Каждый элемент IEnumerator в потоке создается по требования с помощью генератора элемента, пока он не возвращает значение None. Каждый вызов генератора элементов возвращает новое остаточное состояние <c>state</c>.</summary>

 <remarks>Поток будет пересчитываться каждый раз при запросе IEnumerator и итерации для Seq. Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>

 <param name="generator">Функция, которая принимает текущее состояние и возвращает кортеж параметров из следующего элемента последовательности и следующего значения состояния.</param>
 <param name="state">Начальное значение состояния.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Truncate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, которая возвращает по крайней мере N элементов при ее перечислении.</summary>

 <param name="count">Максимальное количество перечисляемых элементов.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет заданную функцию к идущим подряд элементам, возвращая первый результат, когда функция возвращает Some(x).</summary>

 <param name="chooser">Функция для преобразования элементов входной последовательности в параметры.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Выбранный элемент или <c>None</c>.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает индекс первого элемента последовательности, удовлетворяющего заданному предикату. Возвращает значение <c>None</c>, если такого элемента не существует.</summary>

 <param name="predicate">Функция, вычисляющая логическое значение при указании элемента последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Найденный индекс или <c>None</c>.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает первый элемент, для которого заданная функция возвращает значение <c>true</c>. Возвращает значение <c>None</c>, если такого элемента не существует.</summary>

 <param name="predicate">Функция, вычисляющая логическое значение при указании элемента последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Найденный элемент или <c>None</c>.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует список из заданной коллекции.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующий список.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует массив из заданной коллекции.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующий массив.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, которая в ходе ее итерации выдает элементы базовой последовательности, когда заданный предикат возвращает значение <c>true</c>, и больше не возвращает элементов.</summary>

 <param name="predicate">Функция, возвращающая значение false, когда выдавать элементы больше не следует.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Take``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает первые N элементов последовательности.</summary>
 <remarks>Если значение параметра count превышает число элементов в последовательности, вызывает исключение <c>InvalidOperationException</c>. <c>Seq.truncate</c> возвращает столько элементов, сколько содержит последовательность, вместо вызова исключения.</remarks>

 <param name="count">Число элементов, которые нужно принять.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
 <exception cref="System.InvalidOperationException">Вызывается, если счетчик превышает число элементов в последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает сумму результатов, созданную путем применения функции к каждому элементу последовательности.</summary>
 <remarks>Созданные элементы суммируются с использованием оператора <c>+</c> и свойства <c>Zero</c>, связанного с созданным типом.</remarks>

 <param name="projection">Функция для преобразования элементов входной последовательности в суммируемый тип.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Вычисленная сумма.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sum``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает сумму элементов в последовательности.</summary>

 <remarks>Элементы суммируются с помощью оператора <c>+</c> и свойства <c>Zero</c>, связанного с созданным типом.</remarks>

 <param name="source">Входная последовательность.</param>

 <returns>Вычисленная сумма.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет функцию создания ключей к каждому элементу последовательности и выдает последовательность, упорядоченную по ключам. Ключи сравниваются с помощью обычного сравнения, реализуемого <c>Operators.compare</c>.</summary> 
 
 <remarks>Эта функция возвращает последовательность, которая формирует дайджест всей начальной последовательности при итерации этой последовательности. Таким образом, эту функцию не следует использовать с большими или бесконечными последовательностями. Функция не делает предположений об упорядочении исходной последовательности. Это стабильная сортировка, то есть исходный порядок равных элементов сохраняется.</remarks>

 <param name="projection">Функция для преобразования элементов входной последовательности в сравниваемые ключи.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sort``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Выдает последовательность, упорядоченную по ключам.</summary>
 
 <remarks>Эта функция возвращает последовательность, которая формирует дайджест всей начальной последовательности при итерации этой последовательности. Таким образом, эту функцию не следует использовать с большими или бесконечными последовательностями. Функция не делает предположений об упорядочении исходной последовательности. Это стабильная сортировка, то есть исходный порядок равных элементов сохраняется.</remarks>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, которая в ходе ее итерации пропускает элементы базовой последовательности, когда заданный предикат возвращает значение <c>true</c>, а затем выдает оставшиеся элементы последовательности.</summary>

 <param name="predicate">Функция, вычисляющая логическое значение из элемента последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Skip``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, в которой пропущено N элементов первоначальной последовательности и затем выдает оставшиеся элементы последовательности.</summary>

 <param name="count">Число элементов, которые нужно пропустить.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.InvalidOperationException">Вызывается, если счетчик превышает число элементов в последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Singleton``1(``0)">
 <summary>Возвращает последовательность, дающую только один элемент.</summary>

 <param name="value">Входной элемент.</param>

 <returns>Последовательность результатов одного элемента.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Действует как fold, но работает по требованию и возвращает последовательности промежуточных и конечных результатов.</summary>

 <param name="folder">Функция, обновляющая состояние посредством каждого элемента последовательности.</param>
 <param name="state">Начальное состояние.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность вычисленных состояний.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет функцию к каждому элементу последовательности, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Начните, применив функцию к двум первым элементам. Затем передайте этот результат в функцию вместе с третьим элементом и т. д. Возвращает окончательный результат.</summary>

 <param name="reduction">Функция, которая принимает текущий накопленный результат и следующий элемент последовательности для создания следующего результата накопления.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Окончательный результат функции уменьшения.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует новый объект последовательности , которая указывает на данный объект последовательности. Таким образом гарантируется, что первоначальную последовательность нельзя обнаружить повторно и изменить приведением типов. Например, если задан массив, возвращенная последовательность вернет все элементы массива, но при этом нельзя преобразовать объект последовательности в массив.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет заданную функцию к идущим подряд элементам, возвращая первое значение <c>x</c>, в котором функция возвращает Some(x).</summary>

 <param name="chooser">Функция для преобразования элементов входной последовательности в параметр выходного типа.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Выделенный элемент.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если каждый элемент последовательности оценивается равным <c>None</c> при применении заданной функции.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pairwise``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность каждого элемента и его предшественника во входной последовательности за исключением первого элемента, который возвращается в качестве предшественника второго элемента.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Просматривает заданный список как последовательность.</summary>

 <param name="source">Входной список.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfArray``1(``0[])">
 <summary>Обеспечивает просмотр заданного массива в виде последовательности.</summary>

 <param name="source">Входной массив.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Get``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Вычисляет n-й элемент коллекции.</summary>

 <param name="index">Индекс элемента, который должен быть извлечен.</param>
 <param name="source">Входная последовательность.</param>

 <returns>-ый элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает минимальный элемент последовательности, определенный посредством сравнения с результатом функции с помощью Operators.min.</summary>

 <param name="projection">Функция для преобразования элементов входной последовательности в сравниваемые ключи.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Самый маленький элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Min``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает минимальный элемент последовательности, сравненный посредством <c>Operators.min</c>.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Самый маленький элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает максимальный элемент последовательности, определенный посредством сравнения с результатом функции с помощью Operators.max.</summary>

 <param name="projection">Функция для преобразования элементов входной последовательности в сравниваемые ключи.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Самый крупный элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Max``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает максимальный элемент последовательности, определенный посредством оператора Operators.max</summary>

 <param name="source">Входная последовательность.</param>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>

 <returns>Самый крупный элемент последовательности.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом применения заданной функции к каждому элементу коллекции. Целочисленный индекс, переданный функции, указывает индекс (от 0) преобразуемого элемента.</summary>

 <param name="mapping">Функция для преобразования элементов входной последовательности, которая также задает текущий индекс.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом одновременного применения заданной функции к соответствующим парам элементов двух последовательностей. Если одна входная последовательность оказывается короче другой, оставшиеся элементы более длинной последовательности игнорируются.</summary>

 <param name="mapping">Функция для преобразования пар элементов из входных последовательностей.</param>
 <param name="source">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается, если любая из входных последовательностей имеет значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует новую коллекцию, элементы которой являются результатом применения заданной функции к каждому элементу коллекции. Заданная функция будет применяться по мере запрашивания элементов с помощью метода <c>MoveNext</c> для перечислителей, извлеченных из объекта.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>

 <param name="mapping">Функция для преобразования элементов из входной последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Length``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает длину последовательности</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Длина последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Применяет заданную функцию одновременно к двум коллекциям. Если одна последовательность оказывается короче другой, оставшиеся элементы более длинной последовательности игнорируются.</summary>

 <param name="action">Функция, применяемая к каждой паре элементов из входных последовательностей.</param>
 <param name="source1">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>

 <exception cref="System.ArgumentNullException">Создается, если любая из входных последовательностей имеет значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет заданную функцию к каждому элементу коллекции. Целое число, переданное функции, обозначает индекс элемента.</summary>

 <param name="action">Функция, которая применяется к каждому элементу последовательности, а также может обращаться к текущему индексу.</param>
 <param name="source">Входная последовательность.</param>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет заданную функцию к каждому элементу коллекции.</summary>

 <param name="action">Функция преобразования, применяемая к каждому элементу последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.InitializeInfinite``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Создает новую последовательность, при переборе которой будут возвращаться идущие подряд элементы путем вызова заданной функции. Результаты вызова функции не сохраняются — при необходимости повторного создания элементов эта функция будет применяться повторно. Функции передается индекс создаваемого элемента.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности. Итерация может продолжаться до значения <c>Int32.MaxValue</c>.</remarks>

 <param name="initializer">Функция, создающая в последовательности элемент из заданного индекса.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Создает новую последовательность, которая будет возвращать идущие подряд элементы вплоть до указанного числа путем вызова заданной функции в ходе итерации по этой последовательности. Каждый элемент сохраняется после инициализации. Функции передается индекс создаваемого элемента.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>

 <param name="count">Максимальное число элементов, создаваемых для последовательности.</param>
 <param name="initializer">Функция, создающая в последовательности элемент из заданного индекса.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentException">Создается, если count является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает значение true, если последовательность не содержит элементов; в противном случае возвращает значение false.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Значение true, если последовательность пустая; в противном случае — значение false.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ExactlyOne``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает только первый элемент последовательности.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Последний элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается, если в введенном значении не обязательно именно один элемент.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Last``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последний элемент последовательности.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Последний элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Head``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает первый элемент последовательности.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Первый элемент последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет функцию создания ключей к каждому элементу последовательности и получает последовательность уникальных ключей. Каждый уникальный ключ содержит последовательность всех элементов, соответствующих этому ключу.</summary>
 
 <remarks>Эта функция возвращает последовательность, которая формирует дайджест всей начальной последовательности при итерации этой последовательности. Таким образом, эту функцию не следует использовать с большими или бесконечными последовательностями. Функция не делает предположений об упорядочении исходной последовательности.</remarks>

 <param name="projection">Функция, преобразующая элемент последовательности в сравниваемый ключ.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Проверяет, все ли пары элементов, извлеченные из двух последовательностей, удовлетворяют заданному предикату. Если одна последовательность оказывается короче другой, оставшиеся элементы более длинной последовательности игнорируются.</summary>

 <param name="predicate">Функция для проверки пар элементов из входных последовательностей.</param>
 <param name="source1">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>

 <returns>Значение true, если все пары удовлетворяют предикату; в противном случае — значение false.</returns>

 <exception cref="System.ArgumentNullException">Создается, если любая из входных последовательностей имеет значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Проверяет, все ли элементы последовательности удовлетворяют заданному предикату.</summary>

 <remarks>Предикат применяется к элементам входной последовательности. Если любая из проверок возвращает значение false, то для окончательного результата также устанавливается значение false, а проверка последующих элементов не выполняется. В остальных случаях возвращается значение true.</remarks>

 <param name="predicate">Функция для проверки элемента входной последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Значение true, если каждый элемент последовательности удовлетворяет предикату; в противном случае — значение false.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет функцию к каждому элементу коллекции, передавая накапливаемое значение аргумента по потоку в процессе вычисления. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c>, вычисляет <c>f (... (f s i0)...) iN</c></summary>

 <param name="folder">Функция, обновляющая состояние посредством каждого элемента последовательности.</param>
 <param name="state">Начальное состояние.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Объект состояния после применения функции сложения к каждому элементу последовательности.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает индекс первого элемента, для которого заданная функция возвращает значение <c>true</c>.</summary>

 <param name="predicate">Функция для проверки на необходимость в возвращении индекса определенного элемента.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Индекс первого элемента, для которого предикат возвращает значение <c>true</c>.</returns>

 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если ни один элемент не возвращает значение true при оценке посредством предиката</exception>
 <exception cref="System.ArgumentNullException">Создается, если входная последовательность имеет значение NULL</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает первый элемент, для которого заданная функция возвращает значение <c>true</c>.</summary>

 <param name="predicate">Функция для проверки на необходимость в возвращении элемента, находящегося в последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Первый элемент, для которого предикат возвращает значение <c>true</c>.</returns>

 <exception cref="System.Collections.Generic.KeyNotFoundException">Создается, если ни один элемент не возвращает значение true при оценке посредством предиката</exception>
 <exception cref="System.ArgumentNullException">Создается, если входная последовательность имеет значение NULL</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает новую коллекцию, содержащую только те элементы коллекции, для которых заданный предикат возвращает значение true.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности. Последовательность отложенная, результаты отражаются только после ее перечисления. Синоним для Seq.filter.</remarks>

 <param name="predicate">Функция для проверки на необходимость включения каждого элемента входной последовательности в результат.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>    
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает новую коллекцию, содержащую только те элементы коллекции, для которых заданный предикат возвращает значение true. Это синоним для Seq.where.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности. Последовательность отложенная, результаты отражаются только после ее перечисления.</remarks>

 <param name="predicate">Функция для проверки на необходимость включения каждого элемента входной последовательности в результат.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>    
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Проверяет, удовлетворяет ли какая-либо пара соответствующих элементов входных последовательностей заданному предикату.</summary>

 <remarks>Предикат применяется к соответствующим элементам двух последовательностей до длины, более короткой из этих последовательностей. Если любая из проверок возвращает значение true, то для окончательного результата также устанавливается значение true, а проверка последующих элементов не выполняется. В противном случае возвращается значение false. Если одна последовательность оказывается короче другой, оставшиеся элементы более длинной последовательности игнорируются.</remarks>

 <param name="predicate">Функция для проверки каждой пары элементов из входных последовательностей.</param>
 <param name="source1">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>

 <returns>Значение true, если любой результат предиката — true; в противном случае — значение false.</returns>

 <exception cref="System.ArgumentNullException">Создается, если в качестве любой из двух входных последовательностей указано значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Проверяет, удовлетворяет ли какой-либо элемент последовательности заданному предикату.</summary>

 <remarks>Предикат применяется к элементам входной последовательности. Если любая из проверок возвращает значение true, то для окончательного результата также устанавливается значение true, а проверка последующих элементов не выполняется. В противном случае возвращается значение false.</remarks>

 <param name="predicate">Функция для тестирования каждого элемента входной последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Значение true, если любой результат предиката — true; в противном случае — значение false.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Empty``1">
 <summary>Создает пустую последовательность.</summary>

 <returns>Пустая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, которая не содержит дублирующихся записей в соответствии с универсальным хэшем и сравнениями ключей на равенство, возвращенными указанной функцией создания ключей. Если элемент встречается в последовательности несколько раз, последующие вхождения удаляются.</summary>

 <param name="projection">Функция для преобразования элементов последовательности в сравниваемые ключи.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, которая не содержит дублирующихся записей в соответствии с универсальным хэшем и сравнениями на равенство. Если элемент встречается в последовательности несколько раз, последующие вхождения удаляются.</summary>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{``0}})">
 <summary>Возвращает последовательность, полученную из указанной задержанной спецификации последовательности.</summary>

 <remarks>Входная функция вычисляется при каждом запросе IEnumerator для последовательности.</remarks>

 <param name="generator">Функция создания последовательности.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет функцию создания ключей к каждому элементу последовательности и возвращает полученные уникальные ключи и число их вхождений в первоначальной последовательности.</summary>
 
 <remarks>Учтите, что эта функция возвращает последовательность, которая формирует дайджест всей начальной последовательности при итерации этой последовательности. Таким образом, эту функцию не следует использовать с большими или бесконечными последовательностями. Функция не делает предположений об упорядочении исходной последовательности.</remarks>

 <param name="projection">Функция для преобразования каждого элемента входной последовательности в ключи, сравниваемые с другими.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Concat``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Объединяет заданное перечисление перечислений в одно сцепленное перечисление.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>

 <param name="sources">Входное перечисление перечислений.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Сравнивает две последовательности, используя заданную функцию сравнения поэлементно. Возвращает первый ненулевой результат функции сравнения. Если достигнут конец последовательности, возвращается -1, если первая последовательность короче, и 1, если вторая последовательность короче.</summary>

 <param name="comparer">Функция, которая берет элемент из каждой последовательности и возвращает целочисленное значение. Если результат ее оценки отличается от нуля, итерация значений прекращается и возвращается полученное значение.</param>
 <param name="source1">Первая входная последовательность.</param>
 <param name="source2">Вторая входная последовательность.</param>

 <returns>Первое ненулевое значение функции сравнения.</returns>

 <exception cref="System.ArgumentNullException">Создается, если любая из входных последовательностей имеет значение NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Collect``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет данную функцию к каждому элементу последовательности и сцепляет результаты.</summary>

 <remarks>Последовательность отложенная, результаты отражаются только после ее перечисления.</remarks>

 <param name="mapping">Функция для преобразования элементов входной последовательности в последовательности, которые затем сцепляются.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Применяет заданную функцию к каждому элементу списка. Возвращает список, состоящий из результатов x для каждого элемента, где функция возвращает значение Some(x).</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>

 <param name="chooser">Функция для преобразования элементов типа T в параметры типа U.</param>
 <param name="source">Входная последовательность типа T.</param>

 <returns>Результирующая последовательность.</returns>
 
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cast``1(System.Collections.IEnumerable)">
 <summary>Создает оболочку для слабо типизированной последовательности System.Collections как для типизированной последовательности.</summary>

 <remarks>Для применения этой функции, как правило, требуется аннотация типа. Использование неверной аннотации типа может привести к возникновению ошибок типа среды выполнения. Не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>
 
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cache``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает последовательность, соответствующую кэшированной версии входной последовательности. У результирующей последовательности будут те же элементы, что и у входной последовательности. Перечисление результата может быть выполнено несколько раз. Перечисление входной последовательности выполняется не более одного раза при необходимости. Кэширование последовательности обычно полезно, если повторное вычисление элементов первоначальной последовательности требует много ресурсов или если итерация последовательности вызывает побочные эффекты, которые нежелательно повторять много раз. Перечисление результирующей последовательности потокобезопасно в том отношении, что несколько независимых значений IEnumerator можно использовать одновременно из разных потоков (доступ к внутренней таблице подстановки потокобезопасен). Каждое отдельное значение IEnumerator обычно не потокобезопасно и следует избегать одновременного доступа к нему.</summary>

 <remarks>После начала перечисления входной последовательности ее перечислитель будет сохраняться данным объектом до завершения перечисления. Затем перечислитель удаляется. Удаление перечислителя и освобождение базового хранилища кэша может осуществляться путем преобразования возвращенного объекта последовательности в тип IDisposable и вызова метода Dispose для данного объекта. После этого можно заново перечислить объект последовательности с использованием нового перечислителя.</remarks>

 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает среднее значение результатов, созданное путем применения функции к каждому элементу последовательности.</summary>

 <remarks>Вычисляется среднее значение элементов с использованием оператора <c>+</c>, метода <c>DivideByInt</c> и свойства <c>Zero</c>, связанного с созданным типом.</remarks>

 <param name="projection">Функция, применяемая для преобразования каждого элемента последовательности.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Среднее значение.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Average``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Возвращает среднее значение элементов в последовательности.</summary>

 <remarks>Вычисляется среднее значение элементов с использованием оператора <c>+</c>, метода <c>DivideByInt</c> и свойства <c>Zero</c>, связанного с созданным типом элемента.</remarks>

 <param name="source">Входная последовательность.</param>

 <returns>Среднее значение.</returns>

 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной последовательности значения NULL.</exception>
 <exception cref="System.ArgumentException">Создается в случае пустой входной последовательности.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Создает оболочку двух указанных перечислений в виде одного объединенного перечисления.</summary>

 <remarks>Возвращаемая последовательность может безопасно передаваться между потоками. Однако не следует выполнять параллельный доступ к отдельным значениям IEnumerator, созданным из возвращенной последовательности.</remarks>

 <param name="source1">Первая последовательность.</param>
 <param name="source2">Вторая последовательность.</param>

 <returns>Результирующая последовательность.</returns>

 <exception cref="System.ArgumentNullException">Создается, если любая из двух данных последовательностей имеет значение NULL.</exception>
</member>
<member name="T:Microsoft.FSharp.Collections.SeqModule">
 <summary>Основные операции над IEnumerables.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Difference``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает новый набор, в котором из элементов первого набора удалены элементы второго набора.</summary>
 <param name="set1">Первый входной набор.</param>
 <param name="set2">Множество, элементы которого будут удалены из <c>set1</c>.</param>
 <returns>Множество с элементами <c>set2</c>, удаленными из <c>set1</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует новую коллекцию из заданного перечисляемого объекта.</summary>
 <param name="elements">Входная последовательность.</param>
 <returns>Множество, содержащее элементы <c>elements</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает упорядоченное представление коллекции как перечислимый объект.</summary>
 <param name="set">Входной набор.</param>
 <returns>Упорядоченная последовательность элементов множества <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToArray``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Формирует массив, содержащий упорядоченные элементы набора.</summary>
 <param name="set">Входной набор.</param>
 <returns>Упорядоченный массив элементов множества <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfArray``1(``0[])">
 <summary>Формирует набор, содержащий те же элементы, что и заданный массив.</summary>
 <param name="array">Входной массив.</param>
 <returns>Множество, содержащее элементы массива <c>array</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToList``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Формирует список, содержащий упорядоченные элементы набора.</summary>
 <param name="set">Входной набор.</param>
 <returns>Упорядоченный список элементов множества <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Формирует набор, содержащий те же элементы, что и заданный список.</summary>
 <param name="elements">Входной список.</param>
 <returns>Набор, содержащий элементы из входного списка.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MaxElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает наибольший элемент набора в соответствии с правилами упорядочения, используемыми для набора.</summary>
 <param name="set">Входной набор.</param>
 <returns>Максимальное значение в наборе.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MinElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает минимальный элемент набора в соответствии с правилами упорядочения, используемыми для этого набора.</summary>
 <param name="set">Входной набор.</param>
 <returns>Минимальное значение в наборе.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Remove``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает новый набор, в котором указанный элемент удален. Если набор не содержит данный элемент, исключение не создается.</summary>
 <param name="value">Подлежащий удалению элемент.</param>
 <param name="set">Входной набор.</param>
 <returns>Входное множество с удаленным значением <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Разделяет набор на два набора, содержащих те элементы, для которых заданный предикат возвращает соответственно значения true и false.</summary>
 <param name="predicate">Функция для проверки элементов набора.</param>
 <param name="set">Входной набор.</param>
 <returns>Пара множеств, где первое множество содержит элементы, для которых предикат <c>predicate</c> возвращает значение true, а второе — элементы, для которых предикат <c>predicate</c> возвращает значение false.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Применяет заданную функцию к каждому элементу набора по порядку, соответствующему функции сравнения.</summary>
 <param name="action">Функция, применяемая к каждому элементу.</param>
 <param name="set">Входной набор.</param>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает значение true, если результирующий набор не пуст.</summary>
 <param name="set">Входной набор.</param>
 <returns>Значение true, если множество <c>set</c> пустое.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.UnionMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
 <summary>Вычисляет объединение последовательности наборов.</summary>
 <param name="sets">Последовательность наборов для объединения.</param>
 <returns>Объединение входных наборов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Union``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Вычисляет объединение двух наборов.</summary>
 <param name="set1">Первый входной набор.</param>
 <param name="set2">Второй входной набор.</param>
 <returns>Объединение множеств <c>set1</c> и <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
 <summary>Вычисляет точку пересечения последовательности наборов. Последовательность должна быть непустой.</summary>
 <param name="sets">Последовательность наборов для пересечения.</param>
 <returns>Пересечение входных наборов.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Intersect``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Вычисляет пересечение двух наборов.</summary>
 <param name="set1">Первый входной набор.</param>
 <param name="set2">Второй входной набор.</param>
 <returns>Пересечение множеств <c>set1</c> и <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Проверяет, все ли элементы коллекции удовлетворяют заданному предикату. Если входная функция — <c>f</c>, а элементы — <c>i0...iN</c> и "j0...jN", вычисляет <c>p i0 &amp;&amp; ... &amp;&amp; p iN</c>.</summary>
 <param name="predicate">Функция для проверки элементов набора.</param>
 <param name="set">Входной набор.</param>
 <returns>Значение true, если все элементы множества <c>set</c> удовлетворяют предикату <c>predicate</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpSet{``0},``1)">
 <summary>Применяет заданную функцию накопления ко всем элементам набора.</summary>
 <param name="folder">Функция накопления.</param>
 <param name="set">Входной набор.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Конечное состояние.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Применяет заданную функцию накопления ко всем элементам набора</summary>
 <param name="folder">Функция накопления.</param>
 <param name="state">Начальное состояние.</param>
 <param name="set">Входной набор.</param>
 <returns>Конечное состояние.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает новую коллекцию содержащую результаты применения заданной функции к каждому элементу входного набора.</summary>
 <param name="mapping">Функция для преобразования элементов входного массива.</param>
 <param name="set">Входной набор.</param>
 <returns>Набор, содержащий преобразованные элементы.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает новую коллекцию, содержащую только те элементы коллекции, для которых заданный предикат возвращает значение <c>true</c>.</summary>
 <param name="predicate">Функция для проверки элементов набора.</param>
 <param name="set">Входной набор.</param>
 <returns>Множество, содержащее только элементы, для которых предикат <c>predicate</c> возвращает значение true.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Проверяет, удовлетворяет ли какой-либо элемент коллекции заданному предикату. Если входная функция — <c>predicate</c>, а элементы — <c>i0...iN</c>, вычисляет <c>p i0 или ... или p iN</c>.</summary>
 <param name="predicate">Функция для проверки элементов набора.</param>
 <param name="set">Входной набор.</param>
 <returns>Значение true, если любой элемент множества <c>set</c> удовлетворяет предикату <c>predicate</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Count``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает количество элементов в наборе. Такое же, как размер <c>size</c>.</summary>
 <param name="set">Входной набор.</param>
 <returns>Число элементов в наборе.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Принимает значение true, если все элементы второго набора присутствуют в первом, и хотя бы один элемент первого набора не входит во второй.</summary>
 <param name="set1">Потенциальное надмножество.</param>
 <param name="set2">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если множество <c>set1</c> является надлежащим надмножеством множества <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Принимает значение true, если все элементы второго набора присутствуют в первом.</summary>
 <param name="set1">Потенциальное надмножество.</param>
 <param name="set2">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если множество <c>set1</c> является надмножеством множества <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Принимает значение true, если все элементы первого набора присутствуют во втором и хотя бы один элемент второго набора не входит в первый.</summary>
 <param name="set1">Потенциальное подмножество.</param>
 <param name="set2">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если множество <c>set1</c> является надлежащим подмножеством множества <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Принимает значение true, если все элементы первого набора присутствуют во втором наборе.</summary>
 <param name="set1">Потенциальное подмножество.</param>
 <param name="set2">Набор, с которым проводится сравнение.</param>
 <returns>Значение true, если множество <c>set1</c> является подмножеством множества <c>set2</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает значение true, если заданный элемент есть в указанном наборе.</summary>
 <param name="element">Элемент для проверки.</param>
 <param name="set">Входной набор.</param>
 <returns>Значение true, если элемент <c>element</c> входит в множество <c>set</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Add``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Возвращает новый набор с добавленным элементом. Если набор уже содержит данный элемент, исключение не создается.</summary>
 <param name="value">Добавляемое значение.</param>
 <param name="set">Входной набор.</param>
 <returns>Новое множество, содержащее значение <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Singleton``1(``0)">
 <summary>Набор, содержащий заданный элемент.</summary>
 <param name="value">Значение для размещения в наборе.</param>
 <returns>Множество, содержащее значение <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Empty``1">
 <summary>Пустой набор для типа 'T.</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SetModule">
 <summary>Операторы функционального программирования, связанные с типом <c>Set&lt;_&gt;</c> type.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.DefaultCancellationToken">
 <summary>Получает токен отмены по умолчанию для выполнения асинхронных вычислений.</summary>
 <returns>Токен отмены по умолчанию.</returns>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.CancellationToken">
 <summary>Создает асинхронное вычисление, которое возвращает токен CancellationToken, управляющий выполнением вычисления.</summary>
 <remarks>В <c>async { let! token = Async.CancellationToken ...}</c> токен можно использовать для запуска других асинхронных операций, которые будут отменены вместе с этим рабочим процессом.</remarks>
 <returns>Асинхронное вычисление, способное извлечь токен CancellationToken из вычислительного выражения.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.TryCancelled``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
 <summary>Создает асинхронное вычисление, выполняющее вычисление <c>computation</c>. Если это вычисление отменяется до своего завершения, выполняется вычисление, созданное посредством выполнения функции <c>compensation</c>.</summary>
 <param name="computation">Входное асинхронное вычисление.</param>
 <param name="compensation">Функция, которая должна быть запущена при отмене вычисления.</param>
 <returns>Асинхронное вычисление, которое запускает компенсацию в случае отмены входного вычисления.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToThreadPool">
 <summary>Создает асинхронное вычисление, которое ставит в очередь рабочий элемент, запускающий его продолжение.</summary>
 <returns>Вычисление, которое создает новый рабочий элемент в пуле потоков.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToNewThread">
 <summary>Создает асинхронное вычисление, которое создает новый поток и запускает свое продолжение в этом потоке.</summary>
 <returns>Вычисление, которое будет выполняться в новом потоке.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToContext(System.Threading.SynchronizationContext)">
 <summary>Создает асинхронное вычисление, которое запускает свое продолжение с помощью syncContext.Post. Если syncContext имеет значение NULL, асинхронное вычисление эквивалентно SwitchToThreadPool().</summary>
 <param name="syncContext">Контекст синхронизации для приема переданного вычисления.</param>
 <returns>Асинхронное вычисление, для выполнения которого используется syncContext.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuations``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Немедленно запускает асинхронное вычисление в текущем потоке операционной системы. По завершении операции вызывает одно из трех продолжений.</summary>
 <remarks>Если токен отмены не указан, используется токен отмены по умолчанию.</remarks>
 <param name="computation">Выполняемое асинхронное вычисление.</param>
 <param name="continuation">Функция, вызываемая в случае успешного завершения.</param>
 <param name="exceptionContinuation">Функция, вызываемая при возникновении исключения.</param>
 <param name="cancellationContinuation">Функция, вызываемая при отмене.</param>
 <param name="cancellationToken">Токен <c>CancellationToken</c>, связываемый с вычислением. Если данный параметр не указан, используется значение по умолчанию.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediate(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Немедленно запускает асинхронное вычисление в текущем потоке операционной системы.</summary>
 <remarks>Если токен отмены не указан, используется токен отмены по умолчанию.</remarks>
 <param name="computation">Выполняемое асинхронное вычисление.</param>
 <param name="cancellationToken">Токен <c>CancellationToken</c>, связываемый с вычислением. Если данный параметр не указан, используется значение по умолчанию.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChildAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions})">
 <summary>Создает асинхронное вычисление, которое запускает заданное вычисление в виде <c>System.Threading.Tasks.Task</c></summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChild``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Начинает дочернее вычисление в асинхронном рабочем процессе. Это позволяет одновременно выполнять несколько асинхронных вычислений.</summary>
 
 <remarks>Как правило, этот метод следует использовать как непосредственного правого соседа привязки <c>let!</c> в асинхронном рабочем процессе F#, т. е. async { ... let! completor1 = childComputation1 |&gt; Async.StartChild let! completor2 = childComputation2 |&gt; Async.StartChild ... let! result1 = completor1 let! result2 = completor2 ... } В этом случае каждое использование элемента <c>StartChild</c> запускает экземпляр <c>childComputation</c> и возвращает объект completor, представляющий вычисление, которого нужно дождаться для завершения операции. При выполнении объект completor дожидается завершения <c>childComputation</c>.</remarks>
 <param name="computation">Дочернее вычисление.</param>
 <param name="millisecondsTimeout">Значение времени ожидания в миллисекундах. Если не предоставляется, используется значение по умолчанию, -1, соответствующее <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Новое вычисление, ожидающее завершения входного вычисления.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Выполняет вычисление в пуле потоков.</summary>
 <remarks>Если токен отмены не указан, используется токен отмены по умолчанию.</remarks>
 <returns>Задача <c>System.Threading.Tasks.Task</c>, которая будет выполнена в соответствующем состоянии по завершении вычисления (дает результат, создает исключение или отменяется)</returns>
        
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Start(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Начинает асинхронное вычисление в пуле потоков. Не следует ожидать результат.</summary>

 <remarks>Если токен отмены не указан, используется токен отмены по умолчанию.</remarks>
 <param name="computation">Асинхронно запускаемое вычисление.</param>
 <param name="cancellationToken">Токен отмены, который необходимо связать с вычислением. Если токен отмены не указан, используется токен отмены по умолчанию.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.Int32)">
 <summary>Создает асинхронное вычисление, которое будет находиться в спящем режиме в течение заданного времени. Планирование производится с помощью объекта System.Threading.Timer. Данная операция не будет блокировать потоки операционной системы во время ожидания.</summary>
 <param name="millisecondsDueTime">Время пребывания в спящем режиме в миллисекундах.</param>
 <returns>Асинхронное вычисление, которое будет находиться в спящем режиме в течение заданного времени.</returns>
 <exception cref="System.ArgumentOutOfRangeException">Создается, если заданное время является отрицательным или бесконечным.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.RunSynchronously``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Запускает асинхронное вычисление и ожидает его результат.</summary>

 <remarks>При возникновении исключения в ходе асинхронного вычисления данная функция создаст повторное исключение. Если токен отмены не указан, используется токен отмены по умолчанию. Параметр времени ожидания указывается в миллисекундах. Значение -1 эквивалентно System.Threading.Timeout.Infinite.</remarks>
 <param name="computation">Запускаемое вычисление.</param>
 <param name="timeout">Время в миллисекундах, которое нужно ждать результата вычисления, прежде чем будет создано исключение <c>System.TimeoutException</c>. Если значение времени ожидания не указано, для соответствия System.Threading.Timeout.Infinite используется значение по умолчанию — -1.</param>
 <param name="cancellationToken">Токен отмены, который необходимо связать с вычислением. Если токен отмены не указан, используется токен отмены по умолчанию.</param>
 <returns>Результат вычисления.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Создает асинхронное вычисление, которое выполняет все заданные асинхронные вычисления, первоначально ставя каждое из них в очередь в качестве рабочего элемента и используя шаблон разветвлений и соединений.</summary>

 <remarks>Если все дочерние вычисления выполнены успешно, массив результатов передается далее. Если какое-либо дочернее вычисление вызывает исключение, общее вычисление вызывает исключение и отменяет другие. Общее вычисление прореагирует на отмену, выполняя дочерние вычисления. Если вычисление отменено, оно отменяет оставшиеся дочерние вычисления, но ожидает выполнения других дочерних вычислений.</remarks>
 <param name="computationList">Последовательность неодинаковых вычислений, подлежащих параллелизации.</param>
 <returns>Вычисление, которое возвращает массив значений из последовательности входных вычислений.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.OnCancel(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Создает ограниченный согласованный обработчик отмены для использования в асинхронном рабочем процессе.</summary>

 <remarks>Например, <c>async { use! holder = Async.OnCancel interruption ... }</c> создает асинхронное вычисление где, если отмена происходит в любой момент во время выполнения асинхронного вычисления в области объекта <c>holder</c>, действие <c>interruption</c> выполняется в потоке, выполняющем отмену. is executed on the thread that is performing the cancellation. Это может использоваться для организации асинхронного уведомления вычисления об отмене, например посредством установки флага или отмены регистрации ожидающего выполнения действия ввода-вывода.</remarks>
 <param name="interruption">Функция, выполняемая в потоке, в котором осуществляется отмена.</param>
 <returns>Асинхронное вычисление, которое запускает прерывание в случае отмены до удаления.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Ignore``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Создает асинхронное вычисление, которое запускает заданное вычисление и игнорирует его результат.</summary>
 <param name="computation">Входное вычисление.</param>
 <returns>Вычисление, эквивалентное входному, которое при этом игнорирует результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromContinuations``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
 <summary>Создает асинхронное вычисление, которое собирает текущие продолжения состояний успеха, исключения и отмены. Обратный вызов должен в конечном итоге вызывать только одно из заданных продолжений.</summary>
 <param name="callback">Функция, которая принимает текущие продолжения состояний успеха, исключения и отмены.</param>
 <returns>Асинхронное вычисление, которое предоставляет функцию обратного вызова с текущими продолжениями.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Создает асинхронное вычисление в виде пары действий Begin/End в стиле, используемом в API-интерфейсах инфраструктуры CLI. Эту перегрузку следует использовать, если операция определяется тремя аргументами. Например, <c>Async.FromBeginEnd(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)</c> При выполнении вычисления выполняется функция <c>beginFunc</c> с обратным вызовом, представляющим продолжение вычисления. При запуске обратного вызова для поиска общего результата используется функция <c>endFunc</c>.</summary>

 <remarks>Вычисление будет реагировать на отмену, ожидая завершения операции. Если произошла отмена и указано действие <c>cancelAction</c>, это действие выполняется, и вычисление продолжает ожидать завершения операции. Если действие <c>cancelAction</c> не указано, отмена вызывает немедленное прекращение вычисления, и последующие вызовы функции обратного вызова игнорируются.</remarks>
 <param name="arg1">Первый аргумент для данной операции.</param>
 <param name="arg2">Второй аргумент для данной операции.</param>
 <param name="arg3">Третий аргумент для данной операции.</param>
 <param name="beginAction">Функция, инициирующая традиционную асинхронную операцию CLI.</param>
 <param name="endAction">Функция, завершающая традиционную асинхронную операцию CLI.</param>
 <param name="cancelAction">Необязательная функция, выполняемая при запросе отмены.</param>
 <returns>Асинхронное вычисление, заключающее в оболочку заданные функции Begin/End.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Создает асинхронное вычисление в виде пары действий Begin/End в стиле, используемом в API-интерфейсах инфраструктуры CLI. Эту перегрузку следует использовать, если операция определяется двумя аргументами. Например, <c>Async.FromBeginEnd(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)</c> При выполнении вычисления выполняется функция <c>beginFunc</c> с обратным вызовом, представляющим продолжение вычисления. При запуске обратного вызова для поиска общего результата используется функция <c>endFunc</c>.</summary>

 <remarks>Вычисление будет реагировать на отмену, ожидая завершения операции. Если произошла отмена и указано действие <c>cancelAction</c>, это действие выполняется, и вычисление продолжает ожидать завершения операции. Если действие <c>cancelAction</c> не указано, отмена вызывает немедленное прекращение вычисления, и последующие вызовы функции обратного вызова игнорируются.</remarks>
 <param name="arg1">Первый аргумент для данной операции.</param>
 <param name="arg2">Второй аргумент для данной операции.</param>
 <param name="beginAction">Функция, инициирующая традиционную асинхронную операцию CLI.</param>
 <param name="endAction">Функция, завершающая традиционную асинхронную операцию CLI.</param>
 <param name="cancelAction">Необязательная функция, выполняемая при запросе отмены.</param>
 <returns>Асинхронное вычисление, заключающее в оболочку заданные функции Begin/End.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``2(``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Создает асинхронное вычисление в виде пары действий Begin/End в стиле, используемом в API-интерфейсах инфраструктуры CLI. Эту перегрузку следует использовать, если операция определяется одним аргументом. Например, <c>Async.FromBeginEnd(place,ws.BeginGetWeather,ws.EndGetWeather)</c> При выполнении вычисления выполняется функция <c>beginFunc</c> с обратным вызовом, представляющим продолжение вычисления. При запуске обратного вызова для поиска общего результата используется функция <c>endFunc</c>.</summary>

 <remarks>Вычисление будет реагировать на отмену, ожидая завершения операции. Если произошла отмена и указано действие <c>cancelAction</c>, это действие выполняется, и вычисление продолжает ожидать завершения операции. Если действие <c>cancelAction</c> не указано, отмена вызывает немедленное прекращение вычисления, и последующие вызовы функции обратного вызова игнорируются.</remarks>
 <param name="arg">Аргумент операции.</param>
 <param name="beginAction">Функция, инициирующая традиционную асинхронную операцию CLI.</param>
 <param name="endAction">Функция, завершающая традиционную асинхронную операцию CLI.</param>
 <param name="cancelAction">Необязательная функция, выполняемая при запросе отмены.</param>
 <returns>Асинхронное вычисление, заключающее в оболочку заданные функции Begin/End.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Создает асинхронное вычисление в виде пары действий Begin/End в стиле, используемом в API-интерфейсах инфраструктуры CLI. Например, <c>Async.FromBeginEnd(ws.BeginGetWeather,ws.EndGetWeather)</c> При выполнении вычисления выполняется функция <c>beginFunc</c> с обратным вызовом, представляющим продолжение вычисления. При запуске обратного вызова для поиска общего результата используется функция <c>endFunc</c>.</summary>

 <remarks>Вычисление будет реагировать на отмену, ожидая завершения операции. Если произошла отмена и указано действие <c>cancelAction</c>, это действие выполняется, и вычисление продолжает ожидать завершения операции. Если действие <c>cancelAction</c> не указано, отмена вызывает немедленное прекращение вычисления, и последующие вызовы функции обратного вызова игнорируются.</remarks>
 <param name="beginAction">Функция, инициирующая традиционную асинхронную операцию CLI.</param>
 <param name="endAction">Функция, завершающая традиционную асинхронную операцию CLI.</param>
 <param name="cancelAction">Необязательная функция, выполняемая при запросе отмены.</param>
 <returns>Асинхронное вычисление, заключающее в оболочку заданные функции Begin/End.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Catch``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Создает асинхронное вычисление, выполняющее вычисление <c>computation</c>. При успешном завершении вычисления возвращается объект <c>Choice1Of2</c> с возвращенным значением. Если это вычисление создает исключение до своего завершения, возвращается объект <c>Choice2Of2</c> с созданным исключением.</summary>
 <param name="computation">Входное вычисление, возвращающее значение типа T.</param>
 <returns>Вычисление, возвращающее выбор типа T или исключение.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultToken">
 <summary>Создает условие отмены последнего набора начатых асинхронных вычислений без какого-либо конкретного токена CancellationToken. Заменяет глобальный источник CancellationTokenSource на новый глобальный источник токенов для любых асинхронных вычислений, созданных после этого момента без какого-либо конкретного токена CancellationToken.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitWaitHandle(System.Threading.WaitHandle,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Создает асинхронное вычисление, которое будет обслуживать заданный член WaitHandle.</summary>

 <remarks>Вычисление возвращает значение true, если дескриптор обозначил результат в течение заданного времени ожидания.</remarks>
 <param name="waitHandle">Объект <c>WaitHandle</c>, о котором может сигнализироваться.</param>
 <param name="millisecondsTimeout">Значение времени ожидания в миллисекундах. Если не предоставляется, используется значение по умолчанию, -1, соответствующее <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, которое ожидает заданный объект <c>WaitHandle</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask``1(System.Threading.Tasks.Task{``0})">
<summary>
 Возвращает асинхронное вычисление, которое ожидает выполнения указанной задачи и возвращает ее результат.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitIAsyncResult(System.IAsyncResult,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Создает асинхронное вычисление, которое будет обслуживать IAsyncResult.</summary>

 <remarks>Вычисление возвращает значение true, если дескриптор обозначил результат в течение заданного времени ожидания.</remarks>
 <param name="iar">Объект IAsyncResult, сигнализация которого ожидается.</param>
 <param name="millisecondsTimeout">Значение времени ожидания в миллисекундах. Если не предоставляется, используется значение по умолчанию, -1, соответствующее <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, которое ожидает заданный объект <c>IAsyncResult</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitEvent``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Создает асинхронное вычисление, которое ожидает однократного вызова события CLI, посредством добавления в это событие обработчика. По завершении или при отмене вычисления происходит удаление обработчика из события.</summary>

 <remarks>Вычисление прореагирует на отмену, ожидая событие. Если произошла отмена и указано действие <c>cancelAction</c>, это действие выполняется, и вычисление продолжает ожидать событие. Если действие <c>cancelAction</c> не указано, отмена вызывает немедленную отмену вычисления.</remarks>
 <param name="event">Событие, предназначенное для однократной обработки.</param>
 <param name="cancelAction">Необязательная функция, выполняемая вместо отмены при выдаче отмены.</param>
 <returns>Асинхронное вычисление, которое ожидает вызов события.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AsBeginEnd``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Создает три функции, которые можно использовать для реализации асинхронной модели программирования (APM) .NET для заданного асинхронного вычисления.</summary>
 
 <remarks>Как правило, функция должна публиковаться в виде элементов с префиксом <c>Begin</c>, <c>End</c> и <c>Cancel</c>. Ее можно использовать в пределах определения типа следующим образом: <c> let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg -&gt; computation) member x.BeginSomeOperation(arg,callback,state:obj) = beginAction(arg,callback,state) member x.EndSomeOperation(iar) = endAction(iar) member x.CancelSomeOperation(iar) = cancelAction(iar) </c> Если в асинхронном вычислении отсутствуют аргументы, AsBeginEnd используется следующим образом: <c> let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun () -&gt; computation) member x.BeginSomeOperation(callback,state:obj) = beginAction((),callback,state) member x.EndSomeOperation(iar) = endAction(iar) member x.CancelSomeOperation(iar) = cancelAction(iar) </c> Если в асинхронном вычислении используется два аргумента, AsBeginEnd используется следующим образом: <c> let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg1 arg2 -&gt; computation) member x.BeginSomeOperation(arg1,arg2,callback,state:obj) = beginAction((),callback,state) member x.EndSomeOperation(iar) = endAction(iar) member x.CancelSomeOperation(iar) = cancelAction(iar) </c> В каждом случае полученный API-интерфейс будет знаком программистам, работающим с другими языками CLI. Вышеописанный способ позволяет удобно публиковать асинхронные вычисления в компонентах CLI.</remarks>
 <param name="computation">Функция, создающая асинхронное вычисление, которое нужно разделить для обычной асинхронной модели программирования (APM) .NET.</param>
 <returns>Кортеж элементов begin, end и cancel.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync">
 <summary>Этот статический класс содержит члены для создания асинхронных вычислений и управления ими.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Zero">
 <summary>Создает асинхронное вычисление, которое просто возвращает <c>()</c>.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие данного метода позволяет использовать пустые ветви <c>else</c>в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <returns>Асинхронное вычисление, которое возвращает <c>()</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.While(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
 <summary>Создает асинхронное вычисление, которое выполняет вычисление <c>computation</c> несколько раз до тех пор, пока <c>guard()</c> не примет значение false.</summary>

 <remarks>При каждом выполнении вычисления осуществляется проверка отмены. Наличие этого метода позволяет использовать выражение <c>while</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="guard">Функция для определения времени прекращения выполнения вычисления <c>computation</c>.</param>
 <param name="computation">Выполняемая функция. Эквивалентно основной части выражения <c>while</c>.</param>
 <returns>Асинхронное вычисление, результат выполнения которого аналогичен результату цикла while.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Создает асинхронное вычисление, выполняющее <c>binder(resource)</c>. После того как это вычисление выдает результат или прекращает работу из-за исключения или отмены, выполняется действие <c>resource.Dispose()</c>.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие этого метода позволяет использовать выражения <c>use</c> и <c>use!</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="resource">Ресурс, который нужно использовать и удалить.</param>
 <param name="binder">Функция, которая принимает ресурс и возвращает асинхронное вычисление.</param>
 <returns>Асинхронное вычисление, которое выполняет привязку ресурса <c>resource</c>, а затем удаляет его.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryWith``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Создает асинхронное вычисление, которое запускает вычисление <c>computation</c> и возвращает его результат. Если создается исключение, вызывается обработчик <c>catchHandler(exn)</c> и вместо предыдущего выполняется полученное исключение.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие этого метода позволяет использовать выражение <c>try/with</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="computation">Входное вычисление.</param>
 <param name="catchHandler">Выполняемая функция при создании исключения <c>computation</c>.</param>
 <returns>Асинхронное вычисление, которое выполняет вычисление <c>computation</c> и вызывает обработчик <c>catchHandler</c>. при создании исключения.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Создает асинхронное вычисление, которое запускает вычисление <c>computation</c>. Действие <c>compensation</c> выполняется по завершении действия <c>computation</c> независимо от того, нормально или с исключением завершается действие <c>computation</c>. Если действие <c>compensation</c> само создает исключение, исходное исключение игнорируется, а новое становится общим результатом вычисления.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие этого метода позволяет использовать выражение <c>try/finally</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="computation">Входное вычисление.</param>
 <param name="compensation">Действие, которое должно выполняется после завершения действия <c>computation</c> или создания исключения (включая отмену).</param>
 <returns>Асинхронное вычисление, выполняющее вычисление и компенсацию после завершения вычисления или при создании исключения.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.ReturnFrom``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Делегат для входного вычисления.</summary>

 <remarks>Наличие этого метода позволяет использовать выражение <c>return!</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="computation">Входное вычисление.</param>
 <returns>Входное вычисление.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Return``1(``0)">
 <summary>Создает асинхронное вычисление, которое возвращает результат <c>v</c>.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие этого метода позволяет использовать выражение <c>return</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="value">Значение, возвращаемое вычислением.</param>
 <returns>Асинхронное вычисление, при выполнении которого возвращается значение <c>value</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.For``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
 <summary>Создает асинхронное вычисление, которое перечисляет последовательность <c>seq</c> по требованию и выполняет <c>body</c> для каждого элемента.</summary>

 <remarks>В каждой итерации цикла выполняется проверка отмены. Наличие этого метода позволяет использовать выражение <c>for</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="sequence">Перечисляемая последовательность.</param>
 <param name="body">Функция, которая принимает элемент из последовательности и создает асинхронное вычисление. Может отображаться как тело выражения <c>for</c>.</param>
 <returns>Асинхронное вычисление, которое перечисляет последовательность и выполняет тело выражения <c>body</c> для каждого элемента.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Создает асинхронное вычисление, которое запускает генератор <c>generator</c>.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены.</remarks>
 <param name="generator">Выполняемая функция.</param>
 <returns>Асинхронное вычисление, которое запускает генератор <c>generator</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Combine``1(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Создает асинхронное вычисление, которое сначала запускает вычисление <c>computation1</c>, а затем выполняет вычисление <c>computation2</c>, возвращая результат вычисления <c>computation2</c>.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие данного метода позволяет использовать последовательности выражений в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="computation1">Первая часть последовательного вычисления.</param>
 <param name="computation2">Вторая часть последовательного вычисления.</param>
 <returns>Асинхронное вычисление, которое последовательно запускает оба вычисления.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Bind``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Создает асинхронное вычисление, которое выполняет вычисление <c>computation</c>, а когда вычисление <c>computation</c> создает результат <c>T</c>, выполняет <c>binder res</c>.</summary>

 <remarks>При выполнении вычисления осуществляется проверка отмены. Наличие этого метода позволяет использовать выражение <c>let!</c> в синтаксисе вычислительного выражения <c>async { ... }</c>.</remarks>
 <param name="computation">Вычисление, которое предоставляет несвязанный результат.</param>
 <param name="binder">Функция для привязки результата вычисления <c>computation</c>.</param>
 <returns>Асинхронное вычисление, которое выполняет привязку результата вычисления <c>computation</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.#ctor">
<summary>
 Создается объект, который используется для создания асинхронных вычислений с помощью вычислительных выражений F#. Значение "async" является предварительно определенным экземпляром этого типа. При выполнении вычисления осуществляется проверка отмены.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncBuilder">
 <summary>Тип оператора <c>async</c>, который используется для создания рабочих процессов для асинхронных вычислений.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1.Reply(`0)">
 <summary>Отправляет ответ на сообщение PostAndReply.</summary>
 <param name="value">Отправляемое значение.</param>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1">
 <summary>Дескриптор функции ответа на сообщение PostAndReply.</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync`1">
 <summary>Составное асинхронное вычисление, которое при выполнении создает значение типа T или в противном случае вызывает исключение.</summary> 

 <remarks>Асинхронные вычисления обычно задаются с помощью вычислительных выражений F#. Асинхронные вычисления выполняются в двух режимах: как рабочий элемент (выполнение синхронного кода) или как ожидающий элемент (ожидающий события и завершения ввода-вывода). Выполнение асинхронных вычислений может управляться токеном CancellationToken. Этот токен, как правило, может указываться при запуске асинхронного вычисления. Для отмены асинхронного вычисления может использовать связанный класс CancellationTokenSource. Асинхронные вычисления, созданные с помощью вычислительных выражений, могут регулярно проверять условие отмены. Синхронные вычисления, выполняющиеся внутри асинхронного вычисления, не осуществляют автоматическую проверку этого условия.</remarks> 
</member>
<member name="P:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Publish">
 <summary>Публикует событие в качестве значения события первого класса.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Trigger(System.Object[])">
 <summary>Активирует событие с помощью заданных параметров.</summary>
 <param name="args">Параметры события.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.#ctor">
 <summary>Создает объект события, подходящий для реализации произвольного типа делегата.</summary>
 <returns>Объект события.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpDelegateEvent`1">
 <summary>Реализации событий для произвольного типа делегата.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`1.Publish">
 <summary>Публикует наблюдение в качестве значения первого класса.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.Trigger(`0)">
 <summary>Активирует наблюдение с помощью заданных параметров.</summary>
 <param name="arg">Параметры события.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.#ctor">
 <summary>Создает наблюдаемый объект.</summary>
 <returns>Созданное событие.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`1">
 <summary>Реализация событий для типа IEvent&lt;_&gt;.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`2.Publish">
 <summary>Публикует событие в качестве значения события первого класса.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.Trigger(System.Object,`1)">
 <summary>Активирует событие с помощью объекта и параметров заданного отправителя. Объект отправителя может иметь значение <c>null</c>.</summary>
 <param name="sender">Объект, активирующий событие.</param>
 <param name="args">Параметры события.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.#ctor">
 <summary>Создает объект события, пригодный для типов делегата, которые следуют стандартному правилу аргумента первого "отправителя" .NET Framework.</summary>
 <returns>Созданное событие.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`2">
 <summary>Реализации событий для типов делегата, которые следуют стандартному правилу аргумента первого "отправителя" .NET Framework.</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Control.FSharpHandler`1">
 <summary>Тип делегата, связанный с типом событий <c>IEvent&lt;_&gt;</c> языка F#</summary>
 <param name="obj">Объект, создавший событие.</param>
 <param name="args">Аргументы события.</param>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.RemoveHandler(`0)">
 <summary>Удаляет делегат прослушивателя из хранилища прослушивателя событий.</summary>
 <param name="handler">Делегат, который необходимо удалить из хранилища прослушивателя событий.</param>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.AddHandler(`0)">
 <summary>Подключает к событию объект делегата обработчика. В дальнейшем обработчик можно будет удалить с помощью RemoveHandler. Прослушиватель будет вызван при запуске события.</summary>
 <param name="handler">Делегат, вызываемый при запуске события.</param>
</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`1">
 <summary>Значения события первого класса для произвольных типов делегатов.</summary>

 <remarks>F# дает особый статус свойствам членов, совместимым с типом IDelegateEvent и помеченным атрибутом CLIEventAttribute. В данном случае компилятор F# создает соответствующие метаданные CLI для того, чтобы член появился в других языках CLI в качестве события CLI.</remarks>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
 <summary>Точки прослушивания первого класса, (т.е. объекты, позволяющие зарегистрировать обратный вызов, активированный при инициации события). </summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`2">
 <summary>Значения события первого класса для событий CLI, соответствующих стандартам CLI Framework.</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
 <summary>Тип отложенных вычислений.</summary>
 
 <remarks>Значения в модуле <c>Lazy</c> используются для обработки значений этого типа, а нотация <c>lazy expr</c> — для создания значений типа <see cref="System.Lazy{T}" />.</remarks>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout(System.Int32)">
 <summary>Создает исключение времени ожидания при неполучении сообщения в течение этого периода времени. По умолчанию время ожидания не используется.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Вызывается, если в результате выполнения агента возникает исключение.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Error">
 <summary>Вызывается, если в результате выполнения агента возникает исключение.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout">
 <summary>Создает исключение времени ожидания при неполучении сообщения в течение этого периода времени. По умолчанию время ожидания не используется.</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.CurrentQueueLength">
 <summary>Возвращает число необработанных сообщений в очереди сообщений агента.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Вызывается, если в результате выполнения агента возникает исключение.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Сканирует сообщение, выполняя поиск по сообщениям в порядке поступления до тех пор, пока функция <c>scanner</c> не вернет значение Some. Остальные сообщения остаются в очереди.</summary>

 <remarks>Этот метод предназначен для использования в теле агента. Для каждого агента в каждый момент времени может быть активно только одно средство чтения, поэтому активным может быть только один вызов Receive, TryReceive, Scan или TryScan.</remarks>
 <param name="scanner">Функция для возвращения значения None, если сообщение необходимо пропустить, или Some, если сообщение следует обработать и удалить из очереди.</param>
 <param name="timeout">Необязательное время ожидания в миллисекундах. Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, построенное функцией <c>scanner</c> из прочитанного сообщения.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Ожидает сообщение. Будет использовано первое сообщение в порядке поступления.</summary> 

 <remarks>Этот метод предназначен для использования в теле агента. Он возвращает значение None, если время ожидания задано и превышено. Этот метод предназначен для использования в теле агента. Для каждого агента в каждый момент времени может быть активно только одно средство чтения, поэтому активным может быть только один вызов Receive, TryReceive, Scan или TryScan.</remarks>
 <param name="timeout">Необязательное время ожидания в миллисекундах. Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, которое возвращает принятое сообщение или значение None, если время ожидания истекло.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Действует как PostAndReply, но возвращает None при отсутствии ответа в течение периода ожидания.</summary>
 <param name="buildMessage">Функция, используемая для включения AsyncReplyChannel в отправляемое сообщение.</param>
 <param name="timeout">Необязательный параметр времени ожидания ответного сообщения (в миллисекундах). Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Ответ от агента — None, если время ожидания истекло.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start">
 <summary>Запускает агент.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Создает и запускает агент. Функция <c>body</c> используется для создания асинхронного вычисления, выполняемого агентом.</summary>
 <param name="body">Функция для формирования асинхронного вычисления, которое выполняется как цикл чтения для объекта MailboxProcessor при вызове метода Start.</param>
 <param name="cancellationToken">Необязательный токен отмены для <c>body</c>. По умолчанию используется <c>Async.DefaultCancellationToken</c>.</param>
 <returns>Созданный объект MailboxProcessor.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Сканирует сообщение, выполняя поиск по сообщениям в порядке поступления до тех пор, пока функция <c>scanner</c> не вернет значение Some. Остальные сообщения остаются в очереди.</summary>

 <remarks>Он возвращает значение None, если время ожидания задано и превышено. Этот метод предназначен для использования в теле агента. Для каждого агента в каждый момент времени может быть активно только одно средство чтения, поэтому активным может быть только один вызов Receive, TryReceive, Scan или TryScan.</remarks>
 <param name="scanner">Функция для возвращения значения None, если сообщение необходимо пропустить, или Some, если сообщение следует обработать и удалить из очереди.</param>
 <param name="timeout">Необязательное время ожидания в миллисекундах. Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, построенное функцией <c>scanner</c> из прочитанного сообщения.</returns>
 <exception cref="System.TimeoutException">Создается в случае превышения времени ожидания.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Ожидает сообщение. Будет использовано первое сообщение в порядке поступления.</summary> 

 <remarks>Этот метод предназначен для использования в теле агента. Этот метод предназначен для использования в теле агента. Для каждого агента в каждый момент времени может быть активно только одно средство чтения, поэтому активным может быть только один вызов Receive, TryReceive, Scan или TryScan.</remarks>
 <param name="timeout">Необязательное время ожидания в миллисекундах. Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, которое возвращает полученное сообщение.</returns>
 <exception cref="System.TimeoutException">Создается в случае превышения времени ожидания.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Действует как AsyncPostAndReply, но возвращает None при отсутствии ответа в течение периода ожидания.</summary>
 <param name="buildMessage">Функция, используемая для включения AsyncReplyChannel в отправляемое сообщение.</param>
 <param name="timeout">Необязательный параметр времени ожидания ответного сообщения (в миллисекундах). Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, которое возвращает ответ или значение None по истечении времени ожидания.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Отправляет агенту сообщение и одновременно ожидает ответа по каналу.</summary>

 <remarks>Сообщение создается путем применения функции <c>buildMessage</c> к новому каналу ответа, включаемому в сообщение. Агент-получатель должен обработать данное сообщение и вызвать метод Reply для этого канала ответа ровно один раз.</remarks>
 <param name="buildMessage">Функция, используемая для включения AsyncReplyChannel в отправляемое сообщение.</param>
 <param name="timeout">Необязательный параметр времени ожидания ответного сообщения (в миллисекундах). Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Ответ агента.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Отправляет агенту сообщение и ожидает ответа по каналу асинхронным образом.</summary> 

 <remarks>Сообщение создается путем применения функции <c>buildMessage</c> к новому каналу ответа, включаемому в сообщение. Агент-получатель должен обработать данное сообщение и вызвать метод Reply для этого канала ответа ровно один раз.</remarks>
 <param name="buildMessage">Функция, используемая для включения AsyncReplyChannel в отправляемое сообщение.</param>
 <param name="timeout">Необязательный параметр времени ожидания ответного сообщения (в миллисекундах). Значение по умолчанию — -1, что соответствует <c>System.Threading.Timeout.Infinite</c>.</param>
 <returns>Асинхронное вычисление, ожидающее ответа агента.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Post(`0)">
 <summary>Отправляет сообщение в очередь сообщений MailboxProcessor асинхронным образом.</summary>
 <param name="message">Публикуемое сообщение.</param>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.#ctor(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Создает агент. Функция <c>body</c> используется для создания асинхронного вычисления, выполняемого агентом. Эта функция не выполняется до вызова метода <c>Start</c>.</summary>
 <param name="body">Функция для формирования асинхронного вычисления, которое выполняется как цикл чтения для объекта MailboxProcessor при вызове метода Start.</param>
 <param name="cancellationToken">Необязательный токен отмены для <c>body</c>. По умолчанию используется <c>Async.DefaultCancellationToken</c>.</param>
 <returns>Созданный объект MailboxProcessor.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpMailboxProcessor`1">
 <summary>Агент обработки сообщений, выполняющий асинхронное вычисление.</summary>

 <remarks>Агент инкапсулирует очередь сообщений, которая поддерживает несколько модулей записи и один агент чтения. Модули записи отправляют сообщения агенту с помощью метода Post и его разновидностей. Агент может ожидать сообщений методом Receive или TryReceive или сканировать все доступные сообщения методом Scan или TryScan.</remarks>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.SubscribeToObservable``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Подключает функцию прослушивателя к наблюдаемому объекту. Прослушиватель будет вызываться для каждого наблюдения. Прослушиватель может быть удален вызовом метода Dispose для возвращенного объекта IDisposable.</summary>
 <param name="callback">Функция, вызываемая для каждого наблюдения.</param>
 <returns>Объект, устраняющий удаленный прослушиватель.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AddToObservable``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Подключает постоянно функцию прослушивателя к наблюдаемому объекту. Прослушиватель будет вызываться для каждого наблюдения.</summary>
 <param name="callback">Функция, вызываемая для каждого наблюдения.</param>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncWrite(System.IO.Stream,System.Byte[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Возвращает асинхронное вычисление, которое будет записывать заданные байты в поток.</summary>
 <param name="buffer">Буфер, из которого записываются данные.</param>
 <param name="offset">Дополнительное смещение в виде числа байтов в потоке.</param>
 <param name="count">Дополнительное число байтов для записи в поток.</param>
 <returns>Асинхронное вычисление, которое будет записывать заданные байты в поток.</returns>
 <exception cref="System.ArgumentException">Вызывается, если в сумме смещение и показатель количества длиннее, чем буфер.</exception>
 <exception cref="System.ArgumentOutOfRangeException">Создается, если смещение или количество отрицательные.</exception>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncReadBytes(System.IO.Stream,System.Int32)">
 <summary>Возвращает асинхронное вычисление, которое будет считывать заданное количество байтов из потока.</summary>
 <param name="count">Количество байтов, чтение которых необходимо выполнить.</param>
 <returns>Асинхронное вычисление, возвращающее при выполнении байт считывания byte[].</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncRead(System.IO.Stream,System.Byte[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Возвращает асинхронное вычисление, которое будет считывать данные из потока в заданный буфер.</summary>
 <param name="buffer">Буфер, в который необходимо считать данные.</param>
 <param name="offset">Дополнительное смещение в виде числа байтов в потоке.</param>
 <param name="count">Дополнительное число байтов для чтения из потока.</param>
 <returns>Асинхронное вычисление, которое будет считывать данные из потока в заданный буфер.</returns>
 <exception cref="System.ArgumentException">Вызывается, если в сумме смещение и показатель количества длиннее, чем буфер.</exception>
 <exception cref="System.ArgumentOutOfRangeException">Создается, если смещение или количество отрицательные.</exception>
</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">
 <summary>Модуль членов расширений, обеспечивающий выполнение асинхронных операций для некоторых основных типов CLI, связанных с параллелизмом и вводом-выводом.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Pairwise``2(Microsoft.FSharp.Control.IEvent{``0,``1})">
 <summary>Возвращает новое событие, которое активирует вторую и последующие активации входного события. Для N-ной активации входного события передаются аргументы от активаций N-1 и N в виде пары. Аргумент, переданный активации N-1, содержится в скрытом внутреннем состоянии до N-ной активации.</summary>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Событие, которое при активации использует пару последовательных значений, переданных из исходного события.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Add``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Запускает заданную функцию всякий раз при активации заданного события.</summary>
 <param name="callback">Функция, вызываемая при активации события.</param>
 <param name="sourceEvent">Входное событие.</param>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Scan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Возвращает новое событие, состоящее из результатов применения заданной функции накопления к последовательным значениям, вызванным входным событием. Элемент внутреннего состояния записывает текущее значение параметра состояния. При выполнении функции накопления внутреннее состояние не подвергается блокировке, поэтому необходимо сделать так, чтобы входное событие IEvent не вызывалось несколькими потоками одновременно.</summary>
 <param name="collector">Функция, используемая для обновления состояния посредством значения каждого события.</param>
 <param name="state">Начальное состояние.</param>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Событие, запускаемое при обновлении значений состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.IEvent{``2,``0})">
 <summary>Возвращает новое событие, которое инициируется при выборе сообщений из первоначального события. Функция выбора переводит первоначальное сообщение в дополнительное новое сообщение.</summary>
 <param name="chooser">Функция выбора и преобразования значений событий для передачи.</param>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Событие, которое вызывается, только если от функции выбора получен результат Some.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Split``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Control.IEvent{``3,``0})">
 <summary>Возвращает новое событие, ожидающее первоначальное событие и вызывающее первое результирующее событие, если применение функции к аргументам события возвращает значение Choice1Of2, и второе событие, если возвращается значение Choice2Of2.</summary>
 <param name="splitter">Функция для преобразования значений событий в один из двух типов.</param>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Кортеж событий. Первое событие активируется, когда функция <c>splitter</c>возвращает значение Choice1of1, а второе — когда функция <c>splitter</c> возвращает значение Choice2of2.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Возвращает новое событие, ожидающее первоначальное событие и вызывающее первое результирующее событие, если применение предиката к аргументам события возвращает значение true, и второе событие, если возвращается значение false.</summary>
 <param name="predicate">Функция, предназначенная для определения выходного события, которое следует инициировать.</param>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Кортеж событий. Первое событие активируется, когда предикат возвращает значение true, а второе — при возврате предикатом значения false.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Возвращает новое событие, ожидающее первоначальное событие и вызывающее результирующее событие, только когда аргумент события передает указанную функцию.</summary>
 <param name="predicate">Функция, предназначенная для определения триггеров события, которые следует распространить.</param>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Событие, которое передает только значения, прошедшие предикат.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``0})">
 <summary>Возвращает новое событие, которое передает значения, преобразованные заданной функцией.</summary>
 <param name="map">Функция преобразования значений событий.</param>
 <param name="sourceEvent">Входное событие.</param>
 <returns>Событие, которое передает преобразованные значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Merge``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Вызывает выходное событие, если инициировано какое-либо из входных событий.</summary>
 <param name="event1">Первое входное событие.</param>
 <param name="event2">Второе входное событие.</param>
 <returns>Событие, которое вызывается, если инициировано какое-либо из входных событий.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.EventModule">

</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.Force``1(System.Lazy{``0})">
 <summary>Обеспечивает принудительное выполнение данного значения и возвращает его результат. Аналогичен методу Value. Для предотвращения вычисления значения другими потоками используется взаимное исключение.</summary>
 <returns>Значение объекта Lazy.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.CreateFromValue``1(``0)">
 <summary>Создает отложенное вычисление, которое при принудительном выполнении оценивает заданное значение.</summary>
 <param name="value">Входное значение.</param>
 <returns>Созданный объект Lazy.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.Create``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Создает отложенное вычисление, которое при принудительном выполнении вычисляет результат заданной функции.</summary>
 <param name="creator">Функция для предоставления значения при необходимости.</param>
 <returns>Созданный объект Lazy.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.LazyExtensions">
 <summary>Расширения связанных отложенных значений.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Pairwise``1(System.IObservable{``0})">
 <summary>Возвращает новый наблюдаемый объект, который активирует второй и последующие вызовы входного наблюдаемого объекта. Вызов N входного наблюдаемого объекта передает аргументы от вызовов N-1 и N в виде пары. Аргумент, переданный активации N-1, содержится в скрытом внутреннем состоянии до N-ной активации.</summary>

 <remarks>Для каждого наблюдателя зарегистрированный для наблюдения промежуточный объект не является потокобезопасным. Таким образом, наблюдения из источников не должны параллельно активироваться на различных потоках.</remarks>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Наблюдаемый объект, который активирует последующие пары наблюдений из входного наблюдаемого объекта.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Subscribe``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
 <summary>Создает наблюдателя, который осуществляет подписку на заданный наблюдаемый объект и вызывает заданную функцию при каждом наблюдении.</summary>
 <param name="callback">Функция, вызываемая для каждого наблюдения.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Объект, устраняющий удаленный обратный вызов.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Add``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
 <summary>Создает наблюдатель, который осуществляет постоянную подписку на заданный наблюдаемый объект и вызывает заданную функцию для каждого наблюдения.</summary>
 <param name="callback">Функция, вызываемая для каждого наблюдения.</param>
 <param name="source">Входной наблюдаемый объект.</param>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.IObservable{``1})">
 <summary>Возвращает наблюдаемый объект, который распределяет элемент состояния для каждого наблюдателя и применяет заданную функцию накопления к последовательным значениям, поступающим из входных данных. Возвращаемый объект активирует наблюдения для каждого вычисленного значения состояния, исключая начальное значение. Возвращаемый объект распространяет все ошибки, поступающие из источника, и завершается при завершении источника.</summary>

 <remarks>Для каждого наблюдателя зарегистрированный для наблюдения промежуточный объект не является потокобезопасным. Таким образом, наблюдения из источников не должны параллельно активироваться на различных потоках.</remarks>
 <param name="collector">Функция, используемая для обновления состояния посредством каждого наблюдения.</param>
 <param name="state">Начальное состояние.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Наблюдаемый объект, который запускает обновленные значения состояния.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.IObservable{``0})">
 <summary>Возвращает наблюдаемый объект, который выбирает из источника проекцию наблюдений с помощью заданной функции. Возвращаемый объект будет активировать наблюдения <c>x</c>, для которых функция splitter возвращает значение <c>Some x</c>. Кроме того, возвращаемый объект распространяет все ошибки, поступающие из источника, и завершается при завершении источника.</summary>
 <param name="chooser">Функция, которая возвращает значение Some для наблюдений, которые следует распространить, и значение None наблюдений, которые следует игнорировать.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Наблюдаемый объект, который распространяет только некоторые наблюдения из источника.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Split``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},System.IObservable{``0})">
 <summary>Возвращает два наблюдаемых объекта, которые разделяют наблюдения из источника с помощью заданной функции. Первый объект будет активировать наблюдения <c>x</c>, для которых функция splitter возвращает значение <c>Choice1Of2 x</c>. Второй объект будет активировать наблюдения <c>y</c>, для которых функция splitter возвращает результат <c>Choice2Of2 y</c>. Функция выполняется однократно для каждого подписанного наблюдателя. Оба наблюдаемых объекта распространяют наблюдения ошибок, поступающие из источника, и завершаются при завершении источника.</summary>
 <param name="splitter">Функция, принимающая объект наблюдения для преобразования его в один из двух типов Choice.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Кортеж наблюдаемых объектов. Первый объект активируется, когда функция <c>splitter</c> возвращает Choice1of2, а второй — когда функция <c>splitter</c> возвращает значение Choice2of2.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.IObservable{``0})">
 <summary>Возвращает два наблюдаемых объекта, которые разделяют наблюдения из источника с помощью заданной функции. Первый наблюдаемый объект активирует наблюдения для тех значений, для которых предикат возвращает значение true. Второй наблюдаемый объект активирует наблюдения для тех значений, для которых предикат возвращает значение false. Предикат выполняется один раз для каждого наблюдателя-подписчика. Оба наблюдаемых объекта распространяют все наблюдения ошибок, поступающие из источника, и завершаются при завершении источника.</summary>
 <param name="predicate">Функция, предназначенная для определения выходного наблюдаемого объекта, который активирует определенное наблюдение.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Кортеж наблюдаемых объектов. Первый объект выполняет активацию, когда предикат возвращает значение true, а второй — при возврате предикатом значения false.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.IObservable{``0})">
 <summary>Возвращает наблюдаемый объект, который фильтрует наблюдения из источника по указанной функции. Наблюдаемый объект будет видеть только те наблюдения, для которых предикат возвращает значение true. Предикат выполняется один раз для каждого наблюдателя-подписчика. Кроме того, возвращаемый объект распространяет наблюдения ошибок, поступающие из источника, и завершается при завершении источника.</summary>
 <param name="filter">Функция применяется к наблюдениям, чтобы определить необходимость ее сохранения.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Наблюдаемый объект, фильтрующий наблюдения на основании фильтра <c>filter</c>.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.IObservable{``0})">
 <summary>Возвращает наблюдаемый объект, который преобразует наблюдения из источника с помощью заданной функции. Функция преобразования выполняется один раз для каждого наблюдателя-подписчика. Кроме того, возвращаемый объект распространяет наблюдения ошибок, поступающие из источника, и завершается при завершении источника.</summary>
 <param name="mapping">Функция, применяемая к наблюдениям из источника.</param>
 <param name="source">Входной наблюдаемый объект.</param>
 <returns>Наблюдаемый объект типа, указанного сопоставлением <c>mapping</c>.</returns> 
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Merge``1(System.IObservable{``0},System.IObservable{``0})">
 <summary>Возвращает наблюдаемый объект для объединенных наблюдений из источников. Возвращаемый объект распространяет значения успеха и ошибок из любого источника и завершается при завершении обоих источников.</summary>

 <remarks>Для каждого наблюдателя зарегистрированный для наблюдения промежуточный объект не является потокобезопасным. Таким образом, наблюдения из источников не должны параллельно активироваться на различных потоках.</remarks>
 <param name="source1">Первый наблюдаемый объект.</param>
 <param name="source2">Второй наблюдаемый объект.</param>
 <returns>Наблюдаемый объект, распространяющий сведения из обоих источников.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.ObservableModule">
 <summary>Основные операции над событием первого класса и другими наблюдаемыми объектами.</summary>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncDownloadString(System.Net.WebClient,System.Uri)">
 <summary>Возвращает асинхронное вычисление, которое после запуска ожидает загрузку заданного универсального кода ресурса (URI).</summary>
 <param name="address">Извлекаемый универсальный код ресурса (URI).</param>
 <returns>Асинхронное вычисление, которое будет ожидать загрузки универсального кода ресурса (URI).</returns>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncGetResponse(System.Net.WebRequest)">
 <summary>Возвращает асинхронное вычисление, которое после запуска ожидает ответ на заданный веб-запрос.</summary>
 <returns>Асинхронное вычисление, которое ожидает ответ на веб-запрос <c>WebRequest</c>.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.WebExtensions">
 <summary>Модуль членов расширений, обеспечивающий выполнение асинхронных операций для некоторых основных веб-операций.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AbstractClassAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>AbstractClassAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AbstractClassAttribute">
 <summary>При добавлении этого атрибута в определение класса класс становится абстрактным, т. е. его методы реализовать не нужно. Экземпляры абстрактного класса нельзя создать напрямую.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AllowNullLiteralAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>AllowNullLiteralAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AllowNullLiteralAttribute">
 <summary>При добавлении этого атрибута в класс разрешается использование литерала "null" для этого типа в коде F#. Этот атрибут можно добавить только к определенному классу или типу интерфейса F#.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoOpenAttribute.Path">
 <summary>Указывает пространство имен или модуль для автоматического открытия при указании ссылки на это сборку или открытии пространства имен более высокого уровня.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute.#ctor(System.String)">
 <summary>Создает атрибут, используемый для отметки пути пространства имен или модуля для автоматического открытия при указании ссылки на эту сборку</summary>
 <param name="path">Пространство имен или модуль для автоматического открытия при ссылке на сборку или открытии заключающего модуля.</param>
 <returns>Атрибут AutoOpenAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute.#ctor">
 <summary>Создает атрибут, используемый для отметки модуля для автоматического открытия при открытии вмещающего пространства имен</summary>
 <returns>Атрибут AutoOpenAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AutoOpenAttribute">
 <summary>Этот атрибут используется в двух целях. При применении к сборке ему передается строковый аргумент, который должен определять допустимый модуль или пространство имен в этой сборке. Файлы исходного кода, скомпилированные со ссылкой на эту сборку, обрабатываются в среде, в которой указанный путь открывается автоматически.</summary>

 <remarks>При применении к модулю в сборке для этого атрибута не следует указывать какие-либо параметры. Если пространство имен более высокого уровня открыто в исходном коде пользователя, модуль также неявно открывается.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.AutoSerializableAttribute.Value">
 <summary>Значение атрибута, указывающее, помечается ли тип автоматически как сериализуемый</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoSerializableAttribute.#ctor(System.Boolean)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="value">Указывает, должен ли тип быть сериализуемым по умолчанию.</param>
 <returns>AutoSerializableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AutoSerializableAttribute">
 <summary>При добавлении к типу этого атрибута со значением false данный тип перестает быть сериализуемым по умолчанию в среде F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CLIEventAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>Атрибут CLIEventAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CLIEventAttribute">
 <summary>При добавлении этого атрибута к свойству с типом события свойство компилируется как событие метаданных инфраструктуры CLI с помощью синтаксического преобразования в пару методов add_EventName и remove_EventName.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CLIMutableAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>CLIMutableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CLIMutableAttribute">
 <summary>Добавление этого атрибута в тип записи вызывает его компиляцию в представлении CLI при помощи конструктора по умолчанию и средствами получения и задания свойств.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2.Choice2Of2">
 <summary>Вариант 2 из 2 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2.Choice1Of2">
 <summary>Вариант 1 из 2 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2">
 <summary>Вспомогательные типы для активных шаблонов с 2 вариантами выбора. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice3Of3">
 <summary>Вариант 3 из 3 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice2Of3">
 <summary>Вариант 2 из 3 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice1Of3">
 <summary>Вариант 1 из 3 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3">
 <summary>Вспомогательные типы для активных шаблонов с 3 вариантами выбора. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice4Of4">
 <summary>Вариант 4 из 4 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice3Of4">
 <summary>Вариант 3 из 4 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice2Of4">
 <summary>Вариант 2 из 4 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice1Of4">
 <summary>Вариант 1 из 4 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4">
 <summary>Вспомогательные типы для активных шаблонов с 4 вариантами выбора. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice5Of5">
 <summary>Вариант 5 из 5 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice4Of5">
 <summary>Вариант 4 из 5 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice3Of5">
 <summary>Вариант 3 из 5 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice2Of5">
 <summary>Вариант 2 из 5 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice1Of5">
 <summary>Вариант 1 из 5 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5">
 <summary>Вспомогательные типы для активных шаблонов с 5 вариантами выбора. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice6Of6">
 <summary>Вариант 6 из 6 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice5Of6">
 <summary>Вариант 5 из 6 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice4Of6">
 <summary>Вариант 4 из 6 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice3Of6">
 <summary>Вариант 3 из 6 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice2Of6">
 <summary>Вариант 2 из 6 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice1Of6">
 <summary>Вариант 1 из 6 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6">
 <summary>Вспомогательные типы для активных шаблонов с 6 вариантами выбора. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice7Of7">
 <summary>Вариант 7 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice6Of7">
 <summary>Вариант 6 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice5Of7">
 <summary>Вариант 5 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice4Of7">
 <summary>Вариант 4 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice3Of7">
 <summary>Вариант 3 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice2Of7">
 <summary>Вариант 2 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice1Of7">
 <summary>Вариант 1 из 7 вариантов</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7">
 <summary>Вспомогательные типы для активных шаблонов с 7 вариантами выбора.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>ClassAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
 <summary>Добавление данного атрибута к типу приводит к представлению этого типа посредством класса CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>ComparisonConditionalOnAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute">
 <summary>Данный атрибут используется для обозначения типа универсального контейнера и удовлетворяет ограничению F# comparison только в том случае, если универсальный аргумент также удовлетворяет этому ограничению. Например, добавление этого атрибута к параметру 'T при определении типа C&lt;'T&gt; означает, что тип C&lt;X&gt; поддерживает только сравнение, если тип X также поддерживает сравнение и все остальные условия поддержки сравнения C&lt;X&gt; также соблюдены. Тип C&lt;'T&gt; можно использовать и с другими аргументами типов, но такой тип, как C&lt;(int -&gt; int)&gt;, не будет поддерживать сравнение, поскольку тип (int -&gt; int) представляет собой тип функции F# и не поддерживает сравнение.</summary>

 <remarks>Данный атрибут будет игнорироваться, если он используется с универсальными параметрами функций или методов.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.Counts">
 <summary>Обозначает число аргументов в каждой группе аргументов </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.#ctor(System.Int32[])">
 <summary>Создает экземпляр атрибута</summary>
 <param name="counts">Обозначает число аргументов в каждой группе аргументов.</param>
 <returns>CompilationArgumentCountsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute">
 <summary>Этот атрибут автоматически создается компилятором F# для отметки функций и элементов, принимающих частичное применение некоторых их аргументов и возвращающих функцию более старой версии</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">
 <summary>Указывает номер варианта сущности, если таковой имеется, в линейной последовательности элементов в исходном коде F#</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstructFlags">
 <summary>Обозначает связь скомпилированной сущности и исходного кода F#</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">
 <summary>Указывает номер последовательности сущности, если такой имеется, в линейной последовательности элементов в исходном коде F#</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32,System.Int32)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="sourceConstructFlags">Обозначает тип элемента исходной конструкции.</param>
 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="sourceConstructFlags">Обозначает тип элемента исходной конструкции.</param>
 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="sourceConstructFlags">Обозначает тип элемента исходной конструкции.</param>
 <returns>CompilationMappingAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
 <summary>Этот атрибут автоматически создается компилятором F# для отметки функций и методов в созданном коде CLI с флажками, указывающими на соответствие исходным конструкциям. Он используется функциями в пространстве имен Microsoft.FSharp.Reflection для конструкций, скомпилированных с обратным сопоставлением в первоначальную форму. Он не предназначен для прямого использования в пользовательском коде.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">
 <summary>Обозначает одно или несколько изменений скомпилированного представления типа или члена F#</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute.#ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="flags">Обозначает изменения скомпилированного представления типа или члена.</param>
 <returns>Атрибут CompilationRepresentationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
 <summary>Этот атрибут используется для настройки представления типа в среде выполнения. Например, его можно применять для обозначения того, что для типа может использоваться представление значения <c>null</c>. Это влияет на способ компиляции некоторых конструкций.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.Event">
 <summary>Компиляция свойства как событие CLI.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.UseNullAsTrueValue">
 <summary>Разрешает использование значения <c>null</c> в качестве представления нульарных дискриминаторов в размеченном объединении.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix">
 <summary>Добавление значения Module в конец модуля, имя которого конфликтует с именем типа в том же пространстве имен.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.Instance">
 <summary>Компиляция элемента в качестве экземпляра, даже если значение <c>null</c> используется как представление для данного типа.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.Static">
 <summary>Компиляция элемента экземпляра в виде статического объекта.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.None">
 <summary>Без специального представления компиляции.</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">
 <summary>Обозначает одно или несколько изменений скомпилированного представления типа или члена F#.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationSourceNameAttribute.SourceName">
 <summary>Указывает имя сущности в исходном коде F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationSourceNameAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="sourceName">Имя метода в исходном коде.</param>
 <returns>Атрибут CompilationSourceNameAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationSourceNameAttribute">
 <summary>Этот атрибут автоматически создается компилятором F# для отметки методов с атрибутом CompiledName. Он не предназначен для прямого использования в пользовательском коде.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompiledNameAttribute.CompiledName">
 <summary>Имя значения в том виде, в котором оно отображается в скомпилированном коде</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompiledNameAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="compiledName">Имя, предназначенное для использования в скомпилированном коде.</param>
 <returns>CompiledNameAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompiledNameAttribute">
 <summary>При добавлении этого атрибута в значение или определении функции в модуле F# изменяется имя значения в скомпилированном коде CLI.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsHidden(System.Boolean)">
 <summary>Указывает, что конструкция всегда должна быть скрытой в среде редактирования.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsError(System.Boolean)">
 <summary>Указывает, что в сообщении не должна указываться  ошибка компилятора. Номера ошибок меньше 10000 резервируются для будущего использования компилятором и библиотеками F#.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.MessageNumber">
 <summary>Указывает номер, связанный с сообщением.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.Message">
 <summary>Указывает предупреждающее сообщение, которое создается при использовании этой конструкции в исходном коде F#</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsHidden">
 <summary>Указывает, что конструкция всегда должна быть скрытой в среде редактирования.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsError">
 <summary>Указывает, что в сообщении не должна указываться  ошибка компилятора. Номера ошибок меньше 10000 резервируются для будущего использования компилятором и библиотеками F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerMessageAttribute.#ctor(System.String,System.Int32)">
 <summary>Создает экземпляр атрибута.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerMessageAttribute">
 <summary>Обозначает, что следует создать предупреждающее сообщение при использовании этой конструкции в исходном коде F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomComparisonAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>CustomComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomComparisonAttribute">
 <summary>Добавление этого атрибута к типу обозначает, что это тип с пользовательской реализацией сравнения.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomEqualityAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>CustomEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomEqualityAttribute">
 <summary>Добавление этого атрибута к типу обозначает, что это тип с пользовательской реализацией равенства.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpaceUsingBind(System.Boolean)">
 <summary>Указывает, сохраняет ли пользовательская операция пространство переменных запроса вычислительного выражения в процессе использования операции привязки</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpace(System.Boolean)">
 <summary>Указывает, сохраняет ли пользовательская операция пространство переменных запроса вычислительного выражения</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.JoinConditionWord(System.String)">
 <summary>Указывает имя, используемое для части "on" оператора пользовательского запроса для операторов соединения</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeZip(System.Boolean)">
 <summary>Указывает, является ли пользовательская операция операцией, схожей с архивированием, в вычислении последовательностей с поддержкой двух вводов</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeJoin(System.Boolean)">
 <summary>Указывает, является ли пользовательская операция операцией, схожей с присоединением, в вычислении последовательностей с поддержкой двух вводов и ограничения корреляции</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeGroupJoin(System.Boolean)">
 <summary>Указывает, является ли пользовательская операция операцией, схожей с присоединением группы, в вычислении последовательностей с поддержкой двух вводов, ограничения корреляции и создания группы</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.AllowIntoPattern(System.Boolean)">
 <summary>Указывает, поддерживает ли пользовательская операция использование предлога into сразу после использования операции в запросе или другом вычислительном выражении с целью использования результатов операции</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.Name">
 <summary>Получение имени пользовательской операции при использовании в запросе или другом вычислительном выражении</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpaceUsingBind">
 <summary>Указывает, сохраняет ли пользовательская операция пространство переменных запроса вычислительного выражения в процессе использования операции привязки</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpace">
 <summary>Указывает, сохраняет ли пользовательская операция пространство переменных запроса вычислительного выражения</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.JoinConditionWord">
 <summary>Указывает имя, используемое для части "on" оператора пользовательского запроса для операторов соединения</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeZip">
 <summary>Указывает, является ли пользовательская операция операцией, схожей с архивированием, в вычислении последовательностей с поддержкой двух вводов</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeJoin">
 <summary>Указывает, является ли пользовательская операция операцией, схожей с присоединением, в вычислении последовательностей с поддержкой двух вводов и ограничения корреляции</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeGroupJoin">
 <summary>Указывает, является ли пользовательская операция операцией, схожей с присоединением группы, в вычислении последовательностей с поддержкой двух вводов, ограничения корреляции и создания группы</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.AllowIntoPattern">
 <summary>Указывает, поддерживает ли пользовательская операция использование предлога into сразу после использования операции в запросе или другом вычислительном выражении с целью использования результатов операции</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomOperationAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <returns>CustomOperationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomOperationAttribute">
<summary>
 Указывает, что элемент типа построителя вычислений является оператором пользовательского запроса, и указывает имя этого оператора
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.Value">
 <summary>Значение атрибута, указывающее, имеет ли тип приращение по умолчанию.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute.#ctor(System.Boolean)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="value">Указывает, нужно ли создать вспомогательные методы в классе CLI, представляющие размеченное объединение.</param>
 <returns>DefaultAugmentationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
 <summary>При добавлении этого атрибута в размеченное объединение со значением false отключается создание стандартного тестировщика вспомогательного метода, конструктора и методов доступа для созданного класса CLI данного типа.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultValueAttribute.Check">
 <summary>Указывает, что в случае применения ограничения тип поля поддерживает значение NULL.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute.#ctor(System.Boolean)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="check">Указывает, нужно ли подтвердить, что тип поля поддерживает значение <c>null</c>.</param>
 <returns>DefaultValueAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>DefaultValueAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultValueAttribute">
 <summary>При добавлении этого атрибута в объявление поля оно не инициализируется. Во время проверки типов применяется ограничение: тип поля поддерживает значение NULL. Если значение check равно false, то ограничение не используется. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.EntryPointAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>EntryPointAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.EntryPointAttribute">
 <summary>Добавление этого атрибута к функции обозначает, что это точка входа для приложения. Если этот атрибут не задан для EXE, в качестве точки входа используется явная функция инициализации в привязках модуля последнего файла последовательности компиляции.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.EqualityConditionalOnAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>EqualityConditionalOnAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.EqualityConditionalOnAttribute">
 <summary>Данный атрибут используется для обозначения типа универсального контейнера и удовлетворяет ограничению F# equality только в том случае, если универсальный аргумент также удовлетворяет этому ограничению. Например, добавление этого атрибута к параметру 'T при определении типа C&lt;'T&gt; означает, что тип C&lt;X&gt; поддерживает только равенство, если тип X также поддерживает равенство и все остальные условия поддержки равенства C&lt;X&gt; также соблюдены. Тип C&lt;'T&gt; можно использовать и с другими аргументами типов, но такой тип, как C&lt;(int -&gt; int)&gt;, не будет поддерживать равенство, поскольку тип (int -&gt; int) представляет собой тип функции F# и не поддерживает равенство.</summary>

 <remarks>Данный атрибут будет игнорироваться, если он используется с универсальными параметрами функций или методов.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">
 <summary>Указывает предупреждающее сообщение, которое создается при использовании этой конструкции в исходном коде F#</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="message">Предупреждающее сообщение, которое создается при использовании этой конструкции в коде.</param>
 <returns>ExperimentalAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
 <summary>Этот атрибут используется для отметки значений, являющихся частью экспериментальной библиотеки.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(System.Converter{`0,`1})">
 <summary>Преобразование значения типа <c>System.Converter</c> в значение функции первого класса в языке F# </summary>
 <param name="converter">Входной System.Converter.</param>
 <returns>Функция F# того же типа.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(Microsoft.FSharp.Core.FSharpFunc{`0,`1})">
 <summary>Преобразование значения функции первого класса в языке F# в значение типа <c>System.Converter</c></summary>
 <param name="func">Входная функция.</param>
 <returns>Значение A System.Converter типа функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.ToConverter(Microsoft.FSharp.Core.FSharpFunc{`0,`1})">
 <summary>Преобразование значения функции первого класса в языке F# в значение типа <c>System.Converter</c></summary>
 <param name="func">Входная функция.</param>
 <returns>System.Converter&lt;'T,'U&gt;</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}},`0,`1)">
 <summary>Вызов значения функции первого класса F# с двумя каррированными аргументами. В некоторых случаях это приведет к более эффективной работе приложения, чем при последовательной обработке аргументов.</summary>
 <param name="func">Входная функция.</param>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},`0,`1,``0)">
 <summary>Вызов значения функции первого класса F# с тремя каррированными аргументами. В некоторых случаях это приведет к более эффективной работе приложения, чем при последовательной обработке аргументов.</summary>
 <param name="func">Входная функция.</param>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}}},`0,`1,``0,``1)">
 <summary>Вызывает значение функции первого класса F# с четырьмя каррированными аргументами. В некоторых случаях это приведет к более эффективной работе приложения, чем при последовательной обработке аргументов.</summary>
 <param name="func">Входная функция.</param>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <param name="arg4">Четвертый аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``4(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}}}},`0,`1,``0,``1,``2)">
 <summary>Вызов значения функции первого класса F# с пятью каррированными аргументами. В некоторых случаях это приведет к более эффективной работе приложения, чем при последовательной обработке аргументов.</summary>
 <param name="func">Входная функция.</param>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <param name="arg4">Четвертый аргумент.</param>
 <param name="arg5">Пятый аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.Invoke(`0)">
 <summary>Вызов значения функции первого класса F# с одним аргументом</summary>
 <param name="func"></param>
 <returns>'U</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.FromConverter(System.Converter{`0,`1})">
 <summary>Преобразование значения типа <c>System.Converter</c> в значение функции первого класса в языке F# </summary>
 <param name="converter">Входной System.Converter.</param>
 <returns>Функция F# того же типа.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.#ctor">
 <summary>Сконструировать экземпляр значения функции первого класса F# </summary>
 <returns>Созданная функция F#.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpFunc`2">
 <summary>Тип CLI, используемый для представления значений функции F#. Этот тип обычно не должен использоваться напрямую, хотя его можно использовать в других языках CLI.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Release">
 <summary>Номер выпуска версии F#, связанного с этим атрибутом</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Minor">
 <summary>Дополнительный номер версии F#, связанной с этим атрибутом</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Major">
 <summary>Основной номер версии F#, связанной с этим атрибутом</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.#ctor(System.Int32,System.Int32,System.Int32)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="major">Основной номер версии.</param>
 <param name="minor">Дополнительный номер версии.</param>
 <param name="release">Номер выпуска.</param>
 <returns>FSharpInterfaceDataVersionAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
 <summary>Этот атрибут добавляется к созданным сборкам, чтобы указать версию схемы данных, которая используется для кодировки дополнительных сведений F# в ресурсе, прикрепленному к скомпилированным библиотекам F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.Specialize``1">
 <summary>Специализация функции указанного типа</summary>
 <returns>Специализированный тип.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.#ctor">
 <summary>Сконструировать экземпляр значение функции первого класса F# </summary>
 <returns>FSharpTypeFunc</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpTypeFunc">
 <summary>Тип CLI, используемый для представления значений функции первого класса F#. Этот тип предназначен для использования скомпилированным кодом F#.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Format`4">
 <summary>Тип выражения форматирования.</summary>
 <typeparam name="Printer">Тип функции, создаваемый printf.</typeparam>
 <typeparam name="State">Аргумент типа, переданный средствам форматирования %a</typeparam>
 <typeparam name="Residue">Значение, созданное общим действием printf (например, sprint создает строку)</typeparam>
 <typeparam name="Result">Значение, созданное после пост-обработки (например, failwithf создает строку внутри объекта, а затем создает исключение)</typeparam>
</member>
<member name="T:Microsoft.FSharp.Core.Format`5">
 <summary>Тип выражения форматирования.</summary>
 <typeparam name="Printer">Тип функции, создаваемый printf.</typeparam>
 <typeparam name="State">Аргумент типа, переданный средствам форматирования %a</typeparam>
 <typeparam name="Residue">Значение, созданное общим действием printf (например, sprint создает строку)</typeparam>
 <typeparam name="Result">Значение, созданное после пост-обработки (например, failwithf создает строку внутри объекта, а затем создает исключение)</typeparam>
 <typeparam name="Tuple">Кортеж значений, созданных в процессе сканирования или сопоставления</typeparam>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``2(System.Converter{``0,``1})">
 <summary>Преобразует заданный объект делегата преобразователя в значение функции F#</summary>
 <param name="converter">Входной преобразователь.</param>
 <returns>Функция F#.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``1(System.Action{``0})">
 <summary>Преобразует заданный объект делегата действия в значение функции F#</summary>
 <param name="action">Входное действие.</param>
 <returns>Функция F#.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,``3,``4},``5})">
 <summary>Служебная функция, которая используется для преобразования кортежных значений функции в каррированные</summary>
 <param name="func">Входная кортежная функция.</param>
 <returns>Выходная каррированная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,``3},``4})">
 <summary>Служебная функция, которая используется для преобразования кортежных значений функции в каррированные</summary>
 <param name="func">Входная кортежная функция.</param>
 <returns>Выходная каррированная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2},``3})">
 <summary>Служебная функция, которая используется для преобразования кортежных значений функции в каррированные</summary>
 <param name="func">Входная кортежная функция.</param>
 <returns>Выходная каррированная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2})">
 <summary>Служебная функция, которая используется для преобразования кортежных значений функции в каррированные</summary>
 <param name="func">Входная кортежная функция.</param>
 <returns>Выходная каррированная функция.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">
 <summary>Вспомогательные функции для преобразования значений функций первого класса F# в представления функций CLI с использованием делегатов и обратно.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.GeneralizableValueAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>GeneralizableValueAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.GeneralizableValueAttribute">
 <summary>При добавлении этого атрибута к нефункциональному значению с универсальными параметрами обозначает, что при использовании данной конструкции может применяться универсальный код с помощью определения типа. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>InterfaceAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
 <summary>Добавление данного атрибута к типу приводит к представлению этого типа посредством интерфейса CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LiteralAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>LiteralAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.LiteralAttribute">
 <summary>Добавление данного атрибута к значению приводит к тому, что оно компилируется как постоянный литерал CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>MeasureAnnotatedAbbreviationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute">
 <summary>Добавление данного атрибута к типу приводит к тому, что этот тип интерпретируется как уточненный, что в настоящее время ограничивается параметризованными типами измерений. Использование допустимо только при очень ограниченных условиях.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>MeasureAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAttribute">
 <summary>Добавление данного атрибута к типу приводит к тому, что он интерпретируется как единица измерения. Использование допустимо только при очень ограниченных условиях.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoComparisonAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>Атрибут NoComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoComparisonAttribute">
 <summary>Добавление этого атрибута к типу обозначает, что операция сравнения применительно к данному типу не является нормальной. Это значит, что данный тип не удовлетворяет ограничению F# comparison. В пределах системы типов F# это помогает избегать создания экземпляров функции универсального сравнения F# непосредственно в этом типе.  Данный атрибут и проверка не ограничивают использование сравнения с базовым типом или его дочерними типами.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoDynamicInvocationAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>NoDynamicInvocationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoDynamicInvocationAttribute">
 <summary>Этот атрибут используется для отметки значений, которые нельзя вызывать динамически во время выполнения. Он обычно добавляется ко встроенным функциям, в реализации которых есть непроверяемый код. Из-за этого тело метода встроенной функции вызывает исключение, если вместо включения непроверяемого кода в созданную сборку динамически вызывается эта функция.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoEqualityAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>NoEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoEqualityAttribute">
 <summary>Добавление этого атрибута к типу обозначает, что операция равенства применительно к данному типу не является нормальной. Это значит, что данный тип не удовлетворяет ограничению F# equality. В пределах системы типов F# это помогает избегать создания экземпляров универсальной функции равенства F# непосредственно в этом типе. Данный атрибут и проверка не ограничивают использование сравнения с базовым типом или его дочерними типами.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1.Some">
 <summary>Представление выражения "Значение типа T"</summary>
 <param name="Value">Входное значение.</param>
 <returns>Параметр, представляющий значение.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1.None">
 <summary>Представление выражения "Нет значения"</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.Value">
 <summary>Получает значение параметра Some. В случае параметра None вызывается исключение NullReferenceException.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.None">
 <summary>Создает значение параметра, которое представляет собой значение None.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsSome">
 <summary>Возвращает значение true, если параметр является значением типа Some.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsNone">
 <summary>Возвращает значение true, если параметр является значением типа None.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpOption`1.Some(`0)">
 <summary>Создает значение параметра, которое представляет собой значение Some.</summary>
 <param name="value">Входное значение.</param>
 <returns>Параметр, представляющий значение.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1">
 <summary>Тип необязательных значений. При использовании из других языков CLI пустой вариант — это значение <c>null</c>. </summary>

 <remarks>Используйте конструкторы <c>Some</c> и <c>None</c> для создания значений этого типа. Значения в модуле <c>Option</c> можно использовать для управления значениями данного типа или сопоставления шаблона со значениями напрямую. Значения <c>None</c> отображаются как значение <c>null</c> в других языках CLI. Методы экземпляров в данном типе будут отображаться для других языков CLI как статические методы из-за использования значения <c>null</c> в качестве представления значения.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>OptionalArgumentAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
 <summary>Данный атрибут автоматически добавляется ко всем необязательным аргументам.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.PrintfFormat`4.Value">
 <summary>Необработанный текст строки форматирования.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`4.#ctor(System.String)">
 <summary>Создает строку формата </summary>
 <param name="value">Входная строка.</param>
 <returns>Объект PrintfFormat, содержащий отформатированный результат.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`4">
 <summary>Тип выражения форматирования.</summary>
 <typeparam name="Printer">Тип функции, создаваемый printf.</typeparam>
 <typeparam name="State">Аргумент типа, переданный средствам форматирования %a</typeparam>
 <typeparam name="Residue">Значение, созданное общим действием printf (например, sprint создает строку)</typeparam>
 <typeparam name="Result">Значение, созданное после пост-обработки (например, failwithf создает строку внутри объекта, а затем создает исключение)</typeparam>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`5.#ctor(System.String)">
 <summary>Создает строку формата</summary>
 <param name="value">Входная строка.</param>
 <returns>Созданная строка формата.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`5">
 <summary>Тип выражения форматирования.</summary>
 <typeparam name="Printer">Тип функции, создаваемый printf.</typeparam>
 <typeparam name="State">Аргумент типа, переданный средствам форматирования %a</typeparam>
 <typeparam name="Residue">Значение, созданное общим действием printf (например, sprint создает строку)</typeparam>
 <typeparam name="Result">Значение, созданное после пост-обработки (например, failwithf создает строку внутри объекта, а затем создает исключение)</typeparam>
 <typeparam name="Tuple">Кортеж значений, созданных в процессе сканирования или сопоставления</typeparam>
</member>
<member name="M:Microsoft.FSharp.Core.ProjectionParameterAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>ProjectionParameterAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ProjectionParameterAttribute">
 <summary>Указывает, что при использовании пользовательского оператора в выражение вычисления параметр автоматически параметризован областью переменных вычислительного выражения</summary>
</member>
<member name="F:Microsoft.FSharp.Core.Microsoft.FSharp.Core.FSharpRef`1.contents">
<summary>
 Текущее значение ссылочной ячейки
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value(`0)">
 <summary>Текущее значение ссылочной ячейки</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value">
 <summary>Текущее значение ссылочной ячейки</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpRef`1">
 <summary>Тип изменяемых ссылок. Используйте функции [:=] и [!], чтобы получить и задать значения этого типа.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>ReferenceEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ReferenceEqualityAttribute">
 <summary>При добавлении этого атрибута в запись или объединение отключается автоматическое создание перегруженных вариантов System.Object.Equals(obj), System.Object.GetHashCode() и System.IComparable для данного типа. По умолчанию тип будет использовать ссылочное равенство.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>ReflectedDefinitionAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
 <summary>Добавление этого атрибута в привязку let для определения значения верхнего уровня делает выражение в кавычках, реализующее значение, доступным для использования в среде выполнения.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>Атрибут RequireQualifiedAccessAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute">
 <summary>Этот атрибут используется для обозначения того, что для ссылок на элементы модуля, записи или объединения нужен явный метод доступа.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>RequiresExplicitTypeArgumentsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute">
 <summary>При добавлении этого атрибута к типу, значению или члену, который использует данную конструкцию, необходимо явно создавать экземпляр параметров универсального типа.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SealedAttribute.Value">
 <summary>Значение атрибута, указывающее, запечатан ли тип.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute.#ctor(System.Boolean)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="value">Указывает, запечатан ли класс.</param>
 <returns>SealedAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute.#ctor">
 <summary>Создает экземпляр атрибута.</summary>
 <returns>Созданный атрибут.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.SealedAttribute">
 <summary>При добавлении этого атрибута в определение класса он становится запечатанным, т. е. его нельзя расширять или реализовывать.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.NonPublicRepresentation">
 <summary>Указывает наличие у скомпилированной сущности закрытого или внутреннего представления в исходном коде F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.KindMask">
 <summary>Маска значений, относящаяся к виду скомпилированной сущности.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Value">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления значения на языке F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.UnionCase">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления варианта объединения F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Module">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления модуля F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Closure">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления закрытия F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Exception">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления исключения F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Field">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления поля записи или ветви объединения F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.ObjectType">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления типа класса или другого объекта F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.RecordType">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления типа записи F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.SumType">
 <summary>Указывает, что скомпилированная сущность является частью представления объявления типа объединения F#.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.None">
 <summary>Указывает на отсутствие связи скомпилированной сущности и элемента в исходном коде F#.</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.SourceConstructFlags">
 <summary>Указывает связь скомпилированной сущности в двоичном файле CLI и элемента в исходном коде F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>StructAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
 <summary>Добавление данного атрибута к типу приводит к представлению этого типа посредством структуры CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>StructuralComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralComparisonAttribute">
 <summary>При добавлении этого атрибута в запись, объединение, исключение или структуру подтверждается автоматическое создание реализаций System.IComparable для данного типа.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>Атрибут StructuralEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralEqualityAttribute">
 <summary>При добавлении этого атрибута в тип записи, объединения или структуры подтверждается автоматическое создание перегруженных вариантов System.Object.Equals(obj) и System.Object.GetHashCode() для данного типа. </summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.Value">
 <summary>Обозначает текст, отображаемый по умолчанию, когда объекты данного типа отображаются с помощью шаблонов форматирования %A printf и других двухмерных текстовых форматов вывода значений. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <param name="value">Указывает текст для отображения при использовании форматирования %A printf.</param>
 <returns>Атрибут StructuredFormatDisplayAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute">
 <summary>Данный атрибут применяется для отметки способа отображения типа по умолчанию при использовании шаблонов форматирования %A printf и других двухмерных текстовых форматов вывода значений. В данной версии F# допустимы только значения в форме <c>PreText {PropertyName} PostText</c>. Имя свойства обозначает свойство, подлежащее вычислению и отображению вместо самого объекта. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
 <summary>Тип unit, для которого предусмотрено только одно значение — "()". Это значение является особым и всегда использует представление значения NULL.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>Атрибут UnverifiableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
 <summary>Этот атрибут используется для отметки значений, использование которых может привести к созданию непроверяемого кода. Эти значения неизбежно снабжаются пометкой inline, чтобы гарантировать отсутствие непроверяемых конструкций в фактическом коде библиотеки F# и их копирование в исходный код вызывающего объекта.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.VolatileFieldAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>Атрибут VolatileFieldAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.VolatileFieldAttribute">
 <summary>Добавление этого атрибута к изменяемой привязке F# приводит к применению префикса volatile ко всем случаям доступа к полю.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
 <summary>Четырехмерные массивы, индексация которых, как правило, ведется с нуля. Массивы, индексация которых начинается не с нуля, могут создаваться с помощью методов типа System.Array.</summary>

 <remarks>Значения в модуле <c>Array4D</c> можно использовать для обработки значений этого типа. Нотацию <c>arr.[x1,x2,x3,x4]</c> можно использовать для получения и задания значений массива.</remarks>  
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
 <summary>Трехмерные массивы, индексация которых, как правило, ведется с нуля. Массивы, индексация которых начинается не с нуля, могут создаваться с помощью методов типа System.Array.</summary>

 <remarks>Значения в модуле <c>Array3D</c> можно использовать для обработки значений этого типа. Нотацию <c>arr.[x1,x2,x3]</c> можно использовать для получения и задания значений массива.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
 <summary>Двумерные массивы, индексация которых, как правило, ведется с нуля.</summary> 

 <remarks>Значения в модуле <c>Array2D</c> можно использовать для обработки значений этого типа. Нотацию <c>arr.[x,y]</c> можно использовать для получения и задания значений массива. Массивы, индексация которых начинается не с нуля, могут также создаваться с помощью методов типа System.Array.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
 <summary>Одномерные массивы с индексацией от нуля, которые описываются с помощью <c>int[]</c>, <c>string[]</c> и т. п.</summary>
 <remarks>Значения в модуле <c>Array</c> можно использовать для обработки значений этого типа. Нотацию <c>arr.[x]</c> можно использовать для получения и задания значений массива.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">
 <summary>Одномерные массивы с индексацией от нуля, которые описываются с помощью <c>int[]</c>, <c>string[]</c> и т. п.</summary>
 
 <remarks>Значения в модуле <c>Array</c> можно использовать для обработки значений этого типа. Нотацию <c>arr.[x]</c> можно использовать для получения и задания значений массива.</remarks>   
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.bool">
 <summary>Сокращение типа CLI <c>System.Boolean</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
 <summary>Представляет управляемый указатель в коде F#.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byte">
 <summary>Сокращение типа CLI <c>System.Byte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.char">
 <summary>Сокращение типа CLI <c>System.Char</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal">
 <summary>Сокращение типа CLI <c>System.Decimal</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal`1">
 <summary>Тип десятичных чисел, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.Decimal</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.double">
 <summary>Сокращение типа CLI <c>System.Double</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.exn">
 <summary>Сокращение типа CLI <c>System.Exception</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float">
 <summary>Сокращение типа CLI <c>System.Double</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32">
 <summary>Сокращение типа CLI <c>System.Single</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32`1">
 <summary>Тип чисел с плавающей точкой, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.Single</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float`1">
 <summary>Тип чисел с плавающей точкой, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.Double</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
 <summary>Этот тип предназначен для внутреннего использования компилятором кода F#.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int">
 <summary>Сокращение типа CLI <c>System.Int32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16">
 <summary>Сокращение типа CLI <c>System.Int16</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16`1">
 <summary>Тип 16-разрядных целых чисел со знаком, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.Int16</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int32">
 <summary>Сокращение типа CLI <c>System.Int32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64">
 <summary>Сокращение типа CLI <c>System.Int64</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64`1">
 <summary>Тип 64-разрядных целых чисел со знаком, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.Int64</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int8">
 <summary>Сокращение типа CLI <c>System.SByte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int`1">
 <summary>Тип 32-разрядных целых чисел со знаком, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.Int32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint">
 <summary>Сокращение типа CLI <c>System.IntPtr</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
 <summary>Представляет неуправляемый указатель в коде F#.</summary>

 <remarks>Этот тип следует использовать, только при написании кода F#, который взаимодействует с машинным кодом. Использование этого типа в коде F# может привести к созданию непроверяемого кода. Может потребоваться преобразование в тип <c>nativeint</c> и наоборот. Значения этого типа можно создавать с помощью функций в модуле <c>NativeInterop.NativePtr</c>.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.obj">
 <summary>Сокращение типа CLI <c>System.Object</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.option`1">
 <summary>Тип необязательных значений. При использовании из других языков CLI пустой вариант — это значение <c>null</c>. </summary>

 <remarks>Используйте конструкторы <c>Some</c> и <c>None</c> для создания значений этого типа. Значения в модуле <c>Option</c> можно использовать для управления значениями данного типа или сопоставления шаблона со значениями напрямую. Значения None отображаются как значение <c>null</c> в других языках CLI. Методы экземпляров в данном типе будут отображаться для других языков CLI как статические методы из-за использования значения <c>null</c> в качестве представления значения.</remarks>
</member>
<member name="T:Microsoft.FSharp.Core.ref`1">
 <summary>Тип изменяемых ссылок. Используйте функции [:=] и [!], чтобы получить и задать значения этого типа.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">
 <summary>Сокращение типа CLI <c>System.SByte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte`1">
 <summary>Тип 8-разрядных целых чисел со знаком, для которых указана единица измерения. Единица измерения удаляется из скомпилированного кода и при анализе значений данного типа с использованием отражения. По представлению данный тип эквивалентен типу <c>System.SByte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.single">
 <summary>Сокращение типа CLI <c>System.Single</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.string">
 <summary>Сокращение типа CLI <c>System.String</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint16">
 <summary>Сокращение типа CLI <c>System.UInt16</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint32">
 <summary>Сокращение типа CLI <c>System.UInt32</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint64">
 <summary>Сокращение типа CLI <c>System.UInt64</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint8">
 <summary>Сокращение типа CLI <c>System.Byte</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unativeint">
 <summary>Сокращение типа CLI <c>System.UIntPtr</c>.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unit">
 <summary>Тип unit, для которого предусмотрено только одно значение — "()". Это значение является особым и всегда использует представление значения NULL.</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
 <summary>Ошибки неисчерпывающего совпадения вызывают исключение MatchFailureException</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.LastGenerated">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.CheckClose">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GetFreshEnumerator">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>

 <returns>Новый перечислитель последовательности.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GenerateNext(System.Collections.Generic.IEnumerable{`0}@)">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>

 <param name="result">Ссылка на последовательность.</param>

 <returns>0, 1 и 2 обозначают условия Stop, Yield и Goto генератора последовательности соответственно.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.Close">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.#ctor">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>

 <returns>Новый генератор последовательностей для данного выражения.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1">
 <summary>Компилятор F# создает реализации этого типа для скомпилированных выражений последовательностей.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.NamespaceName">
<summary>
 Имя пространства имен, в котором поставщик размещает типы.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.ResolveTypeName(System.String)">
 <summary>
 Компиляторы вызывают этот метод для запроса <c>имени</c> типа у поставщика типов.
 </summary>
 <remarks>Распознаватель должен возвращать тип с именем <c>name</c> в пространстве имен <c>NamespaceName</c> или значение <c>null</c>, если тип неизвестен.
 </remarks>
 <returns></returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.GetTypes">
 <summary>
 Типы верхнего уровня
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.GetNestedNamespaces">
<summary>
 Подпространства имен в этом пространстве имен. Необязательный элемент для предотвращения создания пространства имен до изучения внешнего пространства имен.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.remove_Invalidate(System.EventHandler)">
 <summary>
 Инициируется при изменении допущения, делающего недействительными разрешения, которые на данный момент были предоставлены поставщиком
 </summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.Invalidate">
 <summary>
 Инициируется при изменении допущения, делающего недействительными разрешения, которые на данный момент были предоставлены поставщиком
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.add_Invalidate(System.EventHandler)">
 <summary>
 Инициируется при изменении допущения, делающего недействительными разрешения, которые на данный момент были предоставлены поставщиком
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetStaticParameters(System.Type)">
 <summary>
 Получение статических параметров для предоставленного типа. 
 </summary>
 <param name="typeWithoutArguments">Тип, возвращаемый GetTypes или ResolveTypeName</param>
 <returns></returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetNamespaces">
 <summary>
 Имя пространства имен, в котором данный поставщик TypeProvider размещает типы.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetInvokerExpression(System.Reflection.MethodBase,Microsoft.FSharp.Quotations.FSharpExpr[])">
 <summary>
 Вызывается компилятором, чтобы запросить замену заданной базы MethodBase деревом Expression.
 </summary>
 <param name="syntheticMethodBase">MethodBase, заданный для компилятора типом, возвращаемым вызовом GetType(s).</param>
 <param name="parameters">Выражения, представляющие параметры для этого вызова.</param>
 <returns>Выражение, которое компилятор будет использовать вместо заданной базы метода.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetGeneratedAssemblyContents(System.Reflection.Assembly)">
 <summary>
 Получение физического содержимого данной сборки, предоставленной логически.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.ApplyStaticArguments(System.Type,System.String[],System.Object[])">
 <summary>
 Применение статических аргументов к предоставленному типу, принимающему статические аргументы. 
 </summary>
 <remarks>Поставщик должен вернуть тип с заданным искаженным именем.</remarks>
 <param name="typeWithoutArguments">определение предоставленного типа со статическими параметрами</param>
 <param name="typePathWithArguments">полное имя типа, включая закодированное представление статических параметров</param>
 <param name="staticArguments">статические параметры, индексированные по имени</param>
 <returns></returns>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MeasureInverse`1">
 <summary>Представляет обратное значение выражений измерения при возврате в виде базового аргумента предоставленного типа.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MeasureOne">
 <summary>представляет выражение измерения "1" при возврате в виде базового аргумента предоставленного типа.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MeasureProduct`2">
 <summary>Представляет произведение двух выражений измерения при возврате в виде базового аргумента предоставленного типа.</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <returns>TypeProviderAssemblyAttribute</returns>
 <param name="assemblyName">Имя сборки времени разработки для данного поставщика типов.</param>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>TypeProviderAssemblyAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute">
 <summary>Поместите атрибут в сборку времени выполнения, чтобы указать, что имеется соответствующая сборка времени разработки, содержащая поставщик типов. Сборки времени выполнения и конструктора могут совпадать. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>TypeProviderAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderAttribute">
 <summary>Поместите в класс, реализующий ITypeProvider для расширения компилятора</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.TemporaryFolder(System.String)">
<summary>
 Получите полный путь для использования с временными файлами для экземпляра поставщика типов.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.SystemRuntimeAssemblyVersion(System.Version)">
<summary>
 версия сборки времени выполнения системы, на которую имеется ссылка
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.RuntimeAssembly(System.String)">
<summary>
 Получите полный путь к сборке, вызвавшей создание данного экземпляра поставщика типов, на которую имеется ссылка.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ResolutionFolder(System.String)">
<summary>
 Получите полный путь, используемый для разрешения относительных путей в любых аргументах имени файла, предоставленных экземпляру поставщика типов.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ReferencedAssemblies(System.String[])">
<summary>
 Получите сборки для экземпляра поставщика типов, на которые имеются ссылки.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsInvalidationSupported(System.Boolean)">
<summary>
 Указывает, отвечает ли узел поставщика типов на события аннулирования экземпляров поставщика типов. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsHostedExecution(System.Boolean)">
<summary>
 Указывает, используется ли экземпляр поставщика типов в среде, выполняющей предоставленный код, например F#Interactive.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.TemporaryFolder">
<summary>
 Получите полный путь для использования с временными файлами для экземпляра поставщика типов.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.SystemRuntimeAssemblyVersion">
<summary>
 версия сборки времени выполнения системы, на которую имеется ссылка
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.RuntimeAssembly">
<summary>
 Получите полный путь к сборке, вызвавшей создание данного экземпляра поставщика типов, на которую имеется ссылка.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ResolutionFolder">
<summary>
 Получите полный путь, используемый для разрешения относительных путей в любых аргументах имени файла, предоставленных экземпляру поставщика типов.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ReferencedAssemblies">
<summary>
 Получите сборки для экземпляра поставщика типов, на которые имеются ссылки.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsInvalidationSupported">
<summary>
 Указывает, отвечает ли узел поставщика типов на события аннулирования экземпляров поставщика типов. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsHostedExecution">
<summary>
 Указывает, используется ли экземпляр поставщика типов в среде, выполняющей предоставленный код, например F#Interactive.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.SystemRuntimeContainsType(System.String)">
<summary>
 Проверяет, существует ли заданный тип в библиотеке времени выполнения целевой системы
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig">
<summary>
 Если класс, который реализует ITypeProvider, имеет конструктор, принимающий TypeProviderConfig, он будет создан с экземпляром TypeProviderConfig.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderEditorHideMethodsAttribute.#ctor">
 <summary>Создает экземпляр атрибута</summary>
 <returns>TypeProviderEditorHideMethodsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderEditorHideMethodsAttribute">
 <summary>Указывает, что редактору кода следует скрыть все методы System.Object из меню IntelliSense для экземпляров предоставленного типа</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderTypeAttributes">
 <summary>Флаги атрибутов дополнительных типов, связанных с предоставленными типами</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderXmlDocAttribute.#ctor(System.String)">
 <summary>Создает экземпляр атрибута</summary>
 <returns>TypeProviderXmlDocAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderXmlDocAttribute">
<summary>
 Атрибут TypeProviderXmlDocAttribute можно добавить к типам и элементам. Служба языка отобразит свойство CommentText из атрибута в нужном месте при наведении указателя мыши пользователем на тип или элемент.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.CreateEvent``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``0})">
 <summary>Создает анонимное событие с заданными обработчиками.</summary>

 <param name="addHandler">Функция для обработки добавления делегата события в триггер.</param>
 <param name="removeHandler">Функция для обработки удаления делегата, который запускается событием.</param>
 <param name="createHandler">Функция для создания типа делегата, который может запускаться событием.</param>

 <returns>Инициализированное событие</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateUsing``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Компилятор F# создает вызовы этой функции, чтобы реализовать оператор <c>use</c> для выражений последовательностей F#.</summary>

 <param name="resource">Ресурс, который нужно использовать и удалить.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateFromFunctions``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Компилятор F# создает вызовы этой функции для реализации преобразования нетипизированных последовательностей System.Collections.IEnumerable в типизированные, которое осуществляется внутренней функцией компилятора.</summary>

 <param name="create">Функция инициализатора.</param>
 <param name="moveNext">Функция для итерации и проверки, если достигнут конец последовательности.</param>
 <param name="current">Функция, извлекающая текущий элемент.</param>

 <returns>Результирующая типизированная последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateThenFinally``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Компилятор F# создает вызовы этой функции, чтобы реализовать оператор <c>try/finally</c> для выражений последовательностей F#.</summary>

 <param name="source">Входная последовательность.</param>
 <param name="compensation">Вычисление, включаемое в метод Dispose перечислителя.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateWhile``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Компилятор F# создает вызовы этой функции, чтобы реализовать оператор <c>while</c> для выражений последовательностей F#.</summary>

 <param name="guard">Функция, указывающее, требуется ли продолжить итерацию.</param>
 <param name="source">Входная последовательность.</param>

 <returns>Результирующая последовательность.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers">
 <summary>Группа функций, используемых в составе скомпилированного представления выражений последовательностей F#.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.query">
 <summary>Создает запрос с использованием синтаксиса запросов и операторов.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.LazyPattern``1(System.Lazy{``0})">
 <summary>Активный шаблон для принудительного исполнения значений типа <c>Lazy&lt;_&gt;</c>.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceUntypedExpression``1(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Особый префиксный оператор для объединения нетипизированных выражений в шаблоны цитирования.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceExpression``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>Особый префиксный оператор для объединения типизированных выражений в шаблоны цитирования.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateArray2D``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует двумерный массив из последовательности последовательностей элементов.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Формирует таблицу подстановок только для чтения из последовательности пар "ключ-значение". Объекты ключей индексируются посредством универсального хеширования и равенства.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSByte``1(``0)">
 <summary>Преобразует аргумент в байтовое значение со знаком.</summary>
 <remarks>Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>SByte.Parse()</c> с параметрами InvariantCulture. В остальных случаях операция требует и вызывает метод <c>ToSByte</c> во входном типе.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToByte``1(``0)">
 <summary>Преобразует аргумент в байтовое значение.</summary>
 <remarks>Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Byte.Parse()</c> в строках и в противном случае требуют метода <c>ToByte</c> во входном типе.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToDouble``1(``0)">
 <summary>Преобразует аргумент в 64-разрядное число с плавающей точкой.</summary>
 <remarks>Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Double.Parse()</c> с параметрами InvariantCulture. В противном случае операция требует и вызывает метод <c>ToDouble</c> для входного типа.</remarks>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSingle``1(``0)">
 <summary>Преобразует аргумент в 32-разрядное число с плавающей точкой.</summary>
 <remarks>Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Single.Parse()</c> с параметрами InvariantCulture. В противном случае операция требует и вызывает метод <c>ToSingle</c> во входном типе.</remarks>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.DefaultAsyncBuilder">
 <summary>Создает асинхронный рабочий процесс, используя синтаксис вычислительного выражения.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateSet``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Формирует набор из последовательности объектов. Объекты индексируются посредством универсального сравнения.</summary>
 <param name="elements">Входная последовательность элементов.</param>
 <returns>Созданное множество.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в файл с использованием заданного формата и добавление новой строки.</summary>
 <param name="textWriter">Средство TextWriter для файлов.</param>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в файл с использованием заданного формата.</summary>
 <param name="textWriter">Средство TextWriter для файлов.</param>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>Печать в буфер строк и создание исключения с заданным результатом. Вспомогательные средства печати должны возвращать строки.</summary>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToString``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
 <summary>Выполняет печать в строку в заданном формате.</summary>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в <c>stderr</c> с использованием заданного формата и добавление новой строки.</summary>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в <c>stderr</c> с использованием заданного формата.</summary>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в <c>stdout</c> с использованием заданного формата и добавление новой строки.</summary>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в <c>stdout</c> с использованием заданного формата.</summary>
 <param name="format">Модуль форматирования.</param>
 <returns>Форматированный результат.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ExtraTopLevelOperators">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByInt``1(``0,System.Int32)">
 <summary>Делит значение на целое число.</summary>
 <param name="x">Входное значение.</param>
 <param name="y">Входное целое число.</param>
 <returns>Результат деления.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOne``1">
 <summary>Выполняет разрешение в значение one для любого числового типа-примитива или любого типа со статическим элементом с именем One.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZero``1">
 <summary>Выполняет разрешение в нулевое значение для любого числового типа-примитива и любого типа со статическим членом Zero.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByIntDynamic``1(``0,System.Int32)">
 <summary>Внутренняя функция компилятора, реализующая динамические вызовы для примитива DivideByInt.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedMultiplyDynamic``3(``0,``1)">
 <summary>Внутренняя функция компилятора, реализующая динамические вызовы проверяемого оператора "*".</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.MultiplyDynamic``3(``0,``1)">
 <summary>Внутренняя функция компилятора, реализующая динамические вызовы оператора "*".</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedAdditionDynamic``3(``0,``1)">
 <summary>Внутренняя функция компилятора, реализующая динамические вызовы проверяемого оператора "+".</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.AdditionDynamic``3(``0,``1)">
 <summary>Внутренняя функция компилятора, реализующая динамические вызовы оператора "+".</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOneDynamic``1">
 <summary>Выполняет разрешение в значение one для любого числового типа-примитива или любого типа со статическим элементом с именем One.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZeroDynamic``1">
 <summary>Выполняет разрешение в нулевое значение для любого числового типа-примитива и любого типа со статическим членом Zero.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt64(System.String)">
 <summary>Анализирует uint64 в соответствии с правилами, используемыми перегруженным оператором преобразования uint64 применительно к строкам</summary>
 <param name="s">Входная строка.</param>
 <returns>Проанализированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt64(System.String)">
 <summary>Анализирует int64 в соответствии с правилами, используемыми перегруженным оператором преобразования int64 применительно к строкам</summary>
 <param name="s">Входная строка.</param>
 <returns>Проанализированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt32(System.String)">
 <summary>Анализирует uint32 в соответствии с правилами, используемыми перегруженным оператором преобразования uint32 применительно к строкам</summary>
 <param name="s">Входная строка.</param>
 <returns>Проанализированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt32(System.String)">
 <summary>Анализирует int32 в соответствии с правилами, используемыми перегруженным оператором преобразования int32 применительно к строкам</summary>
 <param name="s">Входная строка.</param>
 <returns>Проанализированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.SByteWithMeasure``1(System.SByte)">
 <summary>Создает значение sbyte с единицами измерения</summary>
 <param name="sbyte">Входной элемент sbyte.</param>
 <returns>Значение типа sbyte с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int16WithMeasure``1(System.Int16)">
 <summary>Создает значение int16 с единицами измерения</summary>
 <param name="int16">Входной элемент int16.</param>
 <returns>Значение int16 с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int64WithMeasure``1(System.Int64)">
 <summary>Создает значение int64 с единицами измерения</summary>
 <param name="int64">Входной элемент int64.</param>
 <returns>Значение int64 с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int32WithMeasure``1(System.Int32)">
 <summary>Создает значение int32 с единицами измерения</summary>
 <param name="int">Входное целое число.</param>
 <returns>Значение int с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DecimalWithMeasure``1(System.Decimal)">
 <summary>Создает десятичное значение с единицами измерения</summary>
 <param name="decimal">Входное десятичное значение.</param>
 <returns>Десятичное значение с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Float32WithMeasure``1(System.Single)">
 <summary>Создает значение float32 с единицами измерения</summary>
 <param name="float32">Входное плавающее значение.</param>
 <returns>Значение с плавающей точкой с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FloatWithMeasure``1(System.Double)">
 <summary>Создает значение float с единицами измерения</summary>
 <param name="float">Входное плавающее значение.</param>
 <returns>Значение с плавающей точкой с единицами измерения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumToValue``2(``0)">
 <summary>Получает базовое значение для значения перечисления.</summary>
 <param name="enum">Входное перечисление.</param>
 <returns>Перечисление в качестве значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumOfValue``2(``0)">
 <summary>Создает значение перечисления из базового значения</summary>
 <param name="value">Входное значение.</param>
 <returns>Значение как перечисление.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHashWithComparer``1(System.Collections.IEqualityComparer,``0)">
 <summary>Рекурсивно хэширует часть значения в соответствии с его структурой. </summary>
 <param name="comparer">Функция сравнения.</param>
 <param name="obj">Входной объект.</param>
 <returns>Хэшированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLimitedHash``1(System.Int32,``0)">
 <summary>Хэширует значение в соответствии с его структурой. Заданное предельное значение следует использовать для ограничения хэша при хэшировании записей, списков и типов объединения F#. </summary>
 <param name="limit">Предельное количество узлов.</param>
 <param name="obj">Входной объект.</param>
 <returns>Хэшированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHash``1(``0)">
 <summary>Хэширует значение в соответствии с его структурой. Хэш не ограничивается общим количеством узлов при хэшировании типов записей, списков и объединений F#.</summary>
 <param name="obj">Входной объект.</param>
 <returns>Хэшированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastLimitedGenericEqualityComparer``1(System.Int32)">
 <summary>Создает объект хэша и равенства F# для указанного типа, используя ограниченное узлами хэширование записей, списков и типов объединения F#.</summary>
 <param name="limit">Входное предельное количество узлов.</param>
 <returns>System.Collections.Generic.IEqualityComparer&lt;'T&gt;</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericEqualityComparer``1">
 <summary>Создает объект хэша и равенства F# для указанного типа</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparerCanBeNull``1">
 <summary>Создайте объект comparer в F# для заданного типа, чтобы он мог принимать значение null, если System.Collections.Generic.Comparer&lt;'T&gt;.Default</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparer``1">
 <summary>Создает объект компаратора F# для указанного типа.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparer">
 <summary>Статический объект компаратора F#.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityERComparer">
 <summary>Возвращает объект компаратора F#, пригодный для хэширования и определения равенства. Поведение возвращаемого компаратора при хэшировании не ограничивается общим количеством узлов при хэшировании типов записей, списков и объединений F#. Данный компаратор равенства обладает семантикой отношения эквивалентности ([nan] = [nan]).</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityComparer">
 <summary>Возвращает объект компаратора F#, пригодный для хэширования и определения равенства. Поведение возвращаемого компаратора при хэшировании не ограничивается общим количеством узлов при хэшировании типов записей, списков и объединений F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
 <summary>Физический хэш. Хэширует идентификатор объекта кроме типов значений, где хэшируется содержимое.</summary>
 <param name="obj">Входной объект.</param>
 <returns>Хэшированное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
 <summary>Равенство ссылок или физическое равенство. Значение true, если введенные значения имеют равные ссылки; в противном случае — значение false.</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMaximum``1(``0,``0)">
 <summary>Выбирает максимальное из двух значений структурным образом в соответствии с порядком, заданным GenericComparison</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Максимальное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMinimum``1(``0,``0)">
 <summary>Выбирает минимальное из двух значений структурным образом в соответствии с порядком, заданным GenericComparison</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Минимальное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterOrEqual``1(``0,``0)">
 <summary>Сравнивает два значения   </summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessOrEqual``1(``0,``0)">
 <summary>Сравнивает два значения   </summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterThan``1(``0,``0)">
 <summary>Сравнивает два значения   </summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessThan``1(``0,``0)">
 <summary>Сравнивает два значения   </summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparisonWithComparer``1(System.Collections.IComparer,``0,``0)">
 <summary>Сравнивает два значения. Может вызываться рекурсивно из реализации System.IComparable для обеспечения согласованности семантики сравнения не чисел.</summary>
 <param name="comp">Функция, сравнивающая значения.</param>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparison``1(``0,``0)">
 <summary>Сравнивает два значения </summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityWithComparer``1(System.Collections.IEqualityComparer,``0,``0)">
 <summary>Сравнивает два значения  на равенство</summary>
 <param name="comp"></param>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityER``1(``0,``0)">
 <summary>Сравнивает два значения на равенство, используя семантику отношения частичной эквивалентности ([nan] = [nan])</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEquality``1(``0,``0)">
 <summary>Сравнивает два значения на равенство, используя семантику отношения частичной эквивалентности ([nan] &lt;&gt; [nan])</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple5``5(System.Collections.IComparer,System.Tuple{``0,``1,``2,``3,``4},System.Tuple{``0,``1,``2,``3,``4})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple4``4(System.Collections.IComparer,System.Tuple{``0,``1,``2,``3},System.Tuple{``0,``1,``2,``3})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple3``3(System.Collections.IComparer,System.Tuple{``0,``1,``2},System.Tuple{``0,``1,``2})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple2``2(System.Collections.IComparer,System.Tuple{``0,``1},System.Tuple{``0,``1})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple5``5(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3,``4},System.Tuple{``0,``1,``2,``3,``4})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple4``4(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3},System.Tuple{``0,``1,``2,``3})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple3``3(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2},System.Tuple{``0,``1,``2})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple2``2(System.Collections.IEqualityComparer,System.Tuple{``0,``1},System.Tuple{``0,``1})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple5``5(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3,``4})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple4``4(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple3``3(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple2``2(System.Collections.IEqualityComparer,System.Tuple{``0,``1})">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessOrEqualIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterOrEqualIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterThanIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessThanIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityERIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonWithComparerIntrinsic``1(System.Collections.IComparer,``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.LimitedGenericHashIntrinsic``1(System.Int32,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashIntrinsic``1(``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityIntrinsic``1(``0,``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashIntrinsic``1(``0)">
 <summary>Точка входа примитива, которая используется компилятором F# в целях оптимизации.</summary> 
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">
 <summary>Компилятор F# создает вызовы некоторых функций этого модуля как часть скомпилированной формы некоторых языковых конструкций</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray4D``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Стандартный перегруженный ассоциативный оператор изменений (с 4 индексами)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray3D``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32,``0)">
 <summary>Стандартный перегруженный ассоциативный оператор изменений (с 3 индексами)</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray2D``1(``0[0:,0:],System.Int32,System.Int32,``0)">
 <summary>Стандартный перегруженный ассоциативный оператор изменений (с 2 индексами)</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray``1(``0[],System.Int32,``0)">
 <summary>Стандартный перегруженный ассоциативный (индексный) оператор изменений</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray4D``1(``0[0:,0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Стандартный перегруженный ассоциативный оператор поиска (с 4 индексами)</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray3D``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32)">
 <summary>Стандартный перегруженный ассоциативный оператор поиска (с 3 индексами)</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray2D``1(``0[0:,0:],System.Int32,System.Int32)">
 <summary>Стандартный перегруженный ассоциативный оператор поиска (с 2 индексами)</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray``1(``0[],System.Int32)">
 <summary>Стандартный перегруженный ассоциативный (индексный) оператор поиска</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CheckThis``1(``0)">
 <summary>Внутренняя функция компилятора для проверки правильности инициализации рекурсивных привязок</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailStaticInit">
 <summary>Внутренняя функция компилятора для проверки правильности инициализации рекурсивных статических привязок</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailInit">
 <summary>Внутренняя функция компилятора для проверки правильности инициализации рекурсивных привязок</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.Dispose``1(``0)">
 <summary>Внутренняя функция компилятора для эффективной компиляции выражений последовательностей</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.MakeDecimal(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)">
 <summary>Данная функция реализует анализ десятичных констант</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance``1">
 <summary>Данная функция реализует вызовы, обращенные к конструкторам по умолчанию, доступ к которым осуществляется с "новыми" ограничениями.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetString(System.String,System.Int32)">
 <summary>Примитив, используемый компиляцией сопоставления шаблонов</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestFast``1(System.Object)">
 <summary>Внутренняя функция компилятора, реализующая оператор ':?'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestGeneric``1(System.Object)">
 <summary>Внутренняя функция компилятора, реализующая оператор ':?'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxFast``1(System.Object)">
 <summary>Внутренняя функция компилятора, реализующая оператор ":?&gt;"</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric``1(System.Object)">
 <summary>Внутренняя функция компилятора, реализующая оператор ":?&gt;"</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions">
 <summary>Компилятор F# создает вызовы некоторых функций этого модуля как часть скомпилированной формы некоторых языковых конструкций</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_IntegerAddressOf``1(``0)">
 <summary>Оператор address-of. Использование этого значения может привести к созданию непроверяемого кода.</summary>
 <param name="obj">Входной объект.</param>
 <returns>Неуправляемый указатель.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_AddressOf``1(``0)">
 <summary>Оператор address-of. Использование этого значения может привести к созданию непроверяемого кода.</summary>
 <param name="obj">Входной объект.</param>
 <returns>Управляемый указатель.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanOr(System.Boolean,System.Boolean)">
 <summary>Бинарный оператор or. При использовании в качестве бинарного оператора правостороннее значение оценивается только по запросу</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.Or(System.Boolean,System.Boolean)">
 <summary>Бинарный оператор or. При использовании в качестве бинарного оператора правостороннее значение вычисляется только по запросу.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanAnd(System.Boolean,System.Boolean)">
 <summary>Бинарный оператор and. При использовании в качестве бинарного оператора правостороннее значение оценивается только по запросу</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_Amp(System.Boolean,System.Boolean)">
 <summary>Бинарный оператор and. При использовании в качестве бинарного оператора правостороннее значение вычисляется только по запросу.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators">
 <summary>Компилятор F# создает вызовы некоторых функций этого модуля как часть скомпилированной формы некоторых языковых конструкций</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings">
 <summary>Только для внутреннего использования.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">
 <summary>Языковые примитивы, связанные с языком F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromStringDynamic(System.String)">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64Dynamic(System.Int64)">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromString``1(System.String)">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64``1(System.Int64)">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt32``1(System.Int32)">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromOne``1">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromZero``1">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals">
<summary>
 Предоставляет реализации по умолчанию синтаксиса числовых литералов F# для формы dddI. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.KeyValuePattern``2(System.Collections.Generic.KeyValuePair{``0,``1})">
 <summary>Активный шаблон для сопоставления значений типа <c>System.Collections.Generic.KeyValuePair</c></summary>
 <param name="keyValuePair">Входная пара "ключ-значение".</param>
 <returns>Кортеж, содержащий ключ и значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToChar``1(``0)">
 <summary>Преобразует аргумент в символ. Числовые значения преобразуются в символы в соответствии с кодировкой UTF-16. Входные строки должны содержать ровно по одному символу. При обработке входных данных других типов для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованный символ.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDecimal``1(``0)">
 <summary>Преобразует аргумент в тип System.Decimal, используя прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>UInt64.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное десятичное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToString``1(``0)">
 <summary>Преобразует аргумент в строку с помощью <c>ToString</c>.</summary>

 <remarks>Для стандартных целочисленных значений и значений с плавающей запятой преобразование <c>ToString</c> использует <c>CultureInfo.InvariantCulture</c>. </remarks>
 <param name="value">Входное значение.</param>
 <returns>Преобразованная строка.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUIntPtr``1(``0)">
 <summary>Преобразует аргумент в целое число без знака, разрядность которого соответствует разрядности системы, используя прямое преобразование для всех числовых типов-примитивов. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение unativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToIntPtr``1(``0)">
 <summary>Преобразует аргумент в целое число со знаком, разрядность которого соответствует разрядности системы. Это прямое преобразование для всех числовых типов-примитивов. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение nativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDouble``1(``0)">
 <summary>Преобразует аргумент в 64-разрядное число с плавающей точкой. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Double.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение с плавающей точкой</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSingle``1(``0)">
 <summary>Преобразует аргумент в 32-разрядное число с плавающей точкой. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Single.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение float32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt64``1(``0)">
 <summary>Преобразует аргумент в 64-разрядное целое число без знака. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>UInt64.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt64``1(``0)">
 <summary>Преобразует аргумент в 64-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Int64.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt32``1(``0)">
 <summary>Преобразует аргумент в 32-разрядное целое число без знака. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>UInt32.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt32``1(``0)">
 <summary>Преобразует аргумент в 32-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Int32.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToEnum``1(System.Int32)">
 <summary>Преобразует аргумент в определенный тип перечисления.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованный тип перечисления.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt``1(``0)">
 <summary>Преобразует аргумент в 32-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Int32.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное целое число</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt16``1(``0)">
 <summary>Преобразует аргумент в 16-разрядное целое число без знака. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>UInt16.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt16``1(``0)">
 <summary>Преобразует аргумент в 16-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Int16.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSByte``1(``0)">
 <summary>Преобразует аргумент в байтовое значение со знаком. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>SByte.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение sbyte</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToByte``1(``0)">
 <summary>Преобразует аргумент в байтовое значение. Это прямое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>Byte.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное байтовое значение</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.PowInteger``1(``0,System.Int32)">
 <summary>Перегруженный оператор степени. Если <c>n &gt; 0</c>, то оно равно <c>x*...*x</c> для <c>n</c> вхождений <c>x</c>. </summary>
 <param name="x">Входное основание степени.</param>
 <param name="n">Входной показатель степени.</param>
 <returns>Основание, возведенное в степень.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``2(``0,``1)">
 <summary>Перегруженный оператор степени.</summary>
 <param name="x">Входное основание степени.</param>
 <param name="y">Входной показатель степени.</param>
 <returns>Основание, возведенное в степень.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Truncate``1(``0)">
 <summary>Перегруженный оператор усечения.</summary>
 <param name="value">Входное значение.</param>
 <returns>Усеченное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tanh``1(``0)">
 <summary>Гиперболический тангенс указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Гиперболический тангенс входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tan``1(``0)">
 <summary>Тангенс указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Тангенс входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sinh``1(``0)">
 <summary>Гиперболический синус указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Гиперболический синус входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sin``1(``0)">
 <summary>Синус заданного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Синус входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cosh``1(``0)">
 <summary>Гиперболический косинус указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Гиперболический косинус входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cos``1(``0)">
 <summary>Косинус заданного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Косинус входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sqrt``2(``0)">
 <summary>Квадратный корень из заданного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Квадратный корень из входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log10``1(``0)">
 <summary>Логарифм заданного числа с основанием 10</summary>
 <param name="value">Входное значение.</param>
 <returns>Десятичный логарифм входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log``1(``0)">
 <summary>Натуральный логарифм указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Натуральный логарифм входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Round``1(``0)">
 <summary>Округляет заданное число</summary>
 <param name="value">Входное значение.</param>
 <returns>Ближайшее целое число от входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sign``1(``0)">
 <summary>Знак заданного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>-1, 0 или 1, в зависимости от знака входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Floor``1(``0)">
 <summary>Наибольшее целое, не превосходящее заданное число</summary>
 <param name="value">Входное значение.</param>
 <returns>Наибольшее целое, не превосходящее входное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exp``1(``0)">
 <summary>Экспоненциальное представление заданного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Экспоненциальное представление входного выражения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ceiling``1(``0)">
 <summary>Ближайшее целое, превышающее заданное число</summary>
 <param name="value">Входное значение.</param>
 <returns>Ближайшее целое число, превышающее входное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan2``2(``0,``0)">
 <summary>Арктангенс <c>x/y</c>, где <c>x</c> и <c>y</c> заданы по отдельности</summary>
 <param name="y">Входное значение y.</param>
 <param name="x">Входное значение x.</param>
 <returns>Арктангенс указанного отношения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan``1(``0)">
 <summary>Арктангенс указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Арктангенс входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Asin``1(``0)">
 <summary>Арксинус указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Арксинус входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Acos``1(``0)">
 <summary>Арккосинус указанного числа</summary>
 <param name="value">Входное значение.</param>
 <returns>Арккосинус входного значения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Abs``1(``0)">
 <summary>Абсолютное значение указанного числа.</summary>
 <param name="value">Входное значение.</param>
 <returns>Абсолютное значение входного параметра.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)">
 <summary>Универсальная хэш-функция. Эта функция аналогична функции hash, однако структурное хэширование по умолчанию для объединений, записей и кортежей F# останавливается, когда достигается предельное количество узлов. Точное поведение функции может корректироваться в зависимости от типа путем реализации GetHashCode для каждого типа.</summary>
 <param name="limit">Предельное количество узлов.</param>
 <param name="obj">Входной объект.</param>
 <returns>Вычисляемый хэш.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Hash``1(``0)">
 <summary>Общая хэш-функция, предназначенная для возврата равных значений хэша для элемента, равных при применении оператора "=". По умолчанию используется структурное хэширование для объединения, записи и кортежа F#, при этом хэшируется все содержимое типа. Точное поведение функции может корректироваться в зависимости от типа путем реализации GetHashCode для каждого типа.</summary>
 <param name="obj">Входной объект.</param>
 <returns>Вычисляемый хэш.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.SizeOf``1">
 <summary>Возвращает размер внутренний размер типа в байтах. Например, <c>sizeof&lt;int&gt;</c> возвращает 4.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeDefOf``1">
 <summary>Создает представление System.Type для определения типа. Если входной тип является экземпляром универсального типа, возвращается определение универсального типа, связанное со всеми такими экземплярами.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.MethodHandleOf``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Внутренний компилятор, используемый только в пределах библиотеки и предназначенный для создания дескриптора RuntimeMethodHandle во время компиляции.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeOf``1">
 <summary>Создает представление System.Type времени выполнения для статического типа. Статический тип поддерживается в возвращаемом значении.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Очистка ресурсов, связанных с входным объектом, после выполнения заданной функции. Очистка выполняется, когда защищенный код вызывает исключение. </summary>
 <param name="resource">Ресурс, который нужно удалить после вызова действия.</param>
 <param name="action">Действие, принимающее ресурс.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Lock``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>Выполняет функцию как область взаимного исключения, используя входное значение в качестве блокировки. </summary>
 <param name="lockObject">Блокируемый объект.</param>
 <param name="action">Действие, выполняемое во время блокировки.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(``0,``1,``0)">
 <summary>Стандартный перегруженный оператор исключения диапазона, например <c>[n..skip..m]</c> для списков и <c>seq {n..skip..m}</c> для последовательностей.</summary>
 <param name="start">Начальное значение диапазона.</param>
 <param name="step">Значение шага диапазона.</param>
 <param name="finish">Конечное значение диапазона.</param>
 <returns>Последовательность, попадающая в диапазон с использованием указанного размера шага.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)">
 <summary>Стандартный перегруженный оператор диапазона, например <c>[n..m]</c> для списков и <c>seq {n..m}</c> для последовательностей.</summary>
 <param name="start">Начальное значение диапазона.</param>
 <param name="finish">Конечное значение диапазона.</param>
 <returns>Последовательность, попадающая в диапазон.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleOut``1">
 <summary>Считывает значение свойства <c>System.Console.Out</c>.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleError``1">
 <summary>Считывает значение свойства <c>System.Console.Error</c>. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleIn``1">
 <summary>Считывает значение свойства <c>System.Console.In</c>. </summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaNSingle">
 <summary>Эквивалентно <c>System.Single.NaN</c></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.InfinitySingle">
 <summary>Эквивалентно <c>System.Single.PositiveInfinity</c></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaN">
 <summary>Эквивалентно <c>System.Double.NaN</c></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.Infinity">
 <summary>Эквивалентно <c>System.Double.PositiveInfinity</c></summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exit``1(System.Int32)">
 <summary>Выход из текущего аппаратно изолированного процесса, если это позволяют в параметры безопасности. В противном случае вызывается исключение. Вызывает <c>System.Environment.Exit</c>.</summary>
 <param name="exitcode">Используемый код выхода.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.CreateSequence``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Создать последовательность с помощью синтаксиса последовательности</summary>
 <param name="sequence">Входная последовательность.</param>
 <returns>Результирующая последовательность.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Not(System.Boolean)">
 <summary>Отрицание логического значения. <c>not true</c> равно <c>false</c>, а <c>not false</c> равно <c>true</c></summary>
 <param name="value">Инвертируемое значение.</param>
 <returns>Результат инвертирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Сцепляет два списка.</summary>
 <param name="list1">Первый список.</param>
 <param name="list2">Второй список.</param>
 <returns>Сцепление списков.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Increment(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
 <summary>Увеличение ссылочной ячейки, содержащей целое число</summary>
 <param name="cell">Ссылочная ячейка.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Decrement(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
 <summary>Уменьшение ссылочной ячейки, содержащей целое число</summary>
 <param name="cell">Ссылочная ячейка.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})">
 <summary>Разыменование изменяемой ссылочной ячейки</summary>
 <param name="cell">Ячейка, которую необходимо разыменовать.</param>
 <returns>Значение, содержащееся в ячейке.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)">
 <summary>Присваивает значение изменяемой ссылочной ячейке</summary>
 <param name="cell">Изменяемая ячейка.</param>
 <param name="value">Значение, задаваемое в ячейке.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ref``1(``0)">
 <summary>Создает изменяемую ссылочную ячейку</summary>
 <param name="value">Значение, которое должно содержаться в ячейке.</param>
 <returns>Созданная ссылочная ячейка.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Identity``1(``0)">
 <summary>Функция идентификатора</summary>
 <param name="x">Входное значение.</param>
 <returns>Такое же значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidOp``1(System.String)">
 <summary>Создается исключение <c>System.InvalidOperationException</c></summary>
 <param name="message">Сообщение об исключении.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NullArg``1(System.String)">
 <summary>Создается исключение <c>System.ArgumentNullException</c></summary>
 <param name="argumentName">Имя аргумента.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArg``1(System.String,System.String)">
 <summary>Создается исключение <c>System.ArgumentException</c> с заданным именем аргумента и сообщением.</summary>
 <param name="argumentName">Имя аргумента.</param>
 <param name="message">Сообщение об исключении.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailWith``1(System.String)">
 <summary>Создается исключение <c>System.Exception</c>.</summary>
 <param name="message">Сообщение об исключении.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Box``1(``0)">
 <summary>Упаковывает строго типизированное значение.</summary>
 <param name="value">Значение для упаковки.</param>
 <returns>Упакованный объект.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unbox``1(System.Object)">
 <summary>Распаковывает строго типизированное значение. Это функция, обратная функции <c>box</c>, unbox&lt;t&gt;(box&lt;t&gt; a) равно a.</summary>
 <param name="value">Упакованное значение.</param>
 <returns>Распакованный результат.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ignore``1(``0)">
 <summary>Игнорировать переданное значение. Это часто используется для отброса результатов вычисления.</summary>
 <param name="value">Значение, которое нужно игнорировать.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Min``1(``0,``0)">
 <summary>Минимум на основе общего сравнения</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Минимальное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Max``1(``0,``0)">
 <summary>Максимум на основе общего сравнения</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Максимальное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Compare``1(``0,``0)">
 <summary>Общее сравнение.</summary>
 <param name="e1">Первое значение.</param>
 <param name="e2">Второе значение.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Snd``2(System.Tuple{``0,``1})">
 <summary>Возвращает второй элемент кортежа, <c>snd (a,b) = b</c>.</summary>
 <param name="tuple">Входной кортеж.</param>
 <returns>Второе значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Fst``2(System.Tuple{``0,``1})">
 <summary>Возвращает первый элемент кортежа, <c>fst (a,b) = a</c>.</summary>
 <param name="tuple">Входной кортеж.</param>
 <returns>Первое значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailurePattern(System.Exception)">
 <summary>Сопоставляет объекты <c>System.Exception</c>, тип среды выполнения которых в точности равен <c>System.Exception</c></summary>
 <param name="error">Входное исключение.</param>
 <returns>Параметр строки.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Failure(System.String)">
 <summary>Создает объект <c>System.Exception</c>.</summary>
 <param name="message">Сообщение об исключении.</param>
 <returns>Исключение System.Exception.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Reraise``1">
 <summary>Повторно создает исключение. Используется только при обработке исключения.</summary>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Rethrow``1">
 <summary>Повторно создает исключение. Используется только при обработке исключения.</summary>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Raise``1(System.Exception)">
 <summary>Создает исключение</summary>
 <param name="exn">Создаваемое исключение.</param>
 <returns>Результирующее значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)">
 <summary>Сцепляет две строки. Также можно использовать оператор "+".</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.DefaultArg``1(Microsoft.FSharp.Core.FSharpOption{``0},``0)">
 <summary>Используется для указания значения по умолчанию для каждого необязательного аргумента в реализации функции</summary>
 <param name="arg">Параметр, представляющий аргумент.</param>
 <param name="defaultValue">Значение аргумента  по умолчанию.</param>
 <returns>Значение аргумента. Если значение равно None, возвращается значение defaultValue.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0,``1,``2)">
 <summary>Применяет расположенную слева функцию к трем значениям справа</summary>
 <param name="func">Функция.</param>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Применяет расположенную слева функцию к паре значений справа</summary>
 <param name="func">Функция.</param>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
 <summary>Применяет расположенную слева функцию к значению справа</summary>
 <param name="func">Функция.</param>
 <param name="arg1">Аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight3``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}})">
 <summary>Функция (справа) применяется к трем значениям (три элемента слева)</summary>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <param name="func">Функция.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight2``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Функция (справа) применяется к двум значениям (пара слева)</summary>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="func">Функция.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Функция (справа) применяется к значению (слева)</summary>
 <param name="arg">Аргумент.</param>
 <param name="func">Функция.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
 <summary>Объединяет две функции, при этом сначала применяется функция справа</summary>
 <param name="func2">Вторая применяемая функция.</param>
 <param name="func1">Первая применяемая функция.</param>
 <returns>Объединение входных функций.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
 <summary>Объединяет две функции, при этом сначала применяется функция слева</summary>
 <param name="func1">Первая применяемая функция.</param>
 <param name="func2">Вторая применяемая функция.</param>
 <returns>Объединение входных функций.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Inequality``1(``0,``0)">
 <summary>Структурная проверка на неравенство</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)">
 <summary>Структурная проверка на равенство</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
 <summary>Структурное сравнение на предмет меньшего или равного значения</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
 <summary>Структурная проверка на большинство или равенство</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
 <summary>Структурная проверка на большинство</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
 <summary>Структурное сравнение на предмет меньшего значения</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)">
 <summary>Перегруженный префиксный оператор =plus</summary>
 <param name="value">Входное значение.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)">
 <summary>Перегруженный логический оператор NOT</summary>
 <param name="value">Входное значение.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)">
 <summary>Перегруженный оператор сдвига вправо на указанное число битов</summary>
 <param name="value">Входное значение.</param>
 <param name="shift">Число битов для смещения.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)">
 <summary>Перегруженный оператор сдвига влево на указанное число битов</summary>
 <param name="value">Входное значение.</param>
 <param name="shift">Число битов для смещения.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)">
 <summary>Перегруженный логический оператор XOR</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)">
 <summary>Перегруженный логический оператор ИЛИ</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)">
 <summary>Перегруженный логический оператор И</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)">
 <summary>Перегруженный оператор остатка от деления</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)">
 <summary>Перегруженный оператор деления</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)">
 <summary>Перегруженный оператор умножения</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)">
 <summary>Перегруженный оператор вычитания</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)">
 <summary>Перегруженный оператор сложения</summary>
 <param name="x">Первый параметр.</param>
 <param name="y">Второй параметр.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)">
 <summary>Перегруженное унарное отрицание.</summary>
 <param name="n">Инвертируемое значение.</param>
 <returns>Результат операции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToChar``1(``0)">
 <summary>Преобразует аргумент в <c>char</c>. Проверяемое преобразование входных числовых значений осуществляется в соответствии с символьной кодировкой UTF-16. Входные строки должны содержать ровно по одному символу. При обработке входных данных других типов для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованный символ</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUIntPtr``1(``0)">
 <summary>Преобразует аргумент в <c>unativeint</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение unativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToIntPtr``1(``0)">
 <summary>Преобразует аргумент в <c>nativeint</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение nativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt64``1(``0)">
 <summary>Преобразует аргумент в <c>uint64</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.UInt64.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt64``1(``0)">
 <summary>Преобразует аргумент в <c>int64</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.Int64.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int64</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt32``1(``0)">
 <summary>Преобразует аргумент в <c>uint32</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.UInt32.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt32``1(``0)">
 <summary>Преобразует аргумент в <c>int32</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.Int32.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int32</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt``1(``0)">
 <summary>Преобразует аргумент в <c>int</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.Int32.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное целое число</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt16``1(``0)">
 <summary>Преобразует аргумент в <c>uint16</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.UInt16.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt16``1(``0)">
 <summary>Преобразует аргумент в <c>int16</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.Int16.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int16</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToSByte``1(``0)">
 <summary>Преобразует аргумент в <c>sbyte</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.SByte.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение sbyte</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToByte``1(``0)">
 <summary>Преобразует аргумент в <c>byte</c>. Это прямое проверяемое преобразование для всех числовых типов-примитивов. Строковые входные данные преобразуются с помощью <c>System.Byte.Parse()</c> с параметрами InvariantCulture. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное байтовое значение</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3(``0,``1)">
 <summary>Перегруженный оператор умножения (проверяет переполнение)</summary>
 <param name="x">Первое значение.</param>
 <param name="y">Второе значение.</param>
 <returns>Произведение двух входных значений .</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3(``0,``1)">
 <summary>Перегруженный оператор сложения (проверяет переполнение)</summary>
 <param name="x">Первое значение.</param>
 <param name="y">Второе значение.</param>
 <returns>Сумма двух входных значений.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3(``0,``1)">
 <summary>Перегруженный оператор вычитания (проверяет переполнение)</summary>
 <param name="x">Первое значение.</param>
 <param name="y">Второе значение.</param>
 <returns>Первое значение минус второе значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_UnaryNegation``1(``0)">
 <summary>Перегруженный оператор унарного отрицания (проверяет переполнение)</summary>
 <param name="value">Входное значение.</param>
 <returns>Инвертированное значение.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">
 <summary>Этот модуль содержит основные арифметические операции с проверкой переполнения.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Hash``1(``0)">
 <summary>Выполняет хэширование значения, где для ограничения "равенства" тип значения статически необязателен. </summary>
 <returns>Вычисленное значение хэша.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Equals``1(``0,``0)">
 <summary>Выполняет общее сравнение на равенство двух значений, где для ограничения "равенства" тип значений статически необязателен. </summary>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Compare``1(``0,``0)">
 <summary>Выполняет общее сравнение двух значений, где для "сравнительного" ограничения тип значений статически необязателен. </summary>
 <returns>Результат сравнения.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.DefaultOf``1">
 <summary>Создает значение по умолчанию для любого типа. Для ссылочных типов — это NULL. Для структур значения всех полей равны значению по умолчанию. Эта функция небезопасна в том смысле, что некоторые значения F# не имеют надлежащих значений <c>null</c>.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Unbox``1(System.Object)">
 <summary>Распаковывает строго типизированное значение. Это функция, обратная функции <c>box</c>, unbox&lt;t&gt;(box&lt;t&gt; a) равно a.</summary>
 <param name="value">Упакованное значение.</param>
 <returns>Распакованный результат.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Unchecked">
 <summary>Этот модуль содержит основные операции, которые не применяют проверки во время выполнения и/или статические проверки.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDecimal(System.Decimal,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа decimal</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDouble(System.Double,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа float</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSingle(System.Single,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа float32</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUIntPtr(System.UIntPtr,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа unativeint</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowIntPtr(System.IntPtr,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа nativeint</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt64(System.UInt64,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа uint64</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt64(System.Int64,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа int64</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt32(System.UInt32,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа uint32</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt32(System.Int32,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа int32</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt16(System.UInt16,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа uint16</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt16(System.Int16,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа int16</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSByte(System.SByte,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа sbyte</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowByte(System.Byte,System.Int32)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции можно создавать посредством универсального оператора pown, применяемого к значениям типа byte</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDynamic``2(``0,``1)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanhDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinhDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CoshDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CosDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SqrtDynamic``2(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Log10Dynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.LogDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SignDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RoundDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TruncateDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.FloorDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.ExpDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CeilingDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Atan2Dynamic``2(``0,``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AtanDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AsinDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AcosDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AbsDynamic``1(``0)">
 <summary>Это встроенная функция библиотеки. Вызовы этой функции могут создаваться посредством вычисления цитирований.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeStepGeneric``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0,``1)">
 <summary>Создает диапазон значений с использованием заданных значений zero, add, start, step и stop</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``0)">
 <summary>Создает диапазон значений с использованием заданных значений zero, add, start, step и stop</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeChar(System.Char,System.Char)">
 <summary>Создает диапазон значений char</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeByte(System.Byte,System.Byte,System.Byte)">
 <summary>Создает диапазон значений byte</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSByte(System.SByte,System.SByte,System.SByte)">
 <summary>Создает диапазон значений sbyte</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt16(System.UInt16,System.UInt16,System.UInt16)">
 <summary>Создает диапазон значений uint16</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt16(System.Int16,System.Int16,System.Int16)">
 <summary>Создает диапазон значений int16</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUIntPtr(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
 <summary>Создает диапазон значений unativeint</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeIntPtr(System.IntPtr,System.IntPtr,System.IntPtr)">
 <summary>Создает диапазон значений nativeint</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt32(System.UInt32,System.UInt32,System.UInt32)">
 <summary>Создает диапазон значений uint32</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt64(System.UInt64,System.UInt64,System.UInt64)">
 <summary>Создает диапазон значений uint64</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt64(System.Int64,System.Int64,System.Int64)">
 <summary>Создает диапазон значений int64</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSingle(System.Single,System.Single,System.Single)">
 <summary>Создает диапазон значений float32</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeDouble(System.Double,System.Double,System.Double)">
 <summary>Создает диапазон значений float</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt32(System.Int32,System.Int32,System.Int32)">
 <summary>Создает диапазон целых чисел</summary>  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetStringSlice(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Получает срез из строки</summary>
 <param name="source">Исходная строка.</param>
 <param name="start">Индекс первого символа среза.</param>
 <param name="finish">Индекс последнего символа среза.</param>
 <returns>Подмассив из заданных индексов.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4D``1(``0[0:,0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:,0:,0:,0:])">
 <summary>Задает срез массива</summary>
 <param name="target">Целевой массив.</param>
 <param name="start1">Начальный индекс в первом измерении.</param>
 <param name="finish1">Конечный индекс в первом измерении.</param>
 <param name="start2">Начальный индекс во втором измерении.</param>
 <param name="finish2">Конечный индекс во втором измерении.</param>
 <param name="start3">Начальный индекс в третьем измерении.</param>
 <param name="finish3">Конечный индекс в третьем измерении.</param>
 <param name="start4">Начальный индекс в четвертом измерении.</param>
 <param name="finish4">Конечный индекс в четвертом измерении.</param>
 <param name="source">Исходный массив.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4D``1(``0[0:,0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Получает срез массива</summary>
 <param name="source">Исходный массив.</param>
 <param name="start1">Начальный индекс в первом измерении.</param>
 <param name="finish1">Конечный индекс в первом измерении.</param>
 <param name="start2">Начальный индекс во втором измерении.</param>
 <param name="finish2">Конечный индекс во втором измерении.</param>
 <param name="start3">Начальный индекс в третьем измерении.</param>
 <param name="finish3">Конечный индекс в третьем измерении.</param>
 <param name="start4">Начальный индекс в четвертом измерении.</param>
 <param name="finish4">Конечный индекс в четвертом измерении.</param>
 <returns>Четырехмерный подмассив из заданных индексов.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3D``1(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:,0:,0:])">
 <summary>Задает срез массива</summary>
 <param name="target">Целевой массив.</param>
 <param name="start1">Начальный индекс в первом измерении.</param>
 <param name="finish1">Конечный индекс в первом измерении.</param>
 <param name="start2">Начальный индекс во втором измерении.</param>
 <param name="finish2">Конечный индекс во втором измерении.</param>
 <param name="start3">Начальный индекс в третьем измерении.</param>
 <param name="finish3">Конечный индекс в третьем измерении.</param>
 <param name="source">Исходный массив.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3D``1(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Получает срез массива</summary>
 <param name="source">Исходный массив.</param>
 <param name="start1">Начальный индекс в первом измерении.</param>
 <param name="finish1">Конечный индекс в первом измерении.</param>
 <param name="start2">Начальный индекс во втором измерении.</param>
 <param name="finish2">Конечный индекс во втором измерении.</param>
 <param name="start3">Начальный индекс в третьем измерении.</param>
 <param name="finish3">Конечный индекс в третьем измерении.</param>
 <returns>Трехмерный подмассив из заданных индексов.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2D``1(``0[0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:,0:])">
 <summary>Задает срез массива</summary>
 <param name="target">Целевой массив.</param>
 <param name="start1">Начальный индекс в первом измерении.</param>
 <param name="finish1">Конечный индекс в первом измерении.</param>
 <param name="start2">Начальный индекс во втором измерении.</param>
 <param name="finish2">Конечный индекс во втором измерении.</param>
 <param name="source">Исходный массив.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2D``1(``0[0:,0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Получает срез массива</summary>
 <param name="source">Исходный массив.</param>
 <param name="start1">Начальный индекс в первом измерении.</param>
 <param name="finish1">Конечный индекс в первом измерении.</param>
 <param name="start2">Начальный индекс во втором измерении.</param>
 <param name="finish2">Конечный индекс во втором измерении.</param>
 <returns>Двумерный подмассив из входных индексов.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice``1(``0[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[])">
 <summary>Задает срез массива</summary>
 <param name="target">Целевой массив.</param>
 <param name="start">Начальный индекс.</param>
 <param name="finish">Конечный индекс.</param>
 <param name="source">Исходный массив.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice``1(``0[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Получает срез массива</summary>
 <param name="source">Входной массив.</param>
 <param name="start">Начальный индекс.</param>
 <param name="finish">Конечный индекс.</param>
 <returns>Подмассив из входных индексов.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.OperatorIntrinsics">
 <summary>Модуль встроенных функций компилятора для эффективной реализации диапазонов целых чисел и динамического вызова других операторов F#.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators">
 <summary>Основные операторы F#. Этот модуль автоматически открывается во всем коде F#.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Invoke(`0,`1,`2,`3,`4)">
 <summary>Вызывает значение функции первого класса F#, которое принимает пять каррированных аргументов, не вмешиваясь в выполнение</summary>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <param name="arg4">Четвертый аргумент.</param>
 <param name="arg5">Пятый аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`2,Microsoft.FSharp.Core.FSharpFunc{`3,Microsoft.FSharp.Core.FSharpFunc{`4,`5}}}}})">
 <summary>Преобразование значения функции первого класса F# в значение оптимизированной функции, которое может принять пять каррированных аргументов, не вмешиваясь в выполнение. </summary>
 <param name="func">Входная функция.</param>
 <returns>Оптимизированная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.#ctor">
 <summary>Создает значение оптимизированной функции, которое может принять пять каррированных аргументов, не вмешиваясь в выполнение.</summary>
 <returns>Оптимизированная функция.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6">
 <summary>Тип CLI, используемый для представления значений функции F#, которые принимают пять каррированных аргументов, не вмешиваясь в выполнение. Этот тип обычно не должен напрямую использоваться в коде F# или других языках CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Invoke(`0,`1,`2,`3)">
 <summary>Вызывает значение функции первого класса F#, которое принимает четыре каррированных аргумента, не вмешиваясь в выполнение</summary>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <param name="arg4">Четвертый аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`2,Microsoft.FSharp.Core.FSharpFunc{`3,`4}}}})">
 <summary>Преобразование значения функции первого класса F# в значение оптимизированной функции, которое может принять четыре каррированных аргумента, не вмешиваясь в выполнение. </summary>
 <param name="func">Входная функция.</param>
 <returns>Оптимизированная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.#ctor">
 <summary>Создает значение оптимизированной функции, которое может принять четыре каррированных аргумента, не вмешиваясь в выполнение.</summary>
 <returns>Оптимизированная функция.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5">
 <summary>Тип CLI, используемый для представления значений функции F#, которые принимают четыре каррированных аргумента, не вмешиваясь в выполнение. Этот тип обычно не должен напрямую использоваться в коде F# или других языках CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Invoke(`0,`1,`2)">
 <summary>Вызывает значение функции первого класса F#, которое принимает три каррированных аргумента, не вмешиваясь в выполнение</summary>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <param name="arg3">Третий аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`2,`3}}})">
 <summary>Преобразует значение функции первого класса F# в значение оптимизированной функции, которое может принять три каррированных аргумента, не вмешиваясь в выполнение. </summary>
 <param name="func">Входная функция.</param>
 <returns>Преобразованная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.#ctor">
 <summary>Создает значение оптимизированной функции, которое может принять три каррированных аргумента, не прерывая выполнение.</summary>
 <returns>Оптимизированная функция.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4">
 <summary>Тип CLI, используемый для представления значений функции F#, которые принимают три прошедших итерацию (каррированных) аргумента, не вмешиваясь в выполнение. Этот тип обычно не должен напрямую использоваться в коде F# или других языках CLI.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Invoke(`0,`1)">
 <summary>Вызывает значение оптимизированной функции с двумя каррированными аргументами </summary>
 <param name="arg1">Первый аргумент.</param>
 <param name="arg2">Второй аргумент.</param>
 <returns>Результат функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,`2}})">
 <summary>Преобразование значения функции первого класса F# в значение оптимизированной функции, которое может принять два каррированных аргумента, не вмешиваясь в выполнение. </summary>
 <param name="func">Входная функция.</param>
 <returns>Преобразованная функция.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.#ctor">
 <summary>Создает значение оптимизированной функции, которое может принять два каррированных аргумента, не вмешиваясь в выполнение.</summary>
 <returns>Оптимизированная функция.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3">
 <summary>Тип CLI, используемый для представления значений функции F#, которые принимают два прошедших итерацию (каррированных) аргумента, не вмешиваясь в выполнение. Этот тип обычно не должен напрямую использоваться в коде F# или других языках CLI.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
 <summary>Модуль реализации, в котором содержатся частные реализации вызова функции.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Преобразует параметр в список длиной 0 или 1.</summary>
 <param name="option">Входной параметр.</param>
 <returns>Результирующий список.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Преобразует параметр в массив длиной 0 или 1.</summary>
 <param name="option">Входной параметр.</param>
 <returns>Результирующий массив.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>bind f inp</c> равно <c>match inp with None -&gt; None | Some x -&gt; f x</c></summary>
 <param name="binder">Функция, которая принимает значение типа T из параметра и преобразует его в параметр, содержащий значение типа U.</param>
 <param name="option">Входной параметр.</param>
 <returns>Параметр выходного типа связывателя.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>map f inp</c> равно <c>match inp with None -&gt; None | Some x -&gt; Some (f x)</c>.</summary>
 <param name="mapping">Функция, применяемая к значению параметра.</param>
 <param name="option">Входной параметр.</param>
 <returns>Возвращает параметр входного значения после применения функции сопоставления или значение None, если входное значение равно None.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>iter f inp</c> выполняет <c>match inp with None -&gt; () | Some x -&gt; f x</c>.</summary>
 <param name="action">Функция, применяемая к значению параметра.</param>
 <param name="option">Входной параметр.</param>
 <returns>Единица, если параметр option имеет значение None; в противном случае возвращается результат применения предиката к значению параметра option.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>forall p inp</c> равно <c>match inp with None -&gt; true | Some x -&gt; p x</c>.</summary>
 <param name="predicate">Функция, вычисляющая логическое значение при указании значения из типа параметра.</param>
 <param name="option">Входной параметр.</param>
 <returns>Значение true, если параметр option имеет значение None; в противном случае возвращается результат применения предиката к значению параметра option.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>exists p inp</c> равно <c>match inp with None -&gt; false | Some x -&gt; p x</c>.</summary>
 <param name="predicate">Функция, вычисляющая логическое значение при указании значения из типа параметра.</param>
 <param name="option">Входной параметр.</param>
 <returns>Значение false, если параметр option имеет значение None; в противном случае возвращается результат применения предиката к значению параметра option.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpOption{``0},``1)">
 <summary><c>fold f inp s</c> равно <c>match inp with None -&gt; s | Some x -&gt; f x s</c>.</summary>
 <param name="folder">Функция, обновляющая данные состояния при значения из параметра.</param>
 <param name="option">Входной параметр.</param>
 <param name="state">Начальное состояние.</param>
 <returns>Первоначальное состояние, если параметр option имеет значение None; в противном случае возвращается обновленное состояние с функцией, определенной параметром folder, и значением параметра option.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>fold f s inp</c> равно <c>match inp with None -&gt; s | Some x -&gt; f s x</c>.</summary>
 <param name="folder">Функция, обновляющая данные состояния при значения из параметра.</param>
 <param name="state">Начальное состояние.</param>
 <param name="option">Входной параметр.</param>
 <returns>Первоначальное состояние, если параметр option имеет значение None; в противном случае возвращается обновленное состояние с функцией, определенной параметром folder, и значением параметра option.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Count``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>count inp</c> равно <c>match inp with None -&gt; 0 | Some _ -&gt; 1</c>.</summary>
 <param name="option">Входной параметр.</param>
 <returns>0, если параметр имеет значение None; в противном случае — значение 1.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.GetValue``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Получает значение, связанное с параметром.</summary>
 <param name="option">Входной параметр.</param>
 <returns>Значение в параметре.</returns>
 <exception href="System.ArgumentException">Создается, если значение параметра равно None.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsNone``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Возвращает значение true, если значение параметра равно None.</summary>
 <param name="option">Входной параметр.</param>
 <returns>Возвращает значение true, если значение параметра равно  None.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsSome``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Возвращает значение true, если значение параметра отличается от None.</summary>
 <param name="option">Входной параметр.</param>
 <returns>Значение true, если параметр не имеет значения None.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptionModule">
 <summary>Основные операции над параметрами.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`1">
 <summary>Представляет статически анализируемый формат, связанный с записью в объект <c>System.IO.TextWriter</c>. Параметр типа обозначает тип аргументов и возвращаемого значения операции формата.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`1">
 <summary>Представляет статически анализируемый формат, если при форматировании создается строка. Параметр типа обозначает тип аргументов и возвращаемого значения операции формата.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`1">
 <summary>Представляет статически анализируемый формат, связанный с записью в объект <c>System.Text.StringBuilder</c>. Параметр типа обозначает тип аргументов и возвращаемого значения операции формата.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`2">
 <summary>Представляет статически анализируемый формат, связанный с записью в объект <c>System.IO.TextWriter</c>. Первый параметр типа указывает аргументы операции форматирования, а последний — тип возвращаемого значения.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`2">
 <summary>Представляет статически анализируемый формат, если при форматировании создается строка. Первый параметр типа указывает аргументы операции форматирования, а последний — тип возвращаемого значения.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`2">
 <summary>Представляет статически анализируемый формат, связанный с записью в объект <c>System.Text.StringBuilder</c>. Первый параметр типа указывает аргументы операции форматирования, а последний — тип возвращаемого значения.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>Печать в буфер строк и создание исключения с заданным результатом. Вспомогательные средства печати должны возвращать строки.</summary>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``2(Microsoft.FSharp.Core.FSharpFunc{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
 <summary>sprintf, но для создания результата вызывается заданная "конечная" функция. См. <c>kprintf</c>.</summary>
 <param name="continutation">Функция, вызываемая для создания результата из отформатированной строки.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatThen``2(Microsoft.FSharp.Core.FSharpFunc{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
 <summary>printf, но для создания результата вызывается заданная "конечная" функция. Например, это позволяет выполнять печать не раньше, чем все выходные данные будут введены в канал. </summary>
 <param name="continutation">Функция вызывается после форматирования для создания результата формата.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriterThen``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
 <summary>fprintf, но для создания результата вызывается заданная "конечная" функция. См. <c>kprintf</c>.</summary>
 <param name="continutation">Функция вызывается после форматирования для создания результата формата.</param>
 <param name="textWriter">Входной TextWriter.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilderThen``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
 <summary>bprintf, но для создания результата вызывается заданная "конечная" функция. См. <c>kprintf</c>.</summary>
 <param name="continutation">Функция вызывается после форматирования для создания результата формата.</param>
 <param name="builder">Входной объект StringBuilder.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
 <summary>Печать в строку с помощью внутреннего буфера строки и возвращение результата в виде строки. Вспомогательные средства печати должны возвращать строки.</summary>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Форматированная строка.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Форматированная печать в stdout с добавлением новой строки.</summary>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Форматированная печать в stdout</summary>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Форматированная печать в stderr с добавлением новой строки </summary>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Форматированная печать в stderr</summary>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Выполняет печать в модуль записи текста с добавлением новой строки</summary>
 <param name="textWriter">Модуль TextWriter, в который осуществляется печать.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в модуль записи текста.</summary>
 <param name="textWriter">Модуль TextWriter, в который осуществляется печать.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilder``1(System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Печать в <c>System.Text.StringBuilder</c></summary>
 <param name="builder">Объект StringBuilder, в который необходимо печатать.</param>
 <param name="format">Модуль форматирования входных данных.</param>
 <returns>Тип возвращаемого значения и аргументы модуля форматирования.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule">
 <summary>Расширенное форматирование в стиле printf для чисел и других типов данных</summary>

 <remarks>Спецификации формата представляют собой строки с маркерами %, обозначающими заполнители формата. Местозаполнители формата состоят из <c> %[flags][width][.precision][type] </c>, где тип интерпретируется следующим образом: <c> %b: логическое значение в формате true или false %s: строка, форматированная как ее содержимое без escape-последовательности %c: символьный литерал %d, %i: любой базовый целочисленный тип, форматированный как десятичное целое число, которое подписывается, если подписан базовый тип целочисленного числа. %u: любой базовый целочисленный тип, форматированный как десятичное целое число без знака %x, %X, %o: любой базовый целочисленный тип, форматированный как шестнадцатеричное число без знака (a-f)/Шестнадцатеричное (A-F)/Восьмеричное целое число %e, %E, %f, %F, %g, %G: любой базовый тип с плавающей запятой (float,float32), форматированный с использованием спецификаций форматирования объектов с плавающей запятой в стиле С, i.e %e, %E: подписанное значение в форме [-]d.dddde[sign]ddd, где d — одна десятичная цифра, dddd — одна или более десятичных цифр, а ddd — точно три десятичных цифры, используется знак + или – %f: подписанное значение в форме [-]dddd.dddd, где dddd — одна или более десятичных цифр. Количество цифр перед десятичной точкой зависит от порядка числа, а количество цифр после десятичной точки зависит от указанной точности. %g, %G: Значение со знаком, представленное в формате f или e в зависимости от того, какой формат является более компактным для заданных значения и точности. %M: значение System.Decimal %O: любое значение, выводимое на печать посредством упаковки-преобразования и с использованием его метода или методов ToString %A: любое значение, выводимое на печать с параметрами макета по умолчанию %a: общий спецификатор формата, требующий два аргумента: (1) функция, принимающая два аргумента: (а) контекстный параметр соответствующего типа для заданной функции форматирования (напр., #System.IO.TextWriter) (б) значение для печати, которое, кроме того, выводит или возвращает соответствующий текст. (2) конкретное значение для печати %t: Общий описатель формата, для которого требуется один аргумент: (1) функция, которая принимает параметр контекста соответствующего типа для заданной функции форматирования (например, System.IO.TextWriter) и выводит или возвращает соответствующий текст. Основные целочисленные типы: byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint Базовые типы с плавающей запятой: float, float32 </c> Необязательный параметр width — это целое число, обозначающее минимальную ширину результата. Например, %6d печатает целое число с префиксом в виде пробелов, на место которых можно поставить не мене 6 символов. Если ширина равна *, используется дополнительный целочисленный аргумент, который задает соответствующую ширину. <c> любое количество *: </c> Допустимые флаги: <c> 0: добавляет нули вместо пробелов, чтобы компенсировать нужную ширину -: выравнивание результата по левой стороне в пределах указанной ширины +: добавляет знак "плюс", если число положительное (чтобы соответствовать знаку "минус" для отрицательных чисел)  : добавляет дополнительный пробел, если число положительное (чтобы соответствовать знаку "минус" для отрицательных чисел) </c> Флаг printf # является недопустимым, при его использовании создается ошибка времени компиляции.</remarks>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Core.SR">

</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Length(System.String)">
 <summary>Возвращает длину строки.</summary>
 <param name="str">Входная строка.</param>
 <returns>Количество знаков в строке.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Replicate(System.Int32,System.String)">
 <summary>Возвращает строку, сцепляя <c>count</c> экземпляров объектов <c>str</c>.</summary>
 <param name="count">Будет скопировано количество копий входной строки.</param>
 <param name="str">Входная строка.</param>
 <returns>Сцепленная строка.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Exists(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Проверяет, удовлетворяет ли какой-либо символ строки заданному предикату.</summary>
 <param name="predicate">Функция, предназначенная для проверки каждого символа строки.</param>
 <param name="str">Входная строка.</param>
 <returns>Значение true, если какой-либо символ возвращает значение true для предиката и false в остальных случаях.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.ForAll(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Проверяет, удовлетворяют ли все символы строки заданному предикату.</summary>
 <param name="predicate">Функция, предназначенная для проверки каждого символа строки.</param>
 <param name="str">Входная строка.</param>
 <returns>Значение true, если все символы возвращают значение true для предиката и false в остальных случаях.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Initialize(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String})">
 <summary>Создает новую строку, символы которой являются результатом применения функции <c>mapping</c> к каждому индексу от <c>0</c>до <c>count-1</c> и сцепляет полученные строки.</summary>
 <param name="count">Число строк, которые нужно инициализировать.</param>
 <param name="initializer">Функция, принимающая индекс и производящая строку, которую необходимо сцепить с другими.</param>
 <returns>Сконструированная строка.</returns>
 <exception cref="System.ArgumentException">Создается, если <c>count</c> является отрицательным.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Collect(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.String},System.String)">
 <summary>Создает новую строку, символы которой являются результатом применения функции <c>mapping</c> к каждому символу входной строки и сцепления получающихся строк.</summary>
 <param name="mapping">Функция для создания строки из каждого символа входной строки.</param>
 <param name="str">Входная строка.</param>
 <returns>Сцепленная строка.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.MapIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char}},System.String)">
 <summary>Создает новую строку, символы которой являются результатом применения функции <c>mapping</c> к каждому символу и индексу входной строки.</summary>
 <param name="mapping">Функция, предназначенная для применения к каждому символу и индексу строки.</param>
 <param name="str">Входная строка.</param>
 <returns>Результирующая строка.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Map(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char},System.String)">
 <summary>Создает новую строку, символы которой являются результатом применения функции <c>mapping</c> к каждому символу входной строки.</summary>
 <param name="mapping">Функция для применения к символам строки.</param>
 <param name="str">Входная строка.</param>
 <returns>Результирующая строка.</returns>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.IterateIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}},System.String)">
 <summary>Применяет функцию <c>action</c> к индексу каждого символа строки и самому символу.</summary>
 <param name="action">Функция, предназначенная для применения к каждому символу и индексу строки.</param>
 <param name="str">Входная строка.</param>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Iterate(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
 <summary>Применяет функцию <c>action</c> к каждому символу строки.</summary>
 <param name="action">Функция, применяемая к каждому символу строки.</param>
 <param name="str">Входная строка.</param>
 <exception cref="System.ArgumentNullException">Создается при указании в качестве входной строки значения NULL.</exception>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Concat(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Возвращает новую строку, созданную посредством сцепления заданных строк с разделителем <c>sep</c>, т. е. <c>a1 + sep + ... + sep + aN</c>.</summary>
 <param name="sep">Строка разделителя, которая вставляется между строками входной последовательности.</param>
 <param name="strings">Последовательность строк, которые нужно объединить.</param>
 <returns>Новая строка, состоящая из сцепленных строк, разделенных строкой разделения.</returns>
 <exception cref="System.ArgumentNullException">Создается, если строки имеют значение NULL.</exception>
</member>
<member name="T:Microsoft.FSharp.Core.StringModule">
 <summary>Операторы функционального программирования для обработки строк. Другие операции со строками осуществляются с помощью строковых функций-членов и других функций в
  <a href="http://msdn2.microsoft.com/en-us/library/system.string.aspx">System.String</a> 
 и <a href="http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx">System.Text.RegularExpressions;</a> типах.</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.katal">
<summary>
 Единица каталитической деятельности в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.sievert">
<summary>
 Единица эквивалента дозы в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.gray">
<summary>
 Единица поглощенной дозы в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.becquerel">
<summary>
 Единица радиоактивности, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.lux">
<summary>
 Единица освещенности в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.lumen">
<summary>
 Единица силы света в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.henry">
<summary>
 Единица индукции в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.tesla">
<summary>
 Единица плотности магнитного потока в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.weber">
<summary>
 Единица магнитного потока в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.siemens">
<summary>
 Единица электрической проводимости в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.ohm">
<summary>
 Единица электрического сопротивления в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.farad">
<summary>
 Единица электрической емкости в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.volt">
<summary>
 Единица разницы электрических потенциалов, электродвижущая сила, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.coulomb">
<summary>
 Единица электрического заряда, количество электроэнергии, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.watt">
<summary>
 Единица силы, лучевого потока, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.joule">
<summary>
 Единица энергии, работы, количество тепла в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.pascal">
<summary>
 Единица давления, напряжения, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.newton">
<summary>
 Единица силы в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.hertz">
<summary>
 Единица частоты в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.candela">
<summary>
 Единица силы света в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.mole">
<summary>
 Количество вещества в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.kelvin">
<summary>
 Единица термодинамической температуры в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.ampere">
<summary>
 Единица силы тока в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.second">
<summary>
 Единица времени в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.kilogram">
<summary>
 Единица массы в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.meter">
<summary>
 Единица длины в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.metre">
<summary>
 Единица длины в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.H">
<summary>
 Синоним генри, единицы индуктивности, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.kat">
<summary>
 Синоним моль/сек, единицы каталитической активности, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Sv">
<summary>
 Синоним зиверт, единицы эквивалента дозы, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Gy">
<summary>
 Синоним грэя, единицы поглощенной дозы, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Bq">
<summary>
 Синоним беккереля, единицы радиоактивности, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.lx">
<summary>
 Синоним люкса, единицы освещенности, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.lm">
<summary>
 Синоним люмена, единицы светового потока, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.T">
<summary>
 Синоним теслы, единицы плотности магнитного потока, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Wb">
<summary>
 Синоним вебера, единицы магнитного потока, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.ohm">
<summary>
 Синоним UnitNames.ohm, единицы электрического сопротивления, в системе СИ.
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.S">
<summary>
 Синоним сименса, единицы электрического сопротивления, в системе СИ.
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.F">
<summary>
 Синоним фарада, единицы емкостного сопротивления, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.V">
<summary>
 Синоним вольта, единицы разницы электрических потенциалов, электродвижущей силы, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.C">
<summary>
 Синоним кулона, единицы электрического заряда, количества электроэнергии, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.W">
<summary>
 Синоним ватта, единицы силы потока излучения, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.J">
<summary>
 Синоним джоуля, единицы энергии, работы и количества тепла, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Pa">
<summary>
 Синоним паскаля, единицы давления, напряжения, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.N">
<summary>
 Синоним ньютона, единицы силы, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Hz">
<summary>
 Синоним герца, единицы частоты, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.cd">
<summary>
 Синоним канделы, единицы силы света, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.mol">
<summary>
 Синоним моля, единицы вещества, в системе СИ.
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.K">
<summary>
 Синоним кельвина, единицы термодинамической температуры, в системе СИ.
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.A">
<summary>
 Синоним ампера, единицы электрического потока, в системе СИ.
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.s">
<summary>
 Синоним секунды, единицы времени, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.kg">
<summary>
 Синоним килограмма, единицы массы, в системе СИ
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.m">
<summary>
 Синоним метра, единицы длины, в системе СИ
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Zero``2">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Возвращает пустую последовательность с указанным аргументом типа.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.YieldFrom``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Возвращает последовательность, которая содержит заданные значения.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Yield``2(``0)">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Возвращает последовательность длины, которая содержит заданное значение.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Where``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Оператор запроса, который выбирает те элементы на основе заданного предиката. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenByNullableDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который выполняет дополнительное упорядочение элементов, выбранных на данный момент, в порядке убывания по заданному ключу сортировки, допускающему значение null. Этот оператор может использоваться только сразу после sortBy, sortByDescending, thenBy или thenByDescending или их модификаций, допускающий значения null.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который выполняет дополнительное упорядочение элементов, выбранных на данный момент, в порядке возрастания по заданному ключу сортировки, допускающему значение null. Этот оператор может использоваться только сразу после sortBy, sortByDescending, thenBy или thenByDescending или их модификаций, допускающий значения null.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenByDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который выполняет дополнительное упорядочение элементов, выбранных на данный момент, в порядке убывания по заданному ключу сортировки. Этот оператор может использоваться только сразу после sortBy, sortByDescending, thenBy или thenByDescending или их модификаций, допускающий значения null.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который выполняет дополнительное упорядочение элементов, выбранных на данный момент, в порядке возрастания по заданному ключу сортировки. Этот оператор может использоваться только сразу после sortBy, sortByDescending, thenBy или thenByDescending или их модификаций, допускающий значения null.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.TakeWhile``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Оператор запроса, который выбирает элементы последовательности, пока они удовлетворяют заданному условию, и затем пропускает оставшиеся элементы.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Take``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},System.Int32)">
 <summary>Оператор запроса, который выбирает указанное число последовательных элементов из выбранных на данный момент.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SumByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который выбирает значение, которое может быть равно null, для каждого элемента, выбранного в данный момент, и возвращает сумму этих значений. Если какой-либо допускающий значение null элемент не имеет значения, он игнорируется.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SumBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который выбирает значение для каждого элемента, выбранного в данный момент, и возвращает сумму этих значений. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Source``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Входные данные для запросов, для которых вызов одной из перегрузок этого метода создает оболочку.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Source``2(System.Linq.IQueryable{``0})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Входные данные для запросов, для которых вызов одной из перегрузок этого метода создает оболочку.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortByNullableDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который сортирует элементы, выбранные на данный момент, в порядке убывания по заданному ключу сортировки, допускающему значение null.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который сортирует элементы, выбранные на данный момент, в порядке возрастания по заданному ключу сортировки, допускающему значение null.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortByDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который сортирует элементы, выбранные на данный момент, в порядке убывания по заданному ключу сортировки.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который сортирует элементы, выбранные на данный момент, в порядке возрастания по заданному ключу сортировки.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SkipWhile``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Оператор запроса, который обходит элементы в последовательности, пока они удовлетворяют заданному условию, и затем выбирает оставшиеся элементы.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Skip``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},System.Int32)">
 <summary>Оператор запроса, который обходит указанное число элементов, выбранных в данный момент, и выделяет оставшиеся элементы.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Select``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который проектирует каждый элемент, выбранный на данный момент.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Run``1(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Linq.QuerySource{``0,System.Linq.IQueryable}})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Выполняет данную котировку как запрос с использованием правил LINQ IQueryable.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Quote``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Указывает, что запрос должен быть передан методу Run в виде котировки.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Nth``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},System.Int32)">
 <summary>Оператор запроса, который выбирает элемент с заданным индексом среди уже выбранных.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MinByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который выбирает значение, которое может быть равно null, для каждого элемента, выбранного в данный момент, и возвращает минимальное из этих значений. Если какой-либо допускающий значение null элемент не имеет значения, он игнорируется.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MinBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который выбирает значение для каждого элемента, выбранного в данный момент, и возвращает минимальное результирующее значение. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MaxByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который выбирает значение, которое может быть равно null, для каждого элемента, выбранного в данный момент, и возвращает максимальное из этих значений. Если какой-либо допускающий значение null элемент не имеет значения, он игнорируется.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MaxBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который выбирает значение для каждого элемента, выбранного в данный момент, и возвращает максимальное результирующее значение. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.LeftOuterJoin``5(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Linq.QuerySource{``2,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``4}})">
 <summary>Оператор запроса, который сопоставляет два множества выбранных значений по совпадающим ключам и группирует результаты. Если какая-либо группа пуста, вместо нее используется группа с одним значением по умолчанию. Стандартное использование: leftOuterJoin y in elements2 on (key1 = key2) into group. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.LastOrDefault``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает последний элемент из выбранных в настоящий момент или значение по умолчанию, если элемент не найден.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Last``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает последний элемент из выбранных в настоящее время.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Join``5(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Linq.QuerySource{``2,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``4}})">
 <summary>Оператор запроса, который сопоставляет два множества выбранных значений по совпадающим ключам. Стандартное использование: join y in elements2 on (key1 = key2). 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.HeadOrDefault``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает первый элемент из выбранных в настоящий момент или значение по умолчанию, если последовательность не содержит элементов.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Head``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает первый элемент из выбранных в настоящее время.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.GroupValBy``4(Microsoft.FSharp.Linq.QuerySource{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Оператор запроса, который выбирает значение для каждого элемента, выбранного в данный момент, и группирует элементы по заданному ключу.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.GroupJoin``5(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Linq.QuerySource{``2,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``4}})">
 <summary>Оператор запроса, который сопоставляет два множества выбранных значений по совпадающим ключам и группирует результаты. Стандартное использование: groupJoin y in elements2 on (key1 = key2) into group. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.GroupBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который группирует выбранные на данный момент элементы по заданному селектору ключа.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.For``4(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Linq.QuerySource{``2,``3}})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Проецирует каждый элемент последовательности на другую последовательность и совмещает полученные последовательности в одну.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Find``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Оператор запроса, который выбирает первый элемент из выбранных на данный момент, который удовлетворяет заданному условию.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Exists``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Оператор запроса, который определяет, удовлетворяет ли выбранный на данный момент элемент условию.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ExactlyOneOrDefault``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает один, конкретный элемент из выбранных в настоящий момент или значение по умолчанию, если элемент не найден.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ExactlyOne``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает один, конкретный элемент из выбранных в настоящее время.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Distinct``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который выбирает конкретные элементы из выбранного на данный момент элемента. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Count``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>Оператор запроса, который возвращает число выбранных элементов.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Contains``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},``0)">
 <summary>Оператор запроса, который определяет, содержат ли выбранные элементы указанный элемент.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.AverageByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>Оператор запроса, который выбирает значение, которое может быть равно null, для каждого элемента, выбранного в данный момент, и возвращает среднее из этих значений. Если какой-либо допускающий значение null элемент не имеет значения, он игнорируется.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.AverageBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>Оператор запроса, который выбирает значение для каждого элемента, выбранного в данный момент, и возвращает среднее этих значений. 
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.All``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Оператор запроса, который определяет, удовлетворяют ли все выбранные на данный момент элементы условию.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.#ctor">
 <summary>Создание экземпляра этого средства построения. Воспользуйтесь синтаксисом query { ... } для синтаксиса запроса.</summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QueryBuilder">
<summary>
 Тип, используемый для поддержки синтаксиса запроса F#. Воспользуйтесь синтаксисом query { ... } для синтаксиса запроса.
</summary>
</member>
<member name="P:Microsoft.FSharp.Linq.QuerySource`2.Source">
 <summary>
 Свойство, используемое для поддержки синтаксиса запроса F#.  
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QuerySource`2.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#.  
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QuerySource`2">
<summary>
 Частичный ввод или результат запроса F#. Это тип, используемый для поддержки синтаксиса запроса F#.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToChar``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в символ. Числовые значения преобразуются в символы в соответствии с кодировкой UTF-16. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованный символ.</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToDecimal``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в тип System.Decimal, используя прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное десятичное значение.</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUIntPtr``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в целое число без знака, разрядность которого соответствует разрядности системы, используя прямое преобразование для всех числовых типов-примитивов. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение unativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToIntPtr``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в целое число со знаком, разрядность которого соответствует разрядности системы. Это прямое преобразование для всех числовых типов-примитивов. В остальных случаях для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение nativeint</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToDouble``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 64-разрядное число с плавающей точкой. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение с плавающей точкой</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToSingle``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 32-разрядное число с плавающей точкой. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение float32</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt64``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 64-разрядное целое число без знака. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint64</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt64``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 64-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int64</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt32``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 32-разрядное целое число без знака. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint32</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt32``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 32-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int32</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToEnum``1(System.Nullable{System.Int32})">
 <summary>Преобразует аргумент в определенный тип перечисления.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованный тип перечисления.</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 32-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное целое число</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt16``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 16-разрядное целое число без знака. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение uint16</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt16``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в 16-разрядное целое число со знаком. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение int16</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToSByte``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в байтовое значение со знаком. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное значение sbyte</returns>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToByte``1(System.Nullable{``0})">
 <summary>Преобразует аргумент в байтовое значение. Это прямое преобразование для всех числовых типов-примитивов. Для выполнения операции требуется соответствующий статический метод преобразования типа входных данных.</summary>
 <param name="value">Входное значение.</param>
 <returns>Преобразованное байтовое значение</returns>
</member>
<member name="T:Microsoft.FSharp.Linq.NullableModule">
<summary>
 Функции для преобразования значений, допускающие значение null
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkDivideQmark``3(System.Nullable{``0},System.Nullable{``1})">
<summary>
 Оператор деления, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_DivideQmark``3(``0,System.Nullable{``1})">
<summary>
 Оператор деления, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkDivide``3(System.Nullable{``0},``1)">
<summary>
 Оператор деления, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPercentQmark``3(System.Nullable{``0},System.Nullable{``1})">
<summary>
 Оператор модуля, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_PercentQmark``3(``0,System.Nullable{``1})">
<summary>
 Оператор модуля, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPercent``3(System.Nullable{``0},``1)">
<summary>
 Оператор модуля, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMultiplyQmark``3(System.Nullable{``0},System.Nullable{``1})">
<summary>
 Оператор умножения, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_MultiplyQmark``3(``0,System.Nullable{``1})">
<summary>
 Оператор умножения, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMultiply``3(System.Nullable{``0},``1)">
<summary>
 Оператор умножения, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMinusQmark``3(System.Nullable{``0},System.Nullable{``1})">
<summary>
 Оператор вычитания, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_MinusQmark``3(``0,System.Nullable{``1})">
<summary>
 Оператор вычитания, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMinus``3(System.Nullable{``0},``1)">
<summary>
 Оператор вычитания, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPlusQmark``3(System.Nullable{``0},System.Nullable{``1})">
<summary>
 Оператор сложения, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_PlusQmark``3(``0,System.Nullable{``1})">
<summary>
 Оператор сложения, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPlus``3(System.Nullable{``0},``1)">
<summary>
 Оператор сложения, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessGreaterQmark``1(System.Nullable{``0},System.Nullable{``0})">
<summary>
 Оператор &lt;&gt;, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkEqualsQmark``1(System.Nullable{``0},System.Nullable{``0})">
<summary>
 Оператор =, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessQmark``1(System.Nullable{``0},System.Nullable{``0})">
<summary>
 Оператор &lt;, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessEqualsQmark``1(System.Nullable{``0},System.Nullable{``0})">
<summary>
 Оператор &lt;=, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreaterQmark``1(System.Nullable{``0},System.Nullable{``0})">
<summary>
 Оператор &gt;, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreaterEqualsQmark``1(System.Nullable{``0},System.Nullable{``0})">
<summary>
 Оператор &gt;=, где допускающее null значение отображается на левой и правой сторонах
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_LessGreaterQmark``1(``0,System.Nullable{``0})">
<summary>
 Оператор &lt;&gt;, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_EqualsQmark``1(``0,System.Nullable{``0})">
<summary>
 Оператор =, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_LessQmark``1(``0,System.Nullable{``0})">
<summary>
 Оператор &lt;, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_LessEqualsQmark``1(``0,System.Nullable{``0})">
<summary>
 Оператор &lt;=, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_GreaterQmark``1(``0,System.Nullable{``0})">
<summary>
 Оператор &gt;, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_GreaterEqualsQmark``1(``0,System.Nullable{``0})">
<summary>
 Оператор &gt;=, где допускающее null значение отображается справа
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessGreater``1(System.Nullable{``0},``0)">
<summary>
 Оператор &lt;&gt;, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkEquals``1(System.Nullable{``0},``0)">
<summary>
 Оператор =, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLess``1(System.Nullable{``0},``0)">
<summary>
 Оператор &lt;, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessEquals``1(System.Nullable{``0},``0)">
<summary>
 Оператор &lt;=, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreater``1(System.Nullable{``0},``0)">
<summary>
 Оператор &gt;, где допускающее null значение отображается слева
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreaterEquals``1(System.Nullable{``0},``0)">
<summary>
 Оператор &gt;=, где допускающее null значение отображается слева
</summary>
</member>
<member name="T:Microsoft.FSharp.Linq.NullableOperators">
<summary>
 Операторы для работы со значениями, допускающими нуль
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority.RunQueryAsEnumerable``1(Microsoft.FSharp.Linq.QueryBuilder,Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Linq.QuerySource{``0,System.Collections.IEnumerable}})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Выполняет данную котировку как запрос с использованием правил LINQ IEnumerable.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority">

</member>
<member name="M:Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority.RunQueryAsValue``1(Microsoft.FSharp.Linq.QueryBuilder,Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>
 Метод, используемый для поддержки синтаксиса запроса F#. Выполняет данную котировку как запрос с использованием правил LINQ.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`1">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`2">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`4">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`5">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`6">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`7">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`8">
<summary>
 Этот тип не должен использоваться непосредственно из пользовательского кода.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.Grouping`2">
<summary>
 Тип, используемый для воссоздания группировки после применения трансформации сопоставления изменяемый -&gt; неизменяемый к результату запроса.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConversionDescription">
<summary>
 Общий MethodInfo для функции Select Описывает, как был осуществлен переход от производства неизменяемых объектов к производству анонимных объектов; при этом предоставляется достаточно информации для преобразования процесса в окончательные результаты запроса.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ProduceMoreMutables(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,System.Tuple{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConversionDescription}},Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Используя часть выражения yield или select, дающего результат для неизменяемых кортежей или неизменяемых записей, создайте эквивалентное выражение, выдающее анонимные объекты. Кроме того, верните беседу для соответствия "изменяемый-неизменяемый", чтобы впоследствии его можно было инвертировать.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.SimplifyConsumingExpr(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Упростите получение кортежей и полей записей.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.CleanupLeaf(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Очистка использования конструкций объектов с заданными свойствами в листовых выражениях, формирующих части запросов F#.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConvImmutableTypeToMutableType(Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConversionDescription,System.Type)">
<summary>
 Используя тип, включающий неизменяемые кортежи и записи, логически соответствующие типу, производимому при использовании команд yield или select, преобразуйте его в тип, включающий анонимные объекты согласно данным конверсии.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|NewAnonymousObject|_|(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Распознавание конструирования анонимных типов, записанных с использованием new AnonymousObject(&lt;e1&gt;, &lt;e2&gt;, ...)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|ObjectConstruction|_|(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Распознавание конструирования объектов, записанных с использованием new O(Prop1 = &lt;e&gt;, Prop2 = &lt;e&gt;, ...)
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|PropSetList|_|(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Проверяет, состоит ли список только из присвоений свойств заданной переменной, нулевых значений (игнорируются) и окончаний, возвращая заданную переменную (шаблон возвращает только присвоенные значения свойств)
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|LeftSequentialSeries|(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Распознавание серий последовательностей, записанных как (... ((&lt;e&gt;; &lt;e&gt;); &lt;e&gt;); ...)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.SubstHelper``1(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar[],System.Object[])">
<summary>
 Вспомогательное средство среды выполнения, используемое для оценки вложенных литералов цитирования
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.EvaluateQuotation(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Вычисляет подмножество цитат F#. Для этого сначала выполняется преобразование в выражение LINQ для подмножества выражений LINQ, представленных синтаксисом выражения на языке C#.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.QuotationToLambdaExpression``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Преобразует подмножество цитат F# в выражение LINQ для подмножества выражений LINQ, представленных синтаксисом выражений на языке C#. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.QuotationToExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Преобразует подмножество цитат F# в выражение LINQ для подмножества выражений LINQ, представленных синтаксисом выражений на языке C#.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.NewAnonymousObjectHelper``1(``0)">
<summary>
 При использовании в цитате эта функция обозначает конкретное преобразование, которое должно выполняться при преобразовании цитаты в выражение LINQ. Эта функция не должна вызываться непосредственно. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.MemberInitializationHelper``1(``0)">
<summary>
 При использовании в цитате эта функция обозначает конкретное преобразование, которое должно выполняться при преобразовании цитаты в выражение LINQ. Эта функция не должна вызываться непосредственно. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.ImplicitExpressionConversionHelper``1(``0)">
<summary>
 При использовании в цитате эта функция обозначает конкретное преобразование, которое должно выполняться при преобразовании цитаты в выражение LINQ. Эта функция не должна вызываться непосредственно. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.StackAllocate``1(System.Int32)">
 <summary>Выделяет блок памяти в стеке.</summary>
 <param name="count">Число выделяемых объектов типа T.</param>
 <returns>Типизированный указатель на выделенную память.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.SetPointerInlined``1(``0*,System.Int32,``0)">
 <summary>Назначает значение <c>value</c> ячейке памяти, на которую ссылается типизированный собственный указатель, вычисленный при добавлении индекса * sizeof&lt;'T&gt; к заданному входному указателю.</summary>
 <param name="address">Входной указатель.</param>
 <param name="index">Индекс, по которому выполняется смещение указателя.</param>
 <param name="value">Присваиваемое значение.</param>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.WritePointerInlined``1(``0*,``0)">
 <summary>Назначает значение <c>value</c> ячейке памяти, на которую ссылается заданный типизированный собственный указатель.</summary>
 <param name="address">Входной указатель.</param>
 <param name="value">Присваиваемое значение.</param>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ReadPointerInlined``1(``0*)">
 <summary>Разыменовывает данный типизированный собственный указатель.</summary>
 <param name="address">Входной указатель.</param>
 <returns>Значение по адресу указателя.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetPointerInlined``1(``0*,System.Int32)">
 <summary>Разыменовывает типизированный собственный указатель, полученный при добавлении индекса * sizeof&lt;'T&gt; к заданному входному указателю.</summary>
 <param name="address">Входной указатель.</param>
 <param name="index">Индекс, по которому выполняется смещение указателя.</param>
 <returns>Значение по адресу указателя.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.AddPointerInlined``1(``0*,System.Int32)">
 <summary>Возвращает типизированный собственный указатель с добавлением индекса * sizeof&lt;'T&gt; к заданному входному указателю.</summary>
 <param name="address">Входной указатель.</param>
 <param name="index">Индекс, по которому выполняется смещение указателя.</param>
 <returns>Типизированный указатель.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToNativeIntInlined``1(``0*)">
 <summary>Возвращает машинный адрес для данного типизированного собственного указателя.</summary>
 <param name="address">Входной указатель.</param>
 <returns>Адрес компьютера.</returns>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.OfNativeIntInlined``1(System.IntPtr)">
 <summary>Возвращает типизированный собственный указатель для указанного машинного адреса.</summary>
 <param name="address">Адрес указателя.</param>
 <returns>Типизированный указатель.</returns>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtrModule">
 <summary>Содержит операции над собственными указателями. Использование этих операторов может привести к созданию непроверяемого кода.</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Array">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.List">

</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr`1.Raw">
 <summary>Получает необработанное выражение, связанное с этим выражением, содержащим тип.</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr`1">
 <summary>Цитируемые выражения, содержащие тип. Выражения создаются с помощью цитирований в исходном тексте или программными средствами</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.Type">
 <summary>Возвращает тип выражения.</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.CustomAttributes">
 <summary>Возвращает настраиваемые атрибуты выражения.</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.WhileLoop(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее цикл while</summary>
 <param name="guard">Предикат для управления итерацией цикла.</param>
 <param name="body">Тело цикла while.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.VarSet(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее задание значения изменяемой переменной</summary>
 <param name="variable">Входная переменная.</param>
 <param name="value">Задаваемое значение.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Var(Microsoft.FSharp.Quotations.FSharpVar)">
 <summary>Формирует выражение, представляющее переменную</summary>
 <param name="variable">Входная переменная.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value``1(``0)">
 <summary>Формирует выражение, представляющее константное значение </summary>
 <param name="value">Типизированное значение.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value(System.Object,System.Type)">
 <summary>Формирует выражение, представляющее константное значение определенного типа</summary>
 <param name="value">Нетипизированный объект.</param>
 <param name="expressionType">Тип объекта.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.UnionCaseTest(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Reflection.UnionCaseInfo)">
 <summary>Формирует выражение, представляющее проверку принадлежности значения к конкретному варианту объединения</summary>
 <param name="source">Выражение для проверки.</param>
 <param name="unionCase">Описание варианта объединения.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TypeTest(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
 <summary>Формирует выражение, представляющее проверку типа.</summary>
 <param name="source">Выражение для проверки.</param>
 <param name="target">Тип целевого объекта.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TupleGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Int32)">
 <summary>Формирует выражение, представляющее получение поля кортежа</summary>
 <param name="tuple">Входной кортеж.</param>
 <param name="index">Индекс элемента кортежа, который следует получить.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryWith(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее конструкцию try/with для фильтрации и перехвата исключений.</summary>
 <param name="body">Тело выражения try.</param>
 <param name="filterVar"></param>
 <param name="filterBody"></param>
 <param name="catchVar">Переменная, привязываемая к перехваченному исключению.</param>
 <param name="catchBody">Выражение, вычисляемое при перехвате исключения.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryGetReflectedDefinition(System.Reflection.MethodBase)">
 <summary>Пытается найти сохраненное определение отражения для указанного метода. Сохраненные определения отражения добавляются в сборку F# с помощью атрибута [&lt;ReflectedDefinition&gt;].</summary>
 <param name="methodBase">Описание искомого метода.</param>
 <returns>Определения отражения или, если совпадение найдено; в противном случае — значение None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryFinally(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее конструкцию try/finally </summary>
 <param name="body">Тело выражения try.</param>
 <param name="compensation">Конечная часть выражения, предназначенного для вычисления.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ToString(System.Boolean)">
 <summary>Форматирование выражения в виде строки</summary>
 <param name="full">Указывает, нужно ли вывести на печать с подробностями метод, свойство, конструктор или объекты типа. Если значение false, эти объекты сокращаются до своего имени.</param>
 <returns>Форматированная строка.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Substitute(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Выполняет подстановку в заданном выражении, используя указанные функции для сопоставления переменных с новыми значениями. Функции должны давать согласованные результаты при каждом применении. В случае захвата переменной может произойти переименование переменной в целевом выражении.</summary>
 <param name="substitution">Функция для сопоставления переменных в выражениях.</param>
 <returns>Выражение с заданными подстановками.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Sequential(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее последовательное выполнение одного выражения за другим</summary>
 <param name="first">Первое выражение.</param>
 <param name="second">Второе выражение.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[])">
 <summary>Позволяет интерактивным средам, таким как F# Interactive, явно регистрировать сериализованные ресурсы, представляющие сохраняемые определения верхнего уровня. Строка указывает уникальное имя добавляемого ресурса. Формат байтов — кодировка, созданная компилятором F#.</summary>
 <param name="assembly">Сборка, связанная с ресурсом.</param>
 <param name="resource">Уникальное имя добавляемого ресурса.</param>
 <param name="serializedValue">Сериализованный ресурс, регистрируемый средой.</param>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Quote(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее вложенный литерал цитирования</summary>
 <param name="inner">Выражение, заключаемое в кавычки.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Формирует выражение, представляющее запись в статическое свойство </summary>
 <param name="property">Описание свойства.</param>
 <param name="value">Задаваемое значение.</param>
 <param name="indexerArgs">Список индексов свойства, если это индексированное свойство.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Формирует выражение, представляющее запись в свойство объекта</summary>
 <param name="obj">Входной объект.</param>
 <param name="property">Описание свойства.</param>
 <param name="value">Задаваемое значение.</param>
 <param name="indexerArgs">Список индексов свойства, если это индексированное свойство.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Формирует выражение, представляющее чтение статического свойства </summary>
 <param name="property">Описание свойства.</param>
 <param name="indexerArgs">Список индексов свойства, если это индексированное свойство.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Формирует выражение, представляющее чтение свойства объекта</summary>
 <param name="obj">Входной объект.</param>
 <param name="property">Описание свойства.</param>
 <param name="indexerArgs">Список индексов свойства, если это индексированное свойство.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражение, представляющее создание значения варианта объединения</summary>
 <param name="unionCase">Описание варианта объединения.</param>
 <param name="arguments">Список аргументов для варианта.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewTuple(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражение, представляющее создание значения кортежа F#</summary>
 <param name="elements">Список элементов кортежа.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewRecord(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражения с конструкциями записей </summary>
 <param name="recordType">Тип записи.</param>
 <param name="elements">Список элементов записи.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражение, представляющее вызов конструктора объекта</summary>
 <param name="constructorInfo">Описание конструктора.</param>
 <param name="arguments">Список аргументов конструктора.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewDelegate(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpVar},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее создание значения делегата для заданного типа</summary>
 <param name="delegateType">Тип делегата.</param>
 <param name="parameters">Параметры делегата.</param>
 <param name="body">Тело функции.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewArray(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражение, представляющее создание значения массива, инициализируемого с помощью заданных элементов</summary>
 <param name="elementType">Тип элементов массива.</param>
 <param name="elements">Список элементов массива.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.LetRecursive(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует рекурсивные выражения, связанные с конструкциями let rec</summary>
 <param name="bindings">Список привязок выражения let.</param>
 <param name="body">Часть выражения, в составе которой находятся привязки.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Let(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражения, связанные с конструкциями let</summary>
 <param name="letVariable">Переменная в выражении let.</param>
 <param name="letExpr">Выражение, привязанное к переменной.</param>
 <param name="body">Часть выражения, в составе которой находится привязка.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Lambda(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее конструирование значения функции F#</summary>
 <param name="parameter">Параметр для функции.</param>
 <param name="body">Тело функции.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.IfThenElse(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Создает выражения if ... then ... else.</summary>
 <param name="guard">Условное выражение.</param>
 <param name="thenExpr">Часть выражения <c>then</c>.</param>
 <param name="elseExpr">Часть выражения <c>else</c>.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GlobalVar``1(System.String)">
 <summary>Получает или создает новую переменную с заданными именем и типом из глобального пула общих переменных, индексированных по имени и типу. Тип задается явным или выводимым параметром типа</summary>
 <param name="name">Имя переменной.</param>
 <returns>Созданная или полученная типизированная глобальная переменная.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GetFreeVars">
 <summary>Получает свободные переменные выражения в виде списка.</summary>
 <returns>Последовательность свободных переменных в выражении.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Создает выражение for i = ... to ... do ..., представляющее циклы для диапазонов целых значений</summary>
 <param name="loopVariable">Часть выражения, объявляющая переменную цикла.</param>
 <param name="start">Часть выражения, задающая начальное значение переменной цикла.</param>
 <param name="endExpr">Часть выражения, задающая конечное значение переменной цикла.</param>
 <param name="body">Часть выражения, представляющая тело цикла.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее запись в поле объекта</summary>
 <param name="obj">Входной объект.</param>
 <param name="fieldInfo">Описание поля, в котором осуществляется запись.</param>
 <param name="value">Значение, устанавливаемое для поля.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее запись в статическое поле </summary>
 <param name="fieldInfo">Описание поля, в котором осуществляется запись.</param>
 <param name="value">Задаваемое значение для поля.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo)">
 <summary>Формирует выражение, представляющее доступ к полю объекта</summary>
 <param name="obj">Входной объект.</param>
 <param name="fieldInfo">Описание поля, к которому осуществляется доступ.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(System.Reflection.FieldInfo)">
 <summary>Формирует выражение, представляющее доступ к статическому полю</summary>
 <param name="fieldInfo">Описание поля, к которому осуществляется доступ.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize(System.Type,Microsoft.FSharp.Collections.FSharpList{System.Type},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},System.Byte[])">
 <summary>При использовании синтаксиса цитирования (&lt;@ @&gt;) и связанных с ним цитируемых типизированных выражений данная функция вызывается автоматически. Байты являются сериализованным двоичным представлением несвязанной формы указанного выражения и аргумент System.Type — это любой тип в сборке, где указанное выражение происходит, т. е. помогает ограничить интерпретацию ссылок на различные сборки в байтах.</summary>
 <param name="qualifyingType">Тип в сборке, где возникает цитирование.</param>
 <param name="spliceTypes">Список разделенных типов.</param>
 <param name="spliceExprs">Список разделенных выражений.</param>
 <param name="bytes">Сериализованная форма цитируемого выражения.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.DefaultValue(System.Type)">
 <summary>Формирует выражение, представляющее вызов конструктора объекта по умолчанию</summary>
 <param name="expressionType">Тип, в котором вызывается конструктор.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Coerce(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
 <summary>Формирует выражение, представляющее приведение выражения к типу</summary>
 <param name="source">Приводимое выражение.</param>
 <param name="target">Тип целевого объекта.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Cast``1(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Возвращает новое типизированное выражение на основании базового выражения, аннотированного типом времени выполнения. Для использования этой функции, как правило, требуется аннотация типа, и использование неверной аннотации может позднее привести к исключению времени выполнения.</summary>
 <param name="source">Выражение для приведения.</param>
 <returns>Результирующее типизированное выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражение, которое представляет вызов метода экземпляра, связанного с объектом</summary>
 <param name="obj">Входной объект.</param>
 <param name="methodInfo">Описание вызываемого метода.</param>
 <param name="arguments">Список аргументов метода.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Формирует выражение, которое представляет вызов статического метода или связанного с модулем функции</summary>
 <param name="methodInfo">MethodInfo, описывающий вызываемый метод.</param>
 <param name="arguments">Список аргументов метода.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Applications(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Формирует выражение, представляющее применение значения функции первого класса к нескольким аргументам</summary>
 <param name="functionExpr">Применяемая функция.</param>
 <param name="arguments">Список списков аргументов функции.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Application(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее применение значения функции первого класса к одному аргументу.</summary>
 <param name="functionExpr">Применяемая функция.</param>
 <param name="argument">Аргумент функции.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressSet(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее задание значения, которое хранится по определенному адресу.</summary>
 <param name="target">Целевое выражение.</param>
 <param name="value">Задаваемое по адресу значение.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressOf(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Формирует выражение, представляющее получение адреса значения.</summary>
 <param name="target">Целевое выражение.</param>
 <returns>Результирующее выражение.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr">
 <summary>Цитируемые выражения, аннотированные с помощью значений System.Type. </summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Type">
 <summary>Тип, связанный с данной переменной</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Name">
 <summary>Объявленное имя переменной</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.IsMutable">
 <summary>Указывает, представляет ли переменная изменяемое место хранения</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.Global(System.String,System.Type)">
 <summary>Извлекает или создает новую переменную с заданными именем и типом из глобального пула общих переменных, индексация которых производится по имени и типу</summary>
 <param name="name">Имя переменной.</param>
 <param name="typ">Тип, связанный с данной переменной.</param>
 <returns>Извлеченная или созданная переменная.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.#ctor(System.String,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Создает новую переменную с заданными именем, типом и изменяемостью</summary>
 <param name="name">Объявленное имя переменной.</param>
 <param name="typ">Тип, связанный с данной переменной.</param>
 <param name="isMutable">Указывает, представляет ли переменная изменяемое место хранения. Значение по умолчанию — false.</param>
 <returns>Созданная переменная.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpVar">
 <summary>Сведения в точке привязки переменной</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Выполняет повторное формирование комбинированных выражений. Первый параметр должен являться объектом, возвращаемым вариантом <c>ShapeCombination</c> активного шаблона в данном модуле.</summary>
 <param name="shape">Входная фигура.</param>
 <param name="arguments">Список аргументов.</param>
 <returns>Выражение, подвергшееся повторному формированию.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.ShapePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон, выполняющий полную декомпозицию с просмотром дерева выражений в виде структуры привязок</summary>
 <param name="input">Входное выражение.</param>
 <returns>Разложенные Var, Lambda или ConstApp.</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShapeModule">
 <summary>Активные шаблоны для прохода, просмотра, повторного формирования и преобразования выражений универсальным способом</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertySetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>Активный шаблон для распознавания методов задания свойств со связанным атрибутом ReflectedDefinition</summary>
 <param name="propertyInfo">Описание свойства.</param>
 <returns>Выражение определения метода, если оно найдено; в противном случае — значение None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertyGetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>Активный шаблон для распознавания методов получения свойств или значений в модулях со связанным атрибутом ReflectedDefinition.</summary>
 <param name="propertyInfo">Описание свойства.</param>
 <returns>Выражение определения метода, если оно найдено; в противном случае — значение None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.MethodWithReflectedDefinitionPattern(System.Reflection.MethodBase)">
 <summary>Активный шаблон для распознавания методов со связанным атрибутом ReflectedDefinition</summary>
 <param name="methodBase">Описание метода.</param>
 <returns>Выражение определения метода, если оно найдено; в противном случае — значение None.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SpecificCallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Параметризованный активный шаблон для распознавания вызовов указанной функции или метода. Возвращаемые элементы представляют собой необязательный целевой объект (присутствующий, если целевым объектом является метод экземпляра), создание экземпляра универсального типа (непустого, если целевым объектом является создание универсального экземпляра) и аргументы функции или метода.</summary>
 <param name="templateParameter">Выражение входного шаблона для задания вызываемого метода.</param>
 <returns>Необязательный целевой объект (присутствующий, если целевым объектом является метод экземпляра), создание экземпляра универсального типа (непустого, если целевым объектом является создание универсального экземпляра) и аргументы функции или метода.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений int64 без знака</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр uint64</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений int64</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр int64</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений int32 без знака</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр uint32</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений int32</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр int32</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений int16 без знака</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр uint16</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений int16</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр int16</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений типа byte</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр byte</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SBytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений типа byte со знаком</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр sbyte</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.CharPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений символов Юникода</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр char</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.DoublePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных 64-разрядных выражений с плавающей запятой</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр float</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SinglePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных 32-разрядных выражений с плавающей запятой</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр float32</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.StringPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений string</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр string</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BoolPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений boolean</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр bool</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UnitPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания постоянных выражений <c>()</c></summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр unit</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.OrElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений формы <c>a || b</c> </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.AndAlsoPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений формы <c>a&amp;&amp;b</c> </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.ApplicationsPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих применение значения функции первого класса (возможно каррированного или представленного в виде кортежа).</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * список Expr list)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.LambdasPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих значение функции первого класса (возможно каррированного или представленного в виде кортежа).</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (список Var list * Expr)</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatternsModule">
 <summary>Содержит набор производных активных шаблонов F#, предназначенных для анализа объектов выражений F#</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих задание изменяемой переменной.</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Var * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих переменную</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр Var</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих постоянное значение</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (obj * Type)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.UnionCaseTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознаваний выражений, представляющих проверку принадлежности значения к конкретному варианту объединения.</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * UnionCaseInfo)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TypeTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих динамическую проверку типов</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Type)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TupleGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих получение поля кортежа</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * int)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryFinallyPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих конструкцию try/finally </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryWithPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих конструкцию try/with для фильтрации и перехвата исключений </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Var * Expr * Var * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.SequentialPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражению, представляющих последовательное выполнение одного выражения за другим</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuotePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих вложенный литерал цитирования</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр Expr</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertySetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих задание статического свойства, свойства экземпляра или нефункционального значения, объявленного в модуле</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr параметр * PropertyInfo * Expr list * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertyGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих чтение какого-либо статического свойства, свойства экземпляра или нефункционального значения, объявленного в модуле</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr параметр * PropertyInfo * список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewTuplePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих формирование значений кортежа</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewUnionCasePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих формирование значений конкретных вариантов объединения</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (UnionCaseInfo * список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewRecordPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих формирование значений записи</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (тип * список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewObjectPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих вызов конструкторов объектов</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>Параметр (ConstructorInfo * список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewDelegatePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих формирование значений делегата</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Type * список Var * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.DefaultValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих вызовы конструктора конструкции по умолчанию</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр Type</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewArrayPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих формирование массивов </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (тип * список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetRecursivePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих рекурсивные привязки let одной или нескольких переменных</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр ((Var * Expr) список * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих привязки let</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Var * Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LambdaPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих значения функций первого класса</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Var * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.IfThenElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих условия</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.WhileLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих циклы while </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ForIntegerRangeLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих применение циклов к диапазонам целых чисел</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Var * Expr * Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих задание статического поля или поля экземпляра. </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (параметр Expr * FieldInfo * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих получение статического поля или поля экземпляра. </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (параметр Expr * FieldInfo)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CoercePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих приведение одного типа к другому</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Type)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих вызовы, которые обращены к статическим методам, методам экземпляра, и выражения, представляющие функции, определяемые в модулях</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (параметр Expr * MethodInfo * список Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ApplicationPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих применение значений функций первого класса</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих задание значения, которое содержится по какому-либо адресу </summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр (Expr * Expr)</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressOfPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Активный шаблон для распознавания выражений, представляющих получение адреса значения</summary>
 <param name="input">Входное выражение, с которым выполняется сравнение.</param>
 <returns>параметр Expr</returns>
</member>
<member name="T:Microsoft.FSharp.Quotations.PatternsModule">
 <summary>Содержит набор активных шаблонов-примитивов F#, предназначенных для анализа объектов выражений F#</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[])">
 <summary>Возвращает тип <c>System.Type</c>, представляющий тип кортежа F# с заданными типами элементов</summary>
 <param name="types">Массив типов для элементов кортежа.</param>
 <returns>Тип, представляющий кортеж, содержащий входные элементы.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
 <summary>Возвращает объект <c>System.Type</c>, представляющий тип функции F# с заданными доменом и диапазоном</summary>
 <param name="domain">Тип входного значения функции.</param>
 <param name="range">Тип выходного значения функции.</param>
 <returns>Тип функции F# с указанным доменом и диапазоном.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Возвращает значение true, если <c>typ</c> является представлением типа объединения F# или типом среды выполнения значения данного типа</summary>
 <param name="typ">Проверяемый тип.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Значение true, если проверка типа завершилась успешно.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
 <summary>Возвращает значение true, если <c>typ</c> является представлением типа кортежа F# </summary>
 <param name="typ">Проверяемый тип.</param>
 <returns>Значение true, если проверка типа завершилась успешно.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Возвращает значение true, если <c>typ</c> является представлением типа записи F#. </summary>
 <param name="typ">Проверяемый тип.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Значение true, если проверка типа завершилась успешно.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
 <summary>Возвращает значение true, если <c>typ</c> является значением <c>System.Type</c>, соответствующим скомпилированной форме модуля F#. </summary>
 <param name="typ">Проверяемый тип.</param>
 <returns>Значение true, если проверка типа завершилась успешно.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
 <summary>Возвращает значение true, если <c>typ</c> является представлением типа функции F# или типом замкнутого выражения среды выполнения, реализующего тип функции F#</summary>
 <param name="typ">Проверяемый тип.</param>
 <returns>Значение true, если проверка типа завершилась успешно.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsExceptionRepresentation(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Возвращает значение true, если <c>typ</c> является представлением объявления исключения F#</summary>
 <param name="exceptionType">Проверяемый тип.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Значение true, если проверка типов вызвала исключение.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Получает варианты типа объединения.</summary>

 <remarks>Предполагается, что заданный тип является типом объединения. В противном случае во время предварительного вычисления создается исключение ArgumentException.</remarks>
 <param name="unionType">Тип входного объединения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом объединения.</exception>
 <returns>Массив описаний вариантов заданного типа объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
 <summary>Получает элементы кортежа из представления типа кортежа F#.</summary>
 <param name="tupleType">Тип входного кортежа.</param>
 <returns>Массив типов, содержащихся в заданном типе кортежа.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Считывает все поля из значения записи в порядке объявления</summary>

 <remarks>Предполагается, что заданное входное значение является значением записи. В противном случае создается исключение ArgumentException.</remarks>
 <param name="recordType">Тип входной записи.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Массив описаний свойств типа записи.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
 <summary>Получает типы домена и диапазона из типа функции F# или из типа замкнутого выражения среды выполнения, реализующего тип функции F#</summary>
 <param name="functionType">Тип входной функции.</param>
 <returns>Кортеж из домена  и типов диапазона входной функции.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetExceptionFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Считывает все поля из объявления исключения F# в порядке объявления</summary>

 <remarks>Предполагается, что <c>exceptionType</c> — тип представления исключения В противном случае создается исключение ArgumentException.</remarks>
 <param name="exceptionType">Считываемый тип исключения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <exception cref="System.ArgumentException">Вызывается, если заданный тип не является исключением.</exception>
 <returns>Массив, содержащий класс PropertyInfo каждого поля в исключении.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">
 <summary>Содержит операции, связанные с конструированием и анализом таких типов F#, как записи, объединения и кортежи</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Предполагается, что заданный тип является типом объединения. В противном случае во время предварительного вычисления создается исключение ArgumentException.</summary>

 <remarks>Использование вычисляемой функции более эффективно по сравнению с вызовом GetUnionCase, поскольку путь, выполняемый вычисляемой функцией, оптимизируется на основании сведений о типе считываемых значений.</remarks>
 <param name="unionType">Тип объединения для оптимизации чтения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Оптимизированная функция для чтения тегов заданного типа объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Выполняет предварительное вычисление свойства или статического метода чтения целого числа, представляющего тег варианта типа объединения.</summary>
 <param name="unionType">Тип объединения для чтения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Описание средства чтения варианта объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Выполняет предварительное вычисление функции для чтения всех полей определенного варианта дискриминатора типа объединения</summary>

 <remarks>Как правило, применение вычисляемой функции приносит результаты быстрее, чем выполнение соответствующего вызова GetFields</remarks>
 <param name="unionCase">Описание варианта объединения, предназначенного для чтения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Функция, предназначенная для чтения полей заданного варианта объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Метод, конструирующий объекты заданного варианта</summary>
 <param name="unionCase">Описание варианта объединения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Описание конструктора заданного варианта объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Предварительно вычисляет функцию для конструирования значения различаемого объединения для определенного варианта объединения. </summary>
 <param name="unionCase">Описание варианта объединения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Функция для конструирования значений заданного варианта объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)">
 <summary>Предварительно вычисляет функцию для считывания значений определенного типа кортежа</summary>

 <remarks>Предполагается, что заданный тип представляет собой TupleType. В противном случае во время предварительного вычисления создается исключение ArgumentException.</remarks>
 <param name="tupleType">Тип кортежа для считывания.</param>
 <exception cref="System.ArgumentException">Создается, если заданный тип не является типом кортежа.</exception>
 <returns>Функция для считывания значений заданного типа кортежа.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)">
 <summary>Получает сведения о способе чтения поля кортежа</summary>
 <param name="tupleType">Тип входного кортежа.</param>
 <param name="index">Индекс элемента кортежа, который следует описать.</param>
 <returns>Описание элемента типа кортежа, необязательный дополнительный тип и индекс, если кортеж большой.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)">
 <summary>Получает метод, конструирующий объекты заданного типа кортежа. Для небольших кортежей дополнительные типы не возвращаются.</summary>
 
 <remarks>Для больших кортежей возвращается дополнительный тип, указывающий на то, что для типа кортежа использовалась вложенное кодирование. В этом случае тип префикса типа кортежа соответствует указанному, а объект этого следует создать и передать как последний аргумент классу ConstructorInfo. Рекурсивный вызов PreComputeTupleConstructorInfo можно использовать для определения конструктора этого типа суффикса.</remarks>
 <param name="tupleType">Тип входного кортежа.</param>
 <returns>Описание конструктора типа кортежа и необязательный дополнительный тип для больших кортежей.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)">
 <summary>Предварительно вычисляет функцию для считывания значений определенного типа кортежа</summary>

 <remarks>Предполагается, что заданный тип представляет собой TupleType. В противном случае во время предварительного вычисления создается исключение ArgumentException.</remarks>
 <param name="tupleType">Тип кортежа для чтения.</param>
 <exception cref="System.ArgumentException">Создается, если заданный тип не является типом кортежа.</exception>
 <returns>Функция для чтения определенного типа кортежа.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Предварительно вычисляет функцию для считывания всех полей из записи. Поля возвращаются в том же порядке, что и те поля, о которых сообщалось в вызове Microsoft.FSharp.Reflection.Type.GetInfo для данного типа.</summary>

 <remarks>Предполагается, что заданный тип является типом записи. В противном случае во время предварительного вычисления создается исключение ArgumentException. Использование вычисляемой функции обычно повышает производительность по сравнению с соответствующим вызовом Value.GetInfo, поскольку путь, выполняемый вычисляемой функцией, оптимизируется на основании сведений о типе считываемых значений.</remarks>
 <param name="recordType">Тип считываемой записи.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом записи.</exception>
 <returns>Оптимизированное средство чтения для заданного типа записи.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)">
 <summary>Предварительно вычисляет функцию для считывания определенного поля из записи. Предполагается, что заданный тип представляет собой тип RecordType с полем с указанным именем. В противном случае во время предварительного вычисления создается исключение ArgumentException.</summary>

 <remarks>Использование вычисляемой функции обычно повышает производительность по сравнению с соответствующим вызовом Value.GetInfo, поскольку путь, выполняемый вычисляемой функцией, оптимизируется на основании сведений о типе считываемых значений.</remarks>
 <param name="info">Объект PropertyInfo поля, предназначенного для чтения.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом записи.</exception>
 <returns>Функция, используемая для чтения указанного поля из записи.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Получает ConstructorInfo для типа записи</summary>
 <param name="recordType">Тип записи.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>ConstructorInfo для заданного типа записи.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Предварительно вычисляет функцию для конструирования значения записи. </summary>

 <remarks>Предполагается, что заданный тип является типом записи. В противном случае во время предварительного вычисления создается исключение ArgumentException.</remarks>
 <param name="recordType">Тип конструируемой записи.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом записи.</exception>
 <returns>Функция для конструирования записей заданного типа.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Создает значение варианта объединения.</summary>
 <param name="unionCase">Описание варианта объединения, предназначенного для создания.</param>
 <param name="args">Массив аргументов, которые формируют заданный вариант.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <returns>Сконструированный вариант объединения.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[],System.Type)">
 <summary>Создает экземпляр типа кортежа.</summary>

 <remarks>Предполагается, что указан, как минимум, один элемент . В противном случае создается исключение ArgumentException.</remarks>
 <param name="tupleElements">Массив полей кортежа.</param>
 <param name="tupleType">Создаваемый тип кортежа.</param>
 <exception cref="System.ArgumentException">Вызывается, если не указан ни один элемент.</exception>
 <returns>Экземпляр типа кортежа с заданными элементами.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Создает экземпляр типа записи.</summary>

 <remarks>Предполагается, что заданное входное значение является типом записи.</remarks>
 <param name="recordType">Тип создаваемой записи.</param>
 <param name="values">Массив значений для инициализации записи.</param>
 <param name="bindingFlags">Необязательные флаги привязки для записи.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом записи.</exception>
 <returns>Созданная запись.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object})">
 <summary>Формирует типизированную функцию посредством объекта из реализации динамической функции</summary>
 <param name="functionType">Тип функции реализации.</param>
 <param name="implementation">Нетипизированная лямбда реализации функции.</param>
 <returns>Типизированная функция из заданной динамической реализации.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Определяет вариант объединения и его поля для какого-либо объекта</summary>

 <remarks>Предполагается, что заданное входное значение является значением варианта объединения. В противном случае создается исключение ArgumentException. Если тип не указан, для определения соответствующего типа объединения используется тип среды выполнения входного объекта. Если входной объект может принимать значение NULL, необходимо обязательно указать тип. Например, значения параметров могут представляться значением NULL.</remarks>
 <param name="value">Входной вариант объединения.</param>
 <param name="unionType">Тип объединения, содержащий значение.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является значением варианта объединения.</exception>
 <returns>Описание варианта объединения и его полей.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">
 <summary>Считывает все поля из кортежа.</summary>

 <remarks>Предполагается, что заданное входное значение является значением кортежа. В противном случае создается исключение ArgumentException.</remarks>
 <param name="tuple">Входной кортеж.</param>
 <exception cref="System.ArgumentException">Вызывается, если тип входных данных не является значением кортежа.</exception>
 <returns>Массив из полей данного кортежа.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">
 <summary>Считывает поле из значения кортежа.</summary>

 <remarks>Предполагается, что заданное входное значение является значением кортежа. В противном случае создается исключение ArgumentException.</remarks>
 <param name="tuple">Входной кортеж.</param>
 <param name="index">Индекс считываемого поля.</param>
 <returns>Значение поля.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Считывает все поля из значения записи.</summary>

 <remarks>Предполагается, что заданное входное значение является значением записи. В противном случае создается исключение ArgumentException.</remarks>
 <param name="record">Объект записи.</param>
 <param name="bindingFlags">Необязательные флаги привязки для записи.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом записи.</exception>
 <returns>Массив полей из записи.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
 <summary>Считывает поле из значения записи.</summary>

 <remarks>Предполагается, что заданное входное значение является значением записи. В противном случае создается исключение ArgumentException.</remarks>
 <param name="record">Объект записи.</param>
 <param name="info">Класс PropertyInfo, описывающий поле, которое нужно считать.</param>
 <exception cref="System.ArgumentException">Создается, если тип входных данных не является типом записи.</exception>
 <returns>Поле из записи.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Считывает все поля из значения, сформированного с использованием экземпляра объявления исключения F#</summary>

 <remarks>Предполагается, что заданное входное значение является значением исключения F#. В противном случае создается исключение ArgumentException.</remarks>
 <param name="exn">Экземпляр исключения.</param>
 <param name="bindingFlags">Необязательные флаги привязки.</param>
 <exception cref="System.ArgumentException">Вызывается, если входной тип не является исключением F#.</exception>
 <returns>Поля из данного исключения.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">
 <summary>Содержит операции, связанные с конструированием и анализом значений, которые связаны с такими типами F#, как записи, объединения и кортежи.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
 <summary>Целочисленный тег варианта.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
 <summary>Имя варианта.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
 <summary>Тип, в котором происходит вариант.</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
 <summary>Поля, связанные с вариантом, представленным объектом PropertyInfo.</summary>
 <returns>Поля, связанные с вариантом.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributesData">
 <summary>Возвращает данные настраиваемых атрибутов, связанные с вариантом.</summary>
 <returns>Список элементов данных пользовательского атрибута.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes(System.Type)">
 <summary>Возвращает настраиваемые атрибуты, связанные с вариантом, который соответствует заданному типу атрибута.</summary>
 <param name="attributeType">Тип возвращаемых атрибутов.</param>
 <returns>Массив настраиваемых атрибутов.</returns>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes">
 <summary>Возвращает настраиваемые атрибуты, связанные с вариантом.</summary>
 <returns>Массив настраиваемых атрибутов.</returns>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
 <summary>Представляет вариант типа различаемого объединения</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions">
<summary>
 Запись параметров для управления структурным форматированием. Для интерактивных свойств F#, соответствующих свойствам данного значения, доступ может осуществляться через значение fsi. Формат объектов с плавающей точкой, представленный в том же формате, который принимается System.Double.ToString, т. е. f6 или g15. Если значение ShowProperties задано, в процессе печати будут оцениваться свойства отображаемых значений. Это может вызвать дополнительную нагрузку на вычислительные ресурсы. Если задано свойство ShowIEnumerable, в процессе печати будет принудительно выполнено вычисление объектов IEnumerable на небольшую ограниченную глубину, как определено параметрами печати. Это может вызвать дополнительную нагрузку на вычислительные ресурсы во время печати. &lt;example&gt; Из F# Interactive настройки по умолчанию можно скорректировать, используя, к примеру, &lt;pre&gt; open Microsoft.FSharp.Compiler.Interactive.Settings;; setPrintWidth 120;; &lt;/pre&gt; &lt;/example&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Layout">
<summary>
 Данные, представляющие структурированные макеты определений.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.layout_to_string(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Преобразуйте любое значение в макет, используя заданные параметры форматирования. Затем макет можно обработать с использованием механизмов форматирования отображения, например механизмов из модуля LayoutOps. any_to_string b output_any создаются с использованием any_to_layout с параметрами форматирования по умолчанию.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Выведите любое значение в канал, используя то же множество правил форматирования, что и в any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.any_to_string``1(``0)">
<summary>
 Преобразуйте значение в строку, используя стандартное средство форматирования. Данные, как правило, форматируются в структурированный формат, т. е. списки форматируются с использованием нотации [1;2]. Подробности формата не указаны и могут меняться в зависимости от версии и в соответствии с флагами, присвоенными компилятору F#. Формат должен быть человекочитаемым, а не машиночитаемым. Если требуются альтернативные общие формат, необходимо создать собственное средство форматирования, используя код в реализации данного файла в качестве отправной точки. Данные из других языков .NET языков форматируются с использованием виртуального вызова Object.ToString() в версии ввода с оболочкой.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1,System.Int32)">
<summary>
 Для ограничивающих шаблонов списковых последовательностей (списки, массивы и т. д.) необходимо развернуть список элементов, используя (проект и z) и создавая список шаблонов с использованием itemL. По достижении максимальной длины (перед исчерпанием) можно выполнить усечение.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}},Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 См. tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Макет, как список F#.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Макет как параметр F#.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Расположение списка вертикально.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Расположение двух элементов вертикально.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Формирование кортежа из макетов.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Размещение скобок вокруг макета.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Размещение квадратных скобок вокруг макета.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Размещение круглых скобок вокруг макета.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Объединение макетов в список, разделяемый с использованием заданного макета.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Присоединение макетов в список, разделяемый точками с запятой.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Присоединение макетов в список, разделяемый пробелами.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Присоединение макетов в список, разделяемый запятыми.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение с возможностью разрыва с отступом ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение с возможностью разрыва с отступом ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение с возможностью разрыва с отступом ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение с потенциальной возможностью разрыва с отступом indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение с потенциальной возможностью разрыва с отступом indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение с потенциальной возможностью разрыва с отступом indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_HatHat(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Присоединение, неразрывное. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.leftL(System.String)">
<summary>
 Строка, представляющая собой левую скобку (справа отсутствует пространство).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.rightL(System.String)">
<summary>
 Строка, представляющая собой правую скобку (слева отсутствует пространство).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepL(System.String)">
<summary>
 Строка, которая не требует пробелов ни с одной из сторон.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.wordL(System.String)">
<summary>
 Строковый лист 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.objL(System.Object)">
<summary>
 Непрерывный лист, который должен быть преобразован в строку модулем работы с шаблонами. Это позволяет осуществлять настройку листовых шаблонов цифр, строк и других компонентов в соответствие с региональными стандартами.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Это пустой макет?
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.emptyL">
<summary>
 Пустой макет
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps">
<summary>
 Макет — это последовательность строк, соединенных вместе. Строки классифицируются как слова, разделители, открывающие и закрывающие скобки. Эта классификация определяет, куда вставляются пробелы. Соединение может быть неразрывным, разрываемым или порванным. При разрыве соединения макет RHS возникает на следующей строке с дополнительными отступами. Макет можно сжать до заданной ширины, принудительно используя пробелы при необходимости.
</summary>
</member>
</members>
</doc>